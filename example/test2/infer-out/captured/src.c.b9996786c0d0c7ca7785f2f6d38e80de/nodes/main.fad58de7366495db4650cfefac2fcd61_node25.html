<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<title>main.fad58de7366495db4650cfefac2fcd61_node25</title>
<style type="text/css">
body { color:#000000; background-color:#ffffff }
body { font-family:Helvetica, sans-serif; font-size:10pt }
h1 { font-size:14pt }
.code { border-collapse:collapse; width:100%; }
.code { font-family: "Andale Mono", monospace; font-size:10pt }
.code { line-height: 1.2em }
.comment { color: green; font-style: oblique }
.keyword { color: blue }
.string_literal { color: red }
.color_black { color: black }
.color_blue { color: blue }
.color_green { color: green }
.color_red { color: red }
.color_orange { color: orange }
.directive { color: darkmagenta }
.expansion { display: none; }
.visited:hover .expansion { display: block; border: 2px solid #FF0000; padding: 2px; background-color:#FFF0F0; font-weight: normal; -webkit-border-radius:5px; -webkit-box-shadow:1px 1px 7px #000; position: absolute; top: -1em; left:10em; z-index: 1 }
.visited { color: darkmagenta; background-color:LemonChiffon; position: relative }
.visitedproof:hover .expansion { display: block; border: 2px solid #FF0000; padding: 2px; background-color:#FFF0F0; font-weight: normal; -webkit-border-radius:5px; -webkit-box-shadow:1px 1px 7px #000; position: absolute; top: -1em; left:10em; z-index: 1 }
.visitedproof { color: darkmagenta; background-color:lightgreen; position: relative }
.dangling:hover .expansion { display: block; border: 2px solid #FF0000; padding: 2px; background-color:#FFF0F0; font-weight: normal; -webkit-border-radius:5px; -webkit-box-shadow:1px 1px 7px #000; position: absolute; top: -1em; left:10em; z-index: 1 }
.dangling { color: gray; background-color:white; position: relative }
.num { width:2.5em; padding-right:2ex; background-color:#eeeeee }
.num { text-align:right; font-size: smaller }
.num { color:#444444 }
.line { padding-left: 1ex; border-left: 3px solid #ccc }
.line { white-space: pre }
.msg { background-color:#fff8b4; color:#000000 }
.msg { -webkit-box-shadow:1px 1px 7px #000 }
.msg { -webkit-border-radius:5px }
.msg { font-family:Helvetica, sans-serif; font-size: smaller }
.msg { font-weight: bold }
.msg { float:left }
.msg { padding:0.5em 1ex 0.5em 1ex }
.msg { margin-top:10px; margin-bottom:10px }
.msg { max-width:60em; word-wrap: break-word; white-space: pre-wrap;}
.mrange { background-color:#dfddf3 }
.mrange { border-bottom:1px solid #6F9DBE }
.PathIndex { font-weight: bold }
table.simpletable { padding: 5px; font-size:12pt; margin:20px; border-collapse: collapse; border-spacing: 0px; }
td.rowname { text-align:right; font-weight:bold; color:#444444; padding-right:2ex; }
</style>
</head>
<body>
<center><h1>Cfg Node <a href="./../../src.c.b9996786c0d0c7ca7785f2f6d38e80de.html#LINE54">25</a></h1></center>PROC: <a href="./../main.fad58de7366495db4650cfefac2fcd61.html">main</a> LINE: <a href="./../../src.c.b9996786c0d0c7ca7785f2f6d38e80de.html#LINE54">54</a>
<br>PREDS:
<a href="./../nodes/main.fad58de7366495db4650cfefac2fcd61_node26.html"><span class='visited'>N_26<span class='expansion'>node26 preds:23 succs:25 exn: </span></span></a><br>SUCCS: 
<a href="./../nodes/main.fad58de7366495db4650cfefac2fcd61_node22.html"><span class='dangling'>N_22<span class='expansion'>node22 preds:27 25 succs:23 24 exn: 
NOT VISITED</span></span></a><br>EXN: 
<br>
<span class='color_green'><LISTING>n$17=*&amp;t:node* [line 54, column 21];
n$18=*n$17.v:int [line 54, column 21];
n$19=_fun_printf("%d\n":char const *,n$18:int) [line 54, column 7];
</LISTING></span><hr width="100%">
<a name="session26" href="./../nodes/main.fad58de7366495db4650cfefac2fcd61_node25.html#session26">node25#session26</a>(<a href="./../../src.c.b9996786c0d0c7ca7785f2f6d38e80de.html#LINE54">54</a>) uninit (25: 2)<LISTING><span class='color_black'>PRE: 
 uninit_vars: { } 
 aliased_vars: { } 
 prepost: ({ }, { })
INSTR: n$19 := printf({ "%d\n", t->v }) [line 54, column 7]
POST: 
 uninit_vars: { } 
 aliased_vars: { } 
 prepost: ({ }, { })

</LISTING></span><hr width="100%">
<a name="session47" href="./../nodes/main.fad58de7366495db4650cfefac2fcd61_node25.html#session47">node25#session47</a>(<a href="./../../src.c.b9996786c0d0c7ca7785f2f6d38e80de.html#LINE54">54</a>) uninit (25: 2)<LISTING><span class='color_black'>PRE: 
 uninit_vars: { } 
 aliased_vars: { } 
 prepost: ({ }, { })
INSTR: n$19 := printf({ "%d\n", t->v }) [line 54, column 7]
POST: 
 uninit_vars: { } 
 aliased_vars: { } 
 prepost: ({ }, { })

</LISTING></span><hr width="100%">
<a name="session88" href="./../nodes/main.fad58de7366495db4650cfefac2fcd61_node25.html#session88">node25#session88</a>(<a href="./../../src.c.b9996786c0d0c7ca7785f2f6d38e80de.html#LINE54">54</a>) siof<LISTING><span class='color_black'>PRE: ({ }, { })
INSTRS: n$17=*&amp;t:node* [line 54, column 21];
n$18=*n$17.v:int [line 54, column 21];
n$19=_fun_printf("%d\n":char const *,n$18:int) [line 54, column 7];
POST: ({ }, { })

</LISTING></span><hr width="100%">
<a name="session121" href="./../nodes/main.fad58de7366495db4650cfefac2fcd61_node25.html#session121">node25#session121</a>(<a href="./../../src.c.b9996786c0d0c7ca7785f2f6d38e80de.html#LINE54">54</a>) address taken<LISTING><span class='color_black'>PRE: { }
INSTRS: n$17=*&amp;t:node* [line 54, column 21];
n$18=*n$17.v:int [line 54, column 21];
n$19=_fun_printf("%d\n":char const *,n$18:int) [line 54, column 7];
POST: { }

</LISTING></span><hr width="100%">
<a name="session147" href="./../nodes/main.fad58de7366495db4650cfefac2fcd61_node25.html#session147">node25#session147</a>(<a href="./../../src.c.b9996786c0d0c7ca7785f2f6d38e80de.html#LINE54">54</a>) racerd<LISTING><span class='color_black'>PRE: Threads: NoThread, Locks: { } 
Accesses { Access: Write to head.next at  at line 39, column 3 Thread: NoThread Lock: false Pre: False,
           Access: Write to x.next at  at line 46, column 5 Thread: NoThread Lock: false Pre: False,
           Access: Read of t.next at  at line 52, column 11 Thread: NoThread Lock: false Pre: False,
           Access: Read of t.next at  at line 53, column 7 Thread: NoThread Lock: false Pre: False } 
 Ownership: { x -> Unowned,
              x.next -> Owned,
              x.v -> Owned,
              n -> Owned,
              t -> Unowned,
              i -> Owned } 
Attributes: { x.next -> { Functional },
              x.v -> { Functional },
              n -> { Functional },
              head.next -> { Functional },
              i -> { Functional } } 
Non-stable Paths: { i,
                    head.next,
                    head,
                    t.next,
                    t,
                    n,
                    x.v,
                    x.next,
                    x,
                    n$30,
                    n$27 }

INSTR: n$19 := printf({ "%d\n", t->v }) [line 54, column 7]
POST: Threads: NoThread, Locks: { } 
Accesses { Access: Write to head.next at  at line 39, column 3 Thread: NoThread Lock: false Pre: False,
           Access: Write to x.next at  at line 46, column 5 Thread: NoThread Lock: false Pre: False,
           Access: Read of t.next at  at line 52, column 11 Thread: NoThread Lock: false Pre: False,
           Access: Read of t.next at  at line 53, column 7 Thread: NoThread Lock: false Pre: False,
           Access: Read of t.v at  at line 54, column 7 Thread: NoThread Lock: false Pre: False } 
 Ownership: { x -> Unowned,
              x.next -> Owned,
              x.v -> Owned,
              n -> Owned,
              t -> Unowned,
              i -> Owned } 
Attributes: { x.next -> { Functional },
              x.v -> { Functional },
              n -> { Functional },
              head.next -> { Functional },
              i -> { Functional } } 
Non-stable Paths: { i,
                    head.next,
                    head,
                    t.next,
                    t,
                    n,
                    x.v,
                    x.next,
                    x,
                    n$30,
                    n$27,
                    n$19 }


</LISTING></span><hr width="100%">
<a name="session168" href="./../nodes/main.fad58de7366495db4650cfefac2fcd61_node25.html#session168">node25#session168</a>(<a href="./../../src.c.b9996786c0d0c7ca7785f2f6d38e80de.html#LINE54">54</a>) racerd<LISTING><span class='color_black'>PRE: Threads: NoThread, Locks: { } 
Accesses { Access: Write to head.next at  at line 39, column 3 Thread: NoThread Lock: false Pre: False,
           Access: Write to x.next at  at line 46, column 5 Thread: NoThread Lock: false Pre: False,
           Access: Read of t.next at  at line 52, column 11 Thread: NoThread Lock: false Pre: False,
           Access: Read of t.next at  at line 53, column 7 Thread: NoThread Lock: false Pre: False,
           Access: Read of t.v at  at line 54, column 7 Thread: NoThread Lock: false Pre: False,
           Access: Write to t.next at  at line 56, column 5 Thread: NoThread Lock: false Pre: False } 
 Ownership: { x -> Unowned,
              x.next -> Owned,
              x.v -> Unowned,
              n -> Unowned,
              t -> Unowned,
              t.next -> Unowned,
              i -> Unowned } 
Attributes: { x.next -> { Functional },
              x.v -> { Functional },
              n -> { Functional },
              head.next -> { Functional },
              i -> { Functional } } 
Non-stable Paths: { i,
                    head.next,
                    head,
                    t.next,
                    t,
                    n,
                    x.v,
                    x.next,
                    x,
                    n$30,
                    n$27,
                    n$19 }

INSTR: n$19 := printf({ "%d\n", t->v }) [line 54, column 7]
POST: Threads: NoThread, Locks: { } 
Accesses { Access: Write to head.next at  at line 39, column 3 Thread: NoThread Lock: false Pre: False,
           Access: Write to x.next at  at line 46, column 5 Thread: NoThread Lock: false Pre: False,
           Access: Read of t.next at  at line 52, column 11 Thread: NoThread Lock: false Pre: False,
           Access: Read of t.next at  at line 53, column 7 Thread: NoThread Lock: false Pre: False,
           Access: Read of t.v at  at line 54, column 7 Thread: NoThread Lock: false Pre: False,
           Access: Write to t.next at  at line 56, column 5 Thread: NoThread Lock: false Pre: False } 
 Ownership: { x -> Unowned,
              x.next -> Owned,
              x.v -> Unowned,
              n -> Unowned,
              t -> Unowned,
              t.next -> Unowned,
              i -> Unowned } 
Attributes: { x.next -> { Functional },
              x.v -> { Functional },
              n -> { Functional },
              head.next -> { Functional },
              i -> { Functional } } 
Non-stable Paths: { i,
                    head.next,
                    head,
                    t.next,
                    t,
                    n,
                    x.v,
                    x.next,
                    x,
                    n$30,
                    n$27,
                    n$19 }


</LISTING></span><hr width="100%">
<a name="session188" href="./../nodes/main.fad58de7366495db4650cfefac2fcd61_node25.html#session188">node25#session188</a>(<a href="./../../src.c.b9996786c0d0c7ca7785f2f6d38e80de.html#LINE54">54</a>) racerd<LISTING><span class='color_black'>PRE: Threads: NoThread, Locks: { } 
Accesses { Access: Write to head.next at  at line 39, column 3 Thread: NoThread Lock: false Pre: False,
           Access: Write to x.next at  at line 46, column 5 Thread: NoThread Lock: false Pre: False,
           Access: Read of t.next at  at line 52, column 11 Thread: NoThread Lock: false Pre: False,
           Access: Read of t.next at  at line 53, column 7 Thread: NoThread Lock: false Pre: False,
           Access: Read of t.v at  at line 54, column 7 Thread: NoThread Lock: false Pre: False,
           Access: Write to t.next at  at line 56, column 5 Thread: NoThread Lock: false Pre: False,
           Access: Read of n.v at  at line 64, column 17 Thread: NoThread Lock: false Pre: False } 
 Ownership: { x -> Unowned,
              x.next -> Owned,
              x.v -> Unowned,
              n -> Unowned,
              t -> Unowned,
              t.next -> Unowned,
              i -> Unowned } 
Attributes: { x.next -> { Functional },
              x.v -> { Functional },
              n -> { Functional },
              head.next -> { Functional },
              i -> { Functional } } 
Non-stable Paths: { i,
                    head.next,
                    head,
                    t.next,
                    t,
                    n,
                    x.v,
                    x.next,
                    x,
                    n$30,
                    n$27,
                    n$19 }

INSTR: n$19 := printf({ "%d\n", t->v }) [line 54, column 7]
POST: Threads: NoThread, Locks: { } 
Accesses { Access: Write to head.next at  at line 39, column 3 Thread: NoThread Lock: false Pre: False,
           Access: Write to x.next at  at line 46, column 5 Thread: NoThread Lock: false Pre: False,
           Access: Read of t.next at  at line 52, column 11 Thread: NoThread Lock: false Pre: False,
           Access: Read of t.next at  at line 53, column 7 Thread: NoThread Lock: false Pre: False,
           Access: Read of t.v at  at line 54, column 7 Thread: NoThread Lock: false Pre: False,
           Access: Write to t.next at  at line 56, column 5 Thread: NoThread Lock: false Pre: False,
           Access: Read of n.v at  at line 64, column 17 Thread: NoThread Lock: false Pre: False } 
 Ownership: { x -> Unowned,
              x.next -> Owned,
              x.v -> Unowned,
              n -> Unowned,
              t -> Unowned,
              t.next -> Unowned,
              i -> Unowned } 
Attributes: { x.next -> { Functional },
              x.v -> { Functional },
              n -> { Functional },
              head.next -> { Functional },
              i -> { Functional } } 
Non-stable Paths: { i,
                    head.next,
                    head,
                    t.next,
                    t,
                    n,
                    x.v,
                    x.next,
                    x,
                    n$30,
                    n$27,
                    n$19 }


</LISTING></span><hr width="100%">
<a name="session214" href="./../nodes/main.fad58de7366495db4650cfefac2fcd61_node25.html#session214">node25#session214</a>(<a href="./../../src.c.b9996786c0d0c7ca7785f2f6d38e80de.html#LINE54">54</a>) ownership<LISTING><span class='color_black'>PRE: { x -> Owned, n -> Owned, head -> Owned, i -> Owned }
INSTR: n$19 := printf({ "%d\n", t->v }) [line 54, column 7]
POST: { x -> Owned, n -> Owned, head -> Owned, i -> Owned }

</LISTING></span><hr width="100%">
<a name="session257" href="./../nodes/main.fad58de7366495db4650cfefac2fcd61_node25.html#session257">node25#session257</a>(<a href="./../../src.c.b9996786c0d0c7ca7785f2f6d38e80de.html#LINE54">54</a>) interproc<LISTING><span class='color_black'>**** [FP:Pending] main Node: 25, Procedure: main, Session: 257, Todo: 1 ****
  PROP 1 of 1:
  <span class='color_blue'><span class='color_red'>t != 0</span>; <span class='color_red'>MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(x)</span>; <span class='color_red'>MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(t)</span>; <span class='color_red'>MEMma &lt; malloc:38 &gt;  <span class='color_orange'>{vpath: }</span>(_t$1)</span> ;
  <span class='color_red'>x = _t$3 <span class='color_orange'>update:45</span>:node*</span>; <span class='color_red'>n = null <span class='color_orange'>update:40</span>:node*</span>; <span class='color_red'>t = _t$2 <span class='color_orange'>update:53</span>:node*</span>; <span class='color_red'>#GB<src.c>$head = _t$1 <span class='color_orange'>update:38</span>:node*</span>; <span class='color_red'>i = 1 <span class='color_orange'>update:43</span>:int</span>; <span class='color_red'>return = _t$0 <span class='color_orange'>initial</span>:int</span> ;
  <span class='color_red'>x|->{next:null <span class='color_orange'>update:46</span>, v:1 <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16</span>; <span class='color_red'>t|->{next:null <span class='color_orange'>update:46</span>, v:0 <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16</span>; <span class='color_red'>_t$1|->{next:t <span class='color_orange'>update:56</span>, v:@f$0 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16</span>
  [footprint
     <span class='color_red'>@f$1 != 0</span> *
     <span class='color_red'>#GB<src.c>$head = @f$0 <span class='color_orange'>rearrange:38</span>:node*</span>  ]</span>
  .... Instructions: .... 
  <span class='color_green'>n$17=*&amp;t:node* [line 54, column 21];
  n$18=*n$17.v:int [line 54, column 21];
  n$19=_fun_printf("%d\n":char const *,n$18:int) [line 54, column 7];
  REMOVE_TEMPS(n$17,n$18,n$19); [line 54, column 7];
  APPLY_ABSTRACTION; [line 54, column 7];
  </span>
  
  Processing prop 1/1
    Instruction <span class='color_green'>n$17=*&amp;t:node* [line 54, column 21]</span>
    in vpath_find exp:n$253
    vpath_find: found head : node*
    in vpath_find exp:n$252
    vpath_find: found head->next : node*
    in vpath_find exp:n$251
    vpath_find: found x : node*
    .... Rearrangement Start ....
    Exp: &amp;t
    Prop: 
    <span class='color_blue'>t != 0; MEMma &lt; malloc:38 &gt;  <span class='color_orange'>{vpath: }</span>(n$253); MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(t); MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(x) ;
    x = n$251 <span class='color_orange'>update:45</span>:node*; n = null <span class='color_orange'>update:40</span>:node*; t = n$252 <span class='color_orange'>update:53</span>:node*; #GB<src.c>$head = n$253 <span class='color_orange'>update:38</span>:node*; i = 1 <span class='color_orange'>update:43</span>:int; return = n$254 <span class='color_orange'>initial</span>:int ;
    n$253|->{next:t <span class='color_orange'>update:56</span>, v:@f$0 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16; t|->{next:null <span class='color_orange'>update:46</span>, v:0 <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16; x|->{next:null <span class='color_orange'>update:46</span>, v:1 <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16
    [footprint
       @f$1 != 0 *
       #GB<src.c>$head = @f$0 <span class='color_orange'>rearrange:38</span>:node*  ]</span>
    
    in prop_iter_extend_ptsto lexp: &amp;t
    prop before:
    <span class='color_blue'>t != 0; MEMma &lt; malloc:38 &gt;  <span class='color_orange'>{vpath: }</span>(n$253); MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(t); MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(x) ;
    x = n$251 <span class='color_orange'>update:45</span>:node*; n = null <span class='color_orange'>update:40</span>:node*; t = n$252 <span class='color_orange'>update:53</span>:node*; #GB<src.c>$head = n$253 <span class='color_orange'>update:38</span>:node*; i = 1 <span class='color_orange'>update:43</span>:int; return = n$254 <span class='color_orange'>initial</span>:int ;
    n$253|->{next:t <span class='color_orange'>update:56</span>, v:@f$0 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16; t|->{next:null <span class='color_orange'>update:46</span>, v:0 <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16; x|->{next:null <span class='color_orange'>update:46</span>, v:1 <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16
    [footprint
       @f$1 != 0 *
       #GB<src.c>$head = @f$0 <span class='color_orange'>rearrange:38</span>:node*  ]</span>
    
    
    prop list after:
    PROP 1 of 1:
    <span class='color_blue'><span class='color_blue'>t != 0</span>; <span class='color_blue'>MEMma &lt; malloc:38 &gt;  <span class='color_orange'>{vpath: }</span>(n$253)</span>; <span class='color_blue'>MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(t)</span>; <span class='color_blue'>MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(x)</span> ;
    <span class='color_blue'>x = n$251 <span class='color_orange'>update:45</span>:node*</span>; <span class='color_blue'>n = null <span class='color_orange'>update:40</span>:node*</span>; <span class='color_blue'>t = n$252 <span class='color_orange'>update:53</span>:node*</span>; <span class='color_blue'>#GB<src.c>$head = n$253 <span class='color_orange'>update:38</span>:node*</span>; <span class='color_blue'>i = 1 <span class='color_orange'>update:43</span>:int</span>; <span class='color_blue'>return = n$254 <span class='color_orange'>initial</span>:int</span> ;
    <span class='color_blue'>n$253|->{next:t <span class='color_orange'>update:56</span>, v:@f$0 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16</span>; <span class='color_blue'>t|->{next:null <span class='color_orange'>update:46</span>, v:0 <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16</span>; <span class='color_blue'>x|->{next:null <span class='color_orange'>update:46</span>, v:1 <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16</span>
    [footprint
       <span class='color_blue'>@f$1 != 0</span> *
       <span class='color_blue'>#GB<src.c>$head = @f$0 <span class='color_orange'>rearrange:38</span>:node*</span>  ]</span>
    
    
    
    Instruction Returns
    PROP 1 of 1:
    <span class='color_blue'><span class='color_red'>t != 0</span>; <span class='color_blue'>MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(x)</span>; <span class='color_blue'>MEMma &lt; malloc:38 &gt;  <span class='color_orange'>{vpath: }</span>(_t$1)</span>; <span class='color_red'>MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(t)</span> ;
    <span class='color_blue'>x = <span class='color_red'>_t$2 <span class='color_orange'>update:45</span></span>:node*</span>; <span class='color_blue'>n = null <span class='color_orange'>update:40</span>:node*</span>; <span class='color_blue'>t = <span class='color_red'>n$17 <span class='color_orange'>update:53</span></span>:node*</span>; <span class='color_blue'>#GB<src.c>$head = _t$1 <span class='color_orange'>update:38</span>:node*</span>; <span class='color_blue'>i = 1 <span class='color_orange'>update:43</span>:int</span>; <span class='color_blue'>return = _t$0 <span class='color_orange'>initial</span>:int</span> ;
    <span class='color_blue'>x|->{next:null <span class='color_orange'>update:46</span>, v:<span class='color_red'>1 <span class='color_orange'>update:47</span></span>} <span class='color_orange'>alloc</span>:node16</span>; <span class='color_blue'>_t$1|->{next:<span class='color_red'>t <span class='color_orange'>update:56</span></span>, v:@f$0 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16</span>; <span class='color_red'>t|->{next:null <span class='color_orange'>update:46</span>, v:0 <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16</span>
    [footprint
       <span class='color_blue'>@f$1 != 0</span> *
       <span class='color_blue'>#GB<src.c>$head = @f$0 <span class='color_orange'>rearrange:38</span>:node*</span>  ]</span>
    
    Instruction <span class='color_green'>n$18=*n$17.v:int [line 54, column 21]</span>
    in vpath_find exp:n$256
    vpath_find: found head : node*
    in vpath_find exp:n$255
    vpath_find: found x : node*
    in vpath_find exp:n$17
    vpath_find: found head->next : node*
    .... Rearrangement Start ....
    Exp: n$17.v
    Prop: 
    <span class='color_blue'>t != 0; MEMma &lt; malloc:38 &gt;  <span class='color_orange'>{vpath: }</span>(n$256); MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(x); MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(t) ;
    x = n$255 <span class='color_orange'>update:45</span>:node*; n = null <span class='color_orange'>update:40</span>:node*; t = n$17 <span class='color_orange'>update:53</span>:node*; #GB<src.c>$head = n$256 <span class='color_orange'>update:38</span>:node*; i = 1 <span class='color_orange'>update:43</span>:int; return = n$257 <span class='color_orange'>initial</span>:int ;
    n$256|->{next:t <span class='color_orange'>update:56</span>, v:@f$0 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16; x|->{next:null <span class='color_orange'>update:46</span>, v:1 <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16; t|->{next:null <span class='color_orange'>update:46</span>, v:0 <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16
    [footprint
       @f$1 != 0 *
       #GB<src.c>$head = @f$0 <span class='color_orange'>rearrange:38</span>:node*  ]</span>
    
    in prop_iter_extend_ptsto lexp: n$17.v
    prop before:
    <span class='color_blue'>t != 0; MEMma &lt; malloc:38 &gt;  <span class='color_orange'>{vpath: }</span>(n$256); MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(x); MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(t) ;
    x = n$255 <span class='color_orange'>update:45</span>:node*; n = null <span class='color_orange'>update:40</span>:node*; t = n$17 <span class='color_orange'>update:53</span>:node*; #GB<src.c>$head = n$256 <span class='color_orange'>update:38</span>:node*; i = 1 <span class='color_orange'>update:43</span>:int; return = n$257 <span class='color_orange'>initial</span>:int ;
    n$256|->{next:t <span class='color_orange'>update:56</span>, v:@f$0 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16; x|->{next:null <span class='color_orange'>update:46</span>, v:1 <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16; t|->{next:null <span class='color_orange'>update:46</span>, v:0 <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16
    [footprint
       @f$1 != 0 *
       #GB<src.c>$head = @f$0 <span class='color_orange'>rearrange:38</span>:node*  ]</span>
    
    
    prop list after:
    PROP 1 of 1:
    <span class='color_blue'><span class='color_blue'>t != 0</span>; <span class='color_blue'>MEMma &lt; malloc:38 &gt;  <span class='color_orange'>{vpath: }</span>(n$256)</span>; <span class='color_blue'>MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(x)</span>; <span class='color_blue'>MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(t)</span> ;
    <span class='color_blue'>x = n$255 <span class='color_orange'>update:45</span>:node*</span>; <span class='color_blue'>n = null <span class='color_orange'>update:40</span>:node*</span>; <span class='color_blue'>t = n$17 <span class='color_orange'>update:53</span>:node*</span>; <span class='color_blue'>#GB<src.c>$head = n$256 <span class='color_orange'>update:38</span>:node*</span>; <span class='color_blue'>i = 1 <span class='color_orange'>update:43</span>:int</span>; <span class='color_blue'>return = n$257 <span class='color_orange'>initial</span>:int</span> ;
    <span class='color_blue'>n$256|->{next:t <span class='color_orange'>update:56</span>, v:@f$0 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16</span>; <span class='color_blue'>x|->{next:null <span class='color_orange'>update:46</span>, v:1 <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16</span>; <span class='color_blue'>t|->{next:null <span class='color_orange'>update:46</span>, v:0 <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16</span>
    [footprint
       <span class='color_blue'>@f$1 != 0</span> *
       <span class='color_blue'>#GB<src.c>$head = @f$0 <span class='color_orange'>rearrange:38</span>:node*</span>  ]</span>
    
    
    
    Instruction Returns
    PROP 1 of 1:
    <span class='color_blue'><span class='color_red'>n$18 = 0</span> ;
    <span class='color_blue'>t != 0</span>; <span class='color_blue'>MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(x)</span>; <span class='color_blue'>MEMma &lt; malloc:38 &gt;  <span class='color_orange'>{vpath: }</span>(_t$1)</span>; <span class='color_blue'>MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(t)</span> ;
    <span class='color_blue'>x = _t$2 <span class='color_orange'>update:45</span>:node*</span>; <span class='color_blue'>n = null <span class='color_orange'>update:40</span>:node*</span>; <span class='color_blue'>t = n$17 <span class='color_orange'>update:53</span>:node*</span>; <span class='color_blue'>#GB<src.c>$head = _t$1 <span class='color_orange'>update:38</span>:node*</span>; <span class='color_blue'>i = 1 <span class='color_orange'>update:43</span>:int</span>; <span class='color_blue'>return = _t$0 <span class='color_orange'>initial</span>:int</span> ;
    <span class='color_blue'>x|->{next:null <span class='color_orange'>update:46</span>, v:1 <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16</span>; <span class='color_blue'>_t$1|->{next:t <span class='color_orange'>update:56</span>, v:@f$0 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16</span>; <span class='color_blue'>t|->{next:null <span class='color_orange'>update:46</span>, v:0 <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16</span>
    [footprint
       <span class='color_blue'>@f$1 != 0</span> *
       <span class='color_blue'>#GB<src.c>$head = @f$0 <span class='color_orange'>rearrange:38</span>:node*</span>  ]</span>
    
    Instruction <span class='color_green'>n$19=_fun_printf("%d\n":char const *,n$18:int) [line 54, column 7]</span>
    in vpath_find exp:n$259
    vpath_find: found head : node*
    in vpath_find exp:n$258
    vpath_find: found x : node*
    in vpath_find exp:n$17
    vpath_find: found head->next : node*
    <span class='color_orange'>WARNING: likely use of variable-arguments function, or function prototype missing</span>
    actual parameters: 0
    formal parameters: 
    Found 1 specs for function printf
    START EXECUTING SPECS FOR printf from state
    <span class='color_blue'>n$18 = 0 ;
    t != 0; MEMma &lt; malloc:38 &gt;  <span class='color_orange'>{vpath: }</span>(n$259); MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(x); MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(t) ;
    x = n$258 <span class='color_orange'>update:45</span>:node*; n = null <span class='color_orange'>update:40</span>:node*; t = n$17 <span class='color_orange'>update:53</span>:node*; #GB<src.c>$head = n$259 <span class='color_orange'>update:38</span>:node*; i = 1 <span class='color_orange'>update:43</span>:int; return = n$260 <span class='color_orange'>initial</span>:int ;
    n$259|->{next:t <span class='color_orange'>update:56</span>, v:@f$0 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16; x|->{next:null <span class='color_orange'>update:46</span>, v:1 <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16; t|->{next:null <span class='color_orange'>update:46</span>, v:0 <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16
    [footprint
       @f$1 != 0 *
       #GB<src.c>$head = @f$0 <span class='color_orange'>rearrange:38</span>:node*  ]</span>
    <span class='color_orange'>WARNING: more actual pars than formal pars in fun call (2 vs 1)</span>
    EXECUTING SPEC 1/1
    ACTUAL PRECONDITION =
      <span class='color_blue'>n$18 = 0 ;
      t != 0; MEMma &lt; malloc:38 &gt;  <span class='color_orange'>{vpath: }</span>(n$259); MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(x); MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(t) ;
      x = n$258 <span class='color_orange'>update:45</span>:node*; n = null <span class='color_orange'>update:40</span>:node*; t = n$17 <span class='color_orange'>update:53</span>:node*; #GB<src.c>$head = n$259 <span class='color_orange'>update:38</span>:node*; i = 1 <span class='color_orange'>update:43</span>:int; format|callee = "%d\n" <span class='color_orange'>actual_precondition</span>:char const *; return = n$260 <span class='color_orange'>initial</span>:int ;
      n$259|->{next:t <span class='color_orange'>update:56</span>, v:@f$0 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16; x|->{next:null <span class='color_orange'>update:46</span>, v:1 <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16; t|->{next:null <span class='color_orange'>update:46</span>, v:0 <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16
      [footprint
         @f$1 != 0 *
         #GB<src.c>$head = @f$0 <span class='color_orange'>rearrange:38</span>:node*  ]</span>
    SPEC =
      --------------------------- ---------- ---------------------------
      PRE:
      <span class='color_blue'><span class='color_blue'>format|callee = _t$293 <span class='color_orange'>formal</span>:char const *</span></span>
      POST 1 of 1:
      <span class='color_blue'><span class='color_red'>(-1  &lt;  _t$294)</span>; <span class='color_red'>DANGL &lt; UNINIT &gt; (return|callee)</span> ;
      <span class='color_red'>return|callee = _t$294 <span class='color_orange'>update:1114</span>:int</span></span>
      ----------------------------------------------------------------
    pre_check_pure_implication
    pi1:
      n$18 = 0; n$17 != 0; MEMma &lt; malloc:38 &gt;  <span class='color_orange'>{vpath: }</span>(n$259); MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(n$258); MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(n$17)
    pi2:
      
    returns
    sub1: 
      n$18 = 0
    sub2: 
      n$18 = 0
    Current Implication
    SUB:
      n$18 = 0
    <span class='color_blue'>t != 0; MEMma &lt; malloc:38 &gt;  <span class='color_orange'>{vpath: }</span>(n$259); MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(x); MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(t); 0 = 0 ;
    x = n$258 <span class='color_orange'>update:45</span>:node*; n = null <span class='color_orange'>update:40</span>:node*; t = n$17 <span class='color_orange'>update:53</span>:node*; #GB<src.c>$head = n$259 <span class='color_orange'>update:38</span>:node*; i = 1 <span class='color_orange'>update:43</span>:int; format|callee = "%d\n" <span class='color_orange'>actual_precondition</span>:char const *; return = n$260 <span class='color_orange'>initial</span>:int ;
    n$259|->{next:t <span class='color_orange'>update:56</span>, v:@f$0 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16; x|->{next:null <span class='color_orange'>update:46</span>, v:1 <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16; t|->{next:null <span class='color_orange'>update:46</span>, v:0 <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16
    [footprint
       @f$1 != 0 *
       #GB<src.c>$head = @f$0 <span class='color_orange'>rearrange:38</span>:node*  ]</span>
    [SUB: 
      n$18 = 0]
    |-
    <span class='color_blue'>format|callee = _t$293 <span class='color_orange'>formal</span>:char const *</span>
    
      do_imply "%d\n" _t$293
        Final Implication
        SUB:
          n$18 = 0
        <span class='color_blue'>t != 0; MEMma &lt; malloc:38 &gt;  <span class='color_orange'>{vpath: }</span>(n$259); MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(x); MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(t); 0 = 0 ;
        x = n$258 <span class='color_orange'>update:45</span>:node*; n = null <span class='color_orange'>update:40</span>:node*; t = n$17 <span class='color_orange'>update:53</span>:node*; #GB<src.c>$head = n$259 <span class='color_orange'>update:38</span>:node*; i = 1 <span class='color_orange'>update:43</span>:int; return = n$260 <span class='color_orange'>initial</span>:int ;
        n$259|->{next:t <span class='color_orange'>update:56</span>, v:@f$0 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16; x|->{next:null <span class='color_orange'>update:46</span>, v:1 <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16; t|->{next:null <span class='color_orange'>update:46</span>, v:0 <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16
        [footprint
           @f$1 != 0 *
           #GB<src.c>$head = @f$0 <span class='color_orange'>rearrange:38</span>:node*  ]</span>
        [SUB: 
          n$18 = 0; _t$293 = "%d\n"]
        |-
        <span class='color_blue'></span>
    Result of Abduction
      SUB:
        n$18 = 0
      <span class='color_blue'>t != 0; MEMma &lt; malloc:38 &gt;  <span class='color_orange'>{vpath: }</span>(n$259); MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(x); MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(t); 0 = 0 ;
      x = n$258 <span class='color_orange'>update:45</span>:node*; n = null <span class='color_orange'>update:40</span>:node*; t = n$17 <span class='color_orange'>update:53</span>:node*; #GB<src.c>$head = n$259 <span class='color_orange'>update:38</span>:node*; i = 1 <span class='color_orange'>update:43</span>:int; format|callee = "%d\n" <span class='color_orange'>actual_precondition</span>:char const *; return = n$260 <span class='color_orange'>initial</span>:int ;
      n$259|->{next:t <span class='color_orange'>update:56</span>, v:@f$0 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16; x|->{next:null <span class='color_orange'>update:46</span>, v:1 <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16; t|->{next:null <span class='color_orange'>update:46</span>, v:0 <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16
      [footprint
         @f$1 != 0 *
         #GB<src.c>$head = @f$0 <span class='color_orange'>rearrange:38</span>:node*  ]</span>
      [SUB: 
        n$18 = 0; _t$293 = "%d\n"]
      |-
      <span class='color_blue'>format|callee = "%d\n" <span class='color_orange'>formal</span>:char const *</span>
    returning TRUE
      New footprint:
      
      Frame fld:
      
      Missing fld:
      
      Instantiated frame:
      n$259|->{next:n$17 <span class='color_orange'>update:56</span>, v:@f$0 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16; n$258|->{next:null <span class='color_orange'>update:46</span>, v:1 <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16; n$17|->{next:null <span class='color_orange'>update:46</span>, v:0 <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16; &amp;x|->n$258 <span class='color_orange'>update:45</span>:node*; &amp;n|->null <span class='color_orange'>update:40</span>:node*; &amp;t|->n$17 <span class='color_orange'>update:53</span>:node*; &amp;#GB<src.c>$head|->n$259 <span class='color_orange'>update:38</span>:node*; &amp;i|->1 <span class='color_orange'>update:43</span>:int; &amp;return|->n$260 <span class='color_orange'>initial</span>:int
      Instantiated post:
      PROP 1 of 1:
      <span class='color_blue'><span class='color_red'>(-1  &lt;  _t$294)</span>; <span class='color_red'>DANGL &lt; UNINIT &gt; (return|callee)</span> ;
      <span class='color_red'>return|callee = _t$294 <span class='color_orange'>update:54</span>:int</span></span>
      
    ***** RESULTS FUNCTION CALL *******
    PROP 1 of 1:
    <span class='color_blue'><span class='color_blue'>n$18 = 0</span> ;
    <span class='color_red'>(-1  &lt;  n$19)</span>; <span class='color_blue'>t != 0</span>; <span class='color_blue'>MEMma &lt; malloc:38 &gt;  <span class='color_orange'>{vpath: }</span>(n$259)</span>; <span class='color_blue'>MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(x)</span>; <span class='color_blue'>MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(t)</span>; <span class='color_red'>DANGL &lt; UNINIT &gt; (n$19)</span> ;
    <span class='color_blue'>x = n$258 <span class='color_orange'>update:45</span>:node*</span>; <span class='color_blue'>n = null <span class='color_orange'>update:40</span>:node*</span>; <span class='color_blue'>t = n$17 <span class='color_orange'>update:53</span>:node*</span>; <span class='color_blue'>#GB<src.c>$head = n$259 <span class='color_orange'>update:38</span>:node*</span>; <span class='color_blue'>i = 1 <span class='color_orange'>update:43</span>:int</span>; <span class='color_blue'>return = n$260 <span class='color_orange'>initial</span>:int</span> ;
    <span class='color_blue'>n$259|->{next:t <span class='color_orange'>update:56</span>, v:@f$0 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16</span>; <span class='color_blue'>x|->{next:null <span class='color_orange'>update:46</span>, v:1 <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16</span>; <span class='color_blue'>t|->{next:null <span class='color_orange'>update:46</span>, v:0 <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16</span>
    [footprint
       <span class='color_blue'>@f$1 != 0</span> *
       <span class='color_blue'>#GB<src.c>$head = @f$0 <span class='color_orange'>rearrange:38</span>:node*</span>  ]</span>
    ***** END RESULTS FUNCTION CALL *******
    Instruction Returns
    PROP 1 of 1:
    <span class='color_blue'><span class='color_blue'>n$18 = 0</span> ;
    <span class='color_red'>(-1  &lt;  n$19)</span>; <span class='color_blue'>t != 0</span>; <span class='color_blue'>MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(x)</span>; <span class='color_blue'>MEMma &lt; malloc:38 &gt;  <span class='color_orange'>{vpath: }</span>(_t$1)</span>; <span class='color_blue'>MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(t)</span>; <span class='color_red'>DANGL &lt; UNINIT &gt; (n$19)</span> ;
    <span class='color_blue'>x = _t$2 <span class='color_orange'>update:45</span>:node*</span>; <span class='color_blue'>n = null <span class='color_orange'>update:40</span>:node*</span>; <span class='color_blue'>t = n$17 <span class='color_orange'>update:53</span>:node*</span>; <span class='color_blue'>#GB<src.c>$head = _t$1 <span class='color_orange'>update:38</span>:node*</span>; <span class='color_blue'>i = 1 <span class='color_orange'>update:43</span>:int</span>; <span class='color_blue'>return = _t$0 <span class='color_orange'>initial</span>:int</span> ;
    <span class='color_blue'>x|->{next:null <span class='color_orange'>update:46</span>, v:1 <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16</span>; <span class='color_blue'>_t$1|->{next:t <span class='color_orange'>update:56</span>, v:@f$0 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16</span>; <span class='color_blue'>t|->{next:null <span class='color_orange'>update:46</span>, v:0 <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16</span>
    [footprint
       <span class='color_blue'>@f$1 != 0</span> *
       <span class='color_blue'>#GB<src.c>$head = @f$0 <span class='color_orange'>rearrange:38</span>:node*</span>  ]</span>
    
    Instruction <span class='color_green'>REMOVE_TEMPS(n$17,n$18,n$19); [line 54, column 7]</span>
    in vpath_find exp:_t$2
    vpath_find: found x : node*
    in vpath_find exp:_t$1
    vpath_find: found head : node*
    in vpath_find exp:n$17
    vpath_find: found t : node*
    Instruction Returns
    PROP 1 of 1:
    <span class='color_blue'><span class='color_red'>(-1  &lt;  _t$4)</span>; <span class='color_blue'>t != 0</span>; <span class='color_red'>MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(x)</span>; <span class='color_blue'>MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(t)</span>; <span class='color_blue'>MEMma &lt; malloc:38 &gt;  <span class='color_orange'>{vpath: }</span>(_t$1)</span>; <span class='color_red'>DANGL &lt; UNINIT &gt; (_t$4)</span> ;
    <span class='color_blue'>x = <span class='color_red'>_t$3 <span class='color_orange'>update:45</span></span>:node*</span>; <span class='color_blue'>n = null <span class='color_orange'>update:40</span>:node*</span>; <span class='color_blue'>t = <span class='color_red'>_t$2 <span class='color_orange'>update:53</span></span>:node*</span>; <span class='color_blue'>#GB<src.c>$head = _t$1 <span class='color_orange'>update:38</span>:node*</span>; <span class='color_blue'>i = 1 <span class='color_orange'>update:43</span>:int</span>; <span class='color_blue'>return = _t$0 <span class='color_orange'>initial</span>:int</span> ;
    <span class='color_red'>x|->{next:null <span class='color_orange'>update:46</span>, v:1 <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16</span>; <span class='color_blue'>t|->{next:null <span class='color_orange'>update:46</span>, v:<span class='color_red'>0 <span class='color_orange'>update:47</span></span>} <span class='color_orange'>alloc</span>:node16</span>; <span class='color_blue'>_t$1|->{next:<span class='color_red'>t <span class='color_orange'>update:56</span></span>, v:@f$0 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16</span>
    [footprint
       <span class='color_blue'>@f$1 != 0</span> *
       <span class='color_blue'>#GB<src.c>$head = @f$0 <span class='color_orange'>rearrange:38</span>:node*</span>  ]</span>
    
    Instruction <span class='color_green'>APPLY_ABSTRACTION; [line 54, column 7]</span>
    in vpath_find exp:_t$3
    vpath_find: found x : node*
    in vpath_find exp:_t$2
    vpath_find: found t : node*
    in vpath_find exp:_t$1
    vpath_find: found head : node*
    <span class='color_blue'>t != 0; MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(x); MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(t); MEMma &lt; malloc:38 &gt;  <span class='color_orange'>{vpath: }</span>(_t$1) ;
    x = _t$3 <span class='color_orange'>update:45</span>:node*; n = null <span class='color_orange'>update:40</span>:node*; t = _t$2 <span class='color_orange'>update:53</span>:node*; #GB<src.c>$head = _t$1 <span class='color_orange'>update:38</span>:node*; i = 1 <span class='color_orange'>update:43</span>:int; return = _t$0 <span class='color_orange'>initial</span>:int ;
    x|->{next:null <span class='color_orange'>update:46</span>, v:1 <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16; t|->{next:null <span class='color_orange'>update:46</span>, v:0 <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16; _t$1|->{next:t <span class='color_orange'>update:56</span>, v:@f$0 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16
    [footprint
       #GB<src.c>$head = @f$0 <span class='color_orange'>rearrange:38</span>:node*  ]</span>
    Instruction Returns
    PROP 1 of 1:
    <span class='color_blue'><span class='color_blue'>t != 0</span>; <span class='color_blue'>MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(x)</span>; <span class='color_blue'>MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(t)</span>; <span class='color_blue'>MEMma &lt; malloc:38 &gt;  <span class='color_orange'>{vpath: }</span>(_t$1)</span> ;
    <span class='color_blue'>x = _t$3 <span class='color_orange'>update:45</span>:node*</span>; <span class='color_blue'>n = null <span class='color_orange'>update:40</span>:node*</span>; <span class='color_blue'>t = _t$2 <span class='color_orange'>update:53</span>:node*</span>; <span class='color_blue'>#GB<src.c>$head = _t$1 <span class='color_orange'>update:38</span>:node*</span>; <span class='color_blue'>i = 1 <span class='color_orange'>update:43</span>:int</span>; <span class='color_blue'>return = _t$0 <span class='color_orange'>initial</span>:int</span> ;
    <span class='color_blue'>x|->{next:null <span class='color_orange'>update:46</span>, v:1 <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16</span>; <span class='color_blue'>t|->{next:null <span class='color_orange'>update:46</span>, v:0 <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16</span>; <span class='color_blue'>_t$1|->{next:t <span class='color_orange'>update:56</span>, v:@f$0 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16</span>
    [footprint
       <span class='color_blue'>#GB<src.c>$head = @f$0 <span class='color_orange'>rearrange:38</span>:node*</span>  ]</span>
    
    .... After Symbolic Execution ....
    PROP 1 of 1:
    <span class='color_blue'><span class='color_blue'>t != 0</span>; <span class='color_blue'>MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(x)</span>; <span class='color_blue'>MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(t)</span>; <span class='color_blue'>MEMma &lt; malloc:38 &gt;  <span class='color_orange'>{vpath: }</span>(_t$1)</span> ;
    <span class='color_blue'>x = _t$3 <span class='color_orange'>update:45</span>:node*</span>; <span class='color_blue'>n = null <span class='color_orange'>update:40</span>:node*</span>; <span class='color_blue'>t = _t$2 <span class='color_orange'>update:53</span>:node*</span>; <span class='color_blue'>#GB<src.c>$head = _t$1 <span class='color_orange'>update:38</span>:node*</span>; <span class='color_blue'>i = 1 <span class='color_orange'>update:43</span>:int</span>; <span class='color_blue'>return = _t$0 <span class='color_orange'>initial</span>:int</span> ;
    <span class='color_blue'>x|->{next:null <span class='color_orange'>update:46</span>, v:1 <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16</span>; <span class='color_blue'>t|->{next:null <span class='color_orange'>update:46</span>, v:0 <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16</span>; <span class='color_blue'>_t$1|->{next:t <span class='color_orange'>update:56</span>, v:@f$0 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16</span>
    [footprint
       <span class='color_blue'>#GB<src.c>$head = @f$0 <span class='color_orange'>rearrange:38</span>:node*</span>  ]</span>
    
    
    
  </LISTING></span><hr width="100%">
<a name="session282" href="./../nodes/main.fad58de7366495db4650cfefac2fcd61_node25.html#session282">node25#session282</a>(<a href="./../../src.c.b9996786c0d0c7ca7785f2f6d38e80de.html#LINE54">54</a>) interproc<LISTING><span class='color_black'>**** [FP:Pending] main Node: 25, Procedure: main, Session: 282, Todo: 1 ****
  PROP 1 of 1:
  <span class='color_blue'><span class='color_red'>t != 0</span>; <span class='color_red'>MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(x)</span>; <span class='color_red'>MEMma &lt; malloc:38 &gt;  <span class='color_orange'>{vpath: }</span>(_t$1)</span> ;
  <span class='color_red'>x = _t$4 <span class='color_orange'>update:45</span>:node*</span>; <span class='color_red'>n = null <span class='color_orange'>update:40</span>:node*</span>; <span class='color_red'>t = _t$2 <span class='color_orange'>update:53</span>:node*</span>; <span class='color_red'>#GB<src.c>$head = _t$1 <span class='color_orange'>update:38</span>:node*</span>; <span class='color_red'>i = 2 <span class='color_orange'>update:43</span>:int</span>; <span class='color_red'>return = _t$0 <span class='color_orange'>initial</span>:int</span> ;
  <span class='color_red'>x|->{next:null <span class='color_orange'>update:46</span>, v:2 <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16</span>; <span class='color_red'>_t$1|->{next:t <span class='color_orange'>update:56</span>, v:_t$3 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16</span>; <span class='color_red'>lsegne(t,null,[],P0)</span>
  [footprint
     <span class='color_red'>@f$1 != 0</span> *
     <span class='color_red'>#GB<src.c>$head = @f$0 <span class='color_orange'>rearrange:38</span>:node*</span>  ]
  where
  P0 = exists [_t$2]. <span class='color_blue'>_t$0|->{next:_t$1 <span class='color_orange'>update:56</span>, v:_t$2 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16</span></span>
  .... Instructions: .... 
  <span class='color_green'>n$17=*&amp;t:node* [line 54, column 21];
  n$18=*n$17.v:int [line 54, column 21];
  n$19=_fun_printf("%d\n":char const *,n$18:int) [line 54, column 7];
  REMOVE_TEMPS(n$17,n$18,n$19); [line 54, column 7];
  APPLY_ABSTRACTION; [line 54, column 7];
  </span>
  
  Processing prop 1/1
    Instruction <span class='color_green'>n$17=*&amp;t:node* [line 54, column 21]</span>
    in vpath_find exp:n$380
    vpath_find: found head : node*
    in vpath_find exp:n$379
    vpath_find: found x : node*
    .... Rearrangement Start ....
    Exp: &amp;t
    Prop: 
    <span class='color_blue'>t != 0; MEMma &lt; malloc:38 &gt;  <span class='color_orange'>{vpath: }</span>(n$380); MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(x) ;
    x = n$379 <span class='color_orange'>update:45</span>:node*; n = null <span class='color_orange'>update:40</span>:node*; t = n$381 <span class='color_orange'>update:53</span>:node*; #GB<src.c>$head = n$380 <span class='color_orange'>update:38</span>:node*; i = 2 <span class='color_orange'>update:43</span>:int; return = n$383 <span class='color_orange'>initial</span>:int ;
    n$380|->{next:t <span class='color_orange'>update:56</span>, v:n$382 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16; x|->{next:null <span class='color_orange'>update:46</span>, v:2 <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16; lsegne(t,null,[],P0)
    [footprint
       @f$1 != 0 *
       #GB<src.c>$head = @f$0 <span class='color_orange'>rearrange:38</span>:node*  ]
    where
    P0 = exists [_t$2]. _t$0|->{next:_t$1 <span class='color_orange'>update:56</span>, v:_t$2 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16</span>
    
    in prop_iter_extend_ptsto lexp: &amp;t
    prop before:
    <span class='color_blue'>t != 0; MEMma &lt; malloc:38 &gt;  <span class='color_orange'>{vpath: }</span>(n$380); MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(x) ;
    x = n$379 <span class='color_orange'>update:45</span>:node*; n = null <span class='color_orange'>update:40</span>:node*; t = n$381 <span class='color_orange'>update:53</span>:node*; #GB<src.c>$head = n$380 <span class='color_orange'>update:38</span>:node*; i = 2 <span class='color_orange'>update:43</span>:int; return = n$383 <span class='color_orange'>initial</span>:int ;
    n$380|->{next:t <span class='color_orange'>update:56</span>, v:n$382 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16; x|->{next:null <span class='color_orange'>update:46</span>, v:2 <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16; lsegne(t,null,[],P0)
    [footprint
       @f$1 != 0 *
       #GB<src.c>$head = @f$0 <span class='color_orange'>rearrange:38</span>:node*  ]
    where
    P0 = exists [_t$2]. _t$0|->{next:_t$1 <span class='color_orange'>update:56</span>, v:_t$2 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16</span>
    
    
    prop list after:
    PROP 1 of 1:
    <span class='color_blue'><span class='color_blue'>t != 0</span>; <span class='color_blue'>MEMma &lt; malloc:38 &gt;  <span class='color_orange'>{vpath: }</span>(n$380)</span>; <span class='color_blue'>MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(x)</span> ;
    <span class='color_blue'>x = n$379 <span class='color_orange'>update:45</span>:node*</span>; <span class='color_blue'>n = null <span class='color_orange'>update:40</span>:node*</span>; <span class='color_blue'>t = n$381 <span class='color_orange'>update:53</span>:node*</span>; <span class='color_blue'>#GB<src.c>$head = n$380 <span class='color_orange'>update:38</span>:node*</span>; <span class='color_blue'>i = 2 <span class='color_orange'>update:43</span>:int</span>; <span class='color_blue'>return = n$383 <span class='color_orange'>initial</span>:int</span> ;
    <span class='color_blue'>n$380|->{next:t <span class='color_orange'>update:56</span>, v:n$382 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16</span>; <span class='color_blue'>x|->{next:null <span class='color_orange'>update:46</span>, v:2 <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16</span>; <span class='color_blue'>lsegne(t,null,[],P0)</span>
    [footprint
       <span class='color_blue'>@f$1 != 0</span> *
       <span class='color_blue'>#GB<src.c>$head = @f$0 <span class='color_orange'>rearrange:38</span>:node*</span>  ]
    where
    P0 = exists [_t$2]. <span class='color_blue'>_t$0|->{next:_t$1 <span class='color_orange'>update:56</span>, v:_t$2 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16</span></span>
    
    
    
    Instruction Returns
    PROP 1 of 1:
    <span class='color_blue'><span class='color_red'>t != 0</span>; <span class='color_red'>MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(x)</span>; <span class='color_blue'>MEMma &lt; malloc:38 &gt;  <span class='color_orange'>{vpath: }</span>(_t$1)</span> ;
    <span class='color_blue'>x = <span class='color_red'>_t$3 <span class='color_orange'>update:45</span></span>:node*</span>; <span class='color_blue'>n = null <span class='color_orange'>update:40</span>:node*</span>; <span class='color_blue'>t = <span class='color_red'>n$17 <span class='color_orange'>update:53</span></span>:node*</span>; <span class='color_blue'>#GB<src.c>$head = _t$1 <span class='color_orange'>update:38</span>:node*</span>; <span class='color_blue'>i = 2 <span class='color_orange'>update:43</span>:int</span>; <span class='color_blue'>return = _t$0 <span class='color_orange'>initial</span>:int</span> ;
    <span class='color_red'>x|->{next:null <span class='color_orange'>update:46</span>, v:2 <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16</span>; <span class='color_blue'>_t$1|->{next:<span class='color_red'>t <span class='color_orange'>update:56</span></span>, v:<span class='color_red'>_t$2 <span class='color_orange'>alloc</span></span>} <span class='color_orange'>alloc</span>:node16</span>; <span class='color_red'>lsegne(t,null,[],P0)</span>
    [footprint
       <span class='color_blue'>@f$1 != 0</span> *
       <span class='color_blue'>#GB<src.c>$head = @f$0 <span class='color_orange'>rearrange:38</span>:node*</span>  ]
    where
    P0 = exists [_t$2]. <span class='color_blue'>_t$0|->{next:_t$1 <span class='color_orange'>update:56</span>, v:_t$2 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16</span></span>
    
    Instruction <span class='color_green'>n$18=*n$17.v:int [line 54, column 21]</span>
    in vpath_find exp:n$385
    vpath_find: found head : node*
    in vpath_find exp:n$384
    vpath_find: found x : node*
    .... Rearrangement Start ....
    Exp: n$17.v
    Prop: 
    <span class='color_blue'>t != 0; MEMma &lt; malloc:38 &gt;  <span class='color_orange'>{vpath: }</span>(n$385); MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(x) ;
    x = n$384 <span class='color_orange'>update:45</span>:node*; n = null <span class='color_orange'>update:40</span>:node*; t = n$17 <span class='color_orange'>update:53</span>:node*; #GB<src.c>$head = n$385 <span class='color_orange'>update:38</span>:node*; i = 2 <span class='color_orange'>update:43</span>:int; return = n$387 <span class='color_orange'>initial</span>:int ;
    n$385|->{next:t <span class='color_orange'>update:56</span>, v:n$386 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16; x|->{next:null <span class='color_orange'>update:46</span>, v:2 <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16; lsegne(t,null,[],P0)
    [footprint
       @f$1 != 0 *
       #GB<src.c>$head = @f$0 <span class='color_orange'>rearrange:38</span>:node*  ]
    where
    P0 = exists [_t$2]. _t$0|->{next:_t$1 <span class='color_orange'>update:56</span>, v:_t$2 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16</span>
    
    in prop_iter_extend_ptsto lexp: n$17.v
    prop before:
    <span class='color_blue'>t != 0; MEMma &lt; malloc:38 &gt;  <span class='color_orange'>{vpath: }</span>(n$385); MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(x) ;
    x = n$384 <span class='color_orange'>update:45</span>:node*; n = null <span class='color_orange'>update:40</span>:node*; t = n$17 <span class='color_orange'>update:53</span>:node*; #GB<src.c>$head = n$385 <span class='color_orange'>update:38</span>:node*; i = 2 <span class='color_orange'>update:43</span>:int; return = n$387 <span class='color_orange'>initial</span>:int ;
    n$385|->{next:t <span class='color_orange'>update:56</span>, v:n$386 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16; x|->{next:null <span class='color_orange'>update:46</span>, v:2 <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16; t|->{next:_t$525 <span class='color_orange'>update:56</span>, v:_t$526 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16; lseg(_t$525,null,[],P0)
    [footprint
       @f$1 != 0 *
       #GB<src.c>$head = @f$0 <span class='color_orange'>rearrange:38</span>:node*  ]
    where
    P0 = exists [_t$2]. _t$0|->{next:_t$1 <span class='color_orange'>update:56</span>, v:_t$2 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16</span>
    
    
    prop list after:
    PROP 1 of 1:
    <span class='color_blue'><span class='color_blue'>t != 0</span>; <span class='color_blue'>MEMma &lt; malloc:38 &gt;  <span class='color_orange'>{vpath: }</span>(n$385)</span>; <span class='color_blue'>MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(x)</span> ;
    <span class='color_blue'>x = n$384 <span class='color_orange'>update:45</span>:node*</span>; <span class='color_blue'>n = null <span class='color_orange'>update:40</span>:node*</span>; <span class='color_blue'>t = n$17 <span class='color_orange'>update:53</span>:node*</span>; <span class='color_blue'>#GB<src.c>$head = n$385 <span class='color_orange'>update:38</span>:node*</span>; <span class='color_blue'>i = 2 <span class='color_orange'>update:43</span>:int</span>; <span class='color_blue'>return = n$387 <span class='color_orange'>initial</span>:int</span> ;
    <span class='color_blue'>n$385|->{next:t <span class='color_orange'>update:56</span>, v:n$386 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16</span>; <span class='color_blue'>x|->{next:null <span class='color_orange'>update:46</span>, v:2 <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16</span>; <span class='color_blue'>t|->{next:_t$525 <span class='color_orange'>update:56</span>, v:_t$526 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16</span>; <span class='color_blue'>lseg(_t$525,null,[],P0)</span>
    [footprint
       <span class='color_blue'>@f$1 != 0</span> *
       <span class='color_blue'>#GB<src.c>$head = @f$0 <span class='color_orange'>rearrange:38</span>:node*</span>  ]
    where
    P0 = exists [_t$2]. <span class='color_blue'>_t$0|->{next:_t$1 <span class='color_orange'>update:56</span>, v:_t$2 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16</span></span>
    
    
    
    Instruction Returns
    PROP 1 of 1:
    <span class='color_blue'><span class='color_blue'>t != 0</span>; <span class='color_red'>MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(x)</span>; <span class='color_blue'>MEMma &lt; malloc:38 &gt;  <span class='color_orange'>{vpath: }</span>(_t$1)</span>; <span class='color_red'>DANGL &lt; UNINIT &gt; (n$18)</span> ;
    <span class='color_blue'>x = <span class='color_red'>_t$4 <span class='color_orange'>update:45</span></span>:node*</span>; <span class='color_blue'>n = null <span class='color_orange'>update:40</span>:node*</span>; <span class='color_blue'>t = n$17 <span class='color_orange'>update:53</span>:node*</span>; <span class='color_blue'>#GB<src.c>$head = _t$1 <span class='color_orange'>update:38</span>:node*</span>; <span class='color_blue'>i = 2 <span class='color_orange'>update:43</span>:int</span>; <span class='color_blue'>return = _t$0 <span class='color_orange'>initial</span>:int</span> ;
    <span class='color_red'>x|->{next:null <span class='color_orange'>update:46</span>, v:2 <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16</span>; <span class='color_blue'>_t$1|->{next:t <span class='color_orange'>update:56</span>, v:_t$2 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16</span>; <span class='color_blue'>t|->{next:_t$3 <span class='color_orange'>update:56</span>, v:n$18 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16</span>; <span class='color_blue'>lseg(_t$3,null,[],P0)</span>
    [footprint
       <span class='color_blue'>@f$1 != 0</span> *
       <span class='color_blue'>#GB<src.c>$head = @f$0 <span class='color_orange'>rearrange:38</span>:node*</span>  ]
    where
    P0 = exists [_t$2]. <span class='color_blue'>_t$0|->{next:_t$1 <span class='color_orange'>update:56</span>, v:_t$2 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16</span></span>
    
    Instruction <span class='color_green'>n$19=_fun_printf("%d\n":char const *,n$18:int) [line 54, column 7]</span>
    in vpath_find exp:n$389
    vpath_find: found head : node*
    in vpath_find exp:n$388
    vpath_find: found x : node*
    <span class='color_orange'>WARNING: likely use of variable-arguments function, or function prototype missing</span>
    actual parameters: n$18
    formal parameters: 
    Found 1 specs for function printf
    START EXECUTING SPECS FOR printf from state
    <span class='color_blue'>t != 0; MEMma &lt; malloc:38 &gt;  <span class='color_orange'>{vpath: }</span>(n$389); MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(x); DANGL &lt; UNINIT &gt; (n$18) ;
    x = n$388 <span class='color_orange'>update:45</span>:node*; n = null <span class='color_orange'>update:40</span>:node*; t = n$17 <span class='color_orange'>update:53</span>:node*; #GB<src.c>$head = n$389 <span class='color_orange'>update:38</span>:node*; i = 2 <span class='color_orange'>update:43</span>:int; return = n$392 <span class='color_orange'>initial</span>:int ;
    n$389|->{next:t <span class='color_orange'>update:56</span>, v:n$390 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16; x|->{next:null <span class='color_orange'>update:46</span>, v:2 <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16; t|->{next:n$391 <span class='color_orange'>update:56</span>, v:n$18 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16; lseg(n$391,null,[],P0)
    [footprint
       @f$1 != 0 *
       #GB<src.c>$head = @f$0 <span class='color_orange'>rearrange:38</span>:node*  ]
    where
    P0 = exists [_t$2]. _t$0|->{next:_t$1 <span class='color_orange'>update:56</span>, v:_t$2 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16</span>
    <span class='color_orange'>WARNING: more actual pars than formal pars in fun call (2 vs 1)</span>
    EXECUTING SPEC 1/1
    ACTUAL PRECONDITION =
      <span class='color_blue'>t != 0; MEMma &lt; malloc:38 &gt;  <span class='color_orange'>{vpath: }</span>(n$389); MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(x); DANGL &lt; UNINIT &gt; (n$18) ;
      x = n$388 <span class='color_orange'>update:45</span>:node*; n = null <span class='color_orange'>update:40</span>:node*; t = n$17 <span class='color_orange'>update:53</span>:node*; #GB<src.c>$head = n$389 <span class='color_orange'>update:38</span>:node*; i = 2 <span class='color_orange'>update:43</span>:int; format|callee = "%d\n" <span class='color_orange'>actual_precondition</span>:char const *; return = n$392 <span class='color_orange'>initial</span>:int ;
      n$389|->{next:t <span class='color_orange'>update:56</span>, v:n$390 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16; x|->{next:null <span class='color_orange'>update:46</span>, v:2 <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16; t|->{next:n$391 <span class='color_orange'>update:56</span>, v:n$18 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16; lseg(n$391,null,[],P0)
      [footprint
         @f$1 != 0 *
         #GB<src.c>$head = @f$0 <span class='color_orange'>rearrange:38</span>:node*  ]
      where
      P0 = exists [_t$2]. _t$0|->{next:_t$1 <span class='color_orange'>update:56</span>, v:_t$2 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16</span>
    SPEC =
      --------------------------- ---------- ---------------------------
      PRE:
      <span class='color_blue'><span class='color_blue'>format|callee = _t$532 <span class='color_orange'>formal</span>:char const *</span></span>
      POST 1 of 1:
      <span class='color_blue'><span class='color_red'>(-1  &lt;  _t$533)</span>; <span class='color_red'>DANGL &lt; UNINIT &gt; (return|callee)</span> ;
      <span class='color_red'>return|callee = _t$533 <span class='color_orange'>update:1114</span>:int</span></span>
      ----------------------------------------------------------------
    pre_check_pure_implication
    pi1:
      n$17 != 0; MEMma &lt; malloc:38 &gt;  <span class='color_orange'>{vpath: }</span>(n$389); MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(n$388); DANGL &lt; UNINIT &gt; (n$18)
    pi2:
      
    returns
    sub1: 
      
    sub2: 
      
    Current Implication
    SUB:
      
    <span class='color_blue'>t != 0; MEMma &lt; malloc:38 &gt;  <span class='color_orange'>{vpath: }</span>(n$389); MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(x); DANGL &lt; UNINIT &gt; (n$18) ;
    x = n$388 <span class='color_orange'>update:45</span>:node*; n = null <span class='color_orange'>update:40</span>:node*; t = n$17 <span class='color_orange'>update:53</span>:node*; #GB<src.c>$head = n$389 <span class='color_orange'>update:38</span>:node*; i = 2 <span class='color_orange'>update:43</span>:int; format|callee = "%d\n" <span class='color_orange'>actual_precondition</span>:char const *; return = n$392 <span class='color_orange'>initial</span>:int ;
    n$389|->{next:t <span class='color_orange'>update:56</span>, v:n$390 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16; x|->{next:null <span class='color_orange'>update:46</span>, v:2 <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16; t|->{next:n$391 <span class='color_orange'>update:56</span>, v:n$18 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16; lseg(n$391,null,[],P0)
    [footprint
       @f$1 != 0 *
       #GB<src.c>$head = @f$0 <span class='color_orange'>rearrange:38</span>:node*  ]
    where
    P0 = exists [_t$2]. _t$0|->{next:_t$1 <span class='color_orange'>update:56</span>, v:_t$2 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16</span>
    |-
    <span class='color_blue'>format|callee = _t$532 <span class='color_orange'>formal</span>:char const *</span>
    
      do_imply "%d\n" _t$532
        Final Implication
        SUB:
          
        <span class='color_blue'>t != 0; MEMma &lt; malloc:38 &gt;  <span class='color_orange'>{vpath: }</span>(n$389); MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(x); DANGL &lt; UNINIT &gt; (n$18) ;
        x = n$388 <span class='color_orange'>update:45</span>:node*; n = null <span class='color_orange'>update:40</span>:node*; t = n$17 <span class='color_orange'>update:53</span>:node*; #GB<src.c>$head = n$389 <span class='color_orange'>update:38</span>:node*; i = 2 <span class='color_orange'>update:43</span>:int; return = n$392 <span class='color_orange'>initial</span>:int ;
        n$389|->{next:t <span class='color_orange'>update:56</span>, v:n$390 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16; x|->{next:null <span class='color_orange'>update:46</span>, v:2 <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16; t|->{next:n$391 <span class='color_orange'>update:56</span>, v:n$18 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16; lseg(n$391,null,[],P0)
        [footprint
           @f$1 != 0 *
           #GB<src.c>$head = @f$0 <span class='color_orange'>rearrange:38</span>:node*  ]
        where
        P0 = exists [_t$2]. _t$0|->{next:_t$1 <span class='color_orange'>update:56</span>, v:_t$2 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16</span>
        [SUB: 
          _t$532 = "%d\n"]
        |-
        <span class='color_blue'></span>
    Result of Abduction
      SUB:
        
      <span class='color_blue'>t != 0; MEMma &lt; malloc:38 &gt;  <span class='color_orange'>{vpath: }</span>(n$389); MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(x); DANGL &lt; UNINIT &gt; (n$18) ;
      x = n$388 <span class='color_orange'>update:45</span>:node*; n = null <span class='color_orange'>update:40</span>:node*; t = n$17 <span class='color_orange'>update:53</span>:node*; #GB<src.c>$head = n$389 <span class='color_orange'>update:38</span>:node*; i = 2 <span class='color_orange'>update:43</span>:int; format|callee = "%d\n" <span class='color_orange'>actual_precondition</span>:char const *; return = n$392 <span class='color_orange'>initial</span>:int ;
      n$389|->{next:t <span class='color_orange'>update:56</span>, v:n$390 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16; x|->{next:null <span class='color_orange'>update:46</span>, v:2 <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16; t|->{next:n$391 <span class='color_orange'>update:56</span>, v:n$18 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16; lseg(n$391,null,[],P0)
      [footprint
         @f$1 != 0 *
         #GB<src.c>$head = @f$0 <span class='color_orange'>rearrange:38</span>:node*  ]
      where
      P0 = exists [_t$2]. _t$0|->{next:_t$1 <span class='color_orange'>update:56</span>, v:_t$2 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16</span>
      [SUB: 
        _t$532 = "%d\n"]
      |-
      <span class='color_blue'>format|callee = "%d\n" <span class='color_orange'>formal</span>:char const *</span>
    returning TRUE
      New footprint:
      
      Frame fld:
      
      Missing fld:
      
      Instantiated frame:
      n$389|->{next:n$17 <span class='color_orange'>update:56</span>, v:n$390 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16; n$388|->{next:null <span class='color_orange'>update:46</span>, v:2 <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16; n$17|->{next:n$391 <span class='color_orange'>update:56</span>, v:n$18 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16; &amp;x|->n$388 <span class='color_orange'>update:45</span>:node*; &amp;n|->null <span class='color_orange'>update:40</span>:node*; &amp;t|->n$17 <span class='color_orange'>update:53</span>:node*; &amp;#GB<src.c>$head|->n$389 <span class='color_orange'>update:38</span>:node*; &amp;i|->2 <span class='color_orange'>update:43</span>:int; &amp;return|->n$392 <span class='color_orange'>initial</span>:int; lseg(n$391,null,[],lam [_t$0,_t$1,]. exists [_t$2]. _t$0|->{next:_t$1 <span class='color_orange'>update:56</span>, v:_t$2 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16)
      Instantiated post:
      PROP 1 of 1:
      <span class='color_blue'><span class='color_red'>(-1  &lt;  _t$533)</span>; <span class='color_red'>DANGL &lt; UNINIT &gt; (return|callee)</span> ;
      <span class='color_red'>return|callee = _t$533 <span class='color_orange'>update:54</span>:int</span></span>
      
    ***** RESULTS FUNCTION CALL *******
    PROP 1 of 1:
    <span class='color_blue'><span class='color_red'>(-1  &lt;  n$19)</span>; <span class='color_blue'>t != 0</span>; <span class='color_blue'>MEMma &lt; malloc:38 &gt;  <span class='color_orange'>{vpath: }</span>(n$389)</span>; <span class='color_blue'>MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(x)</span>; <span class='color_red'>DANGL &lt; UNINIT &gt; (n$19)</span>; <span class='color_blue'>DANGL &lt; UNINIT &gt; (n$18)</span> ;
    <span class='color_blue'>x = n$388 <span class='color_orange'>update:45</span>:node*</span>; <span class='color_blue'>n = null <span class='color_orange'>update:40</span>:node*</span>; <span class='color_blue'>t = n$17 <span class='color_orange'>update:53</span>:node*</span>; <span class='color_blue'>#GB<src.c>$head = n$389 <span class='color_orange'>update:38</span>:node*</span>; <span class='color_blue'>i = 2 <span class='color_orange'>update:43</span>:int</span>; <span class='color_blue'>return = n$392 <span class='color_orange'>initial</span>:int</span> ;
    <span class='color_blue'>n$389|->{next:t <span class='color_orange'>update:56</span>, v:n$390 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16</span>; <span class='color_blue'>x|->{next:null <span class='color_orange'>update:46</span>, v:2 <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16</span>; <span class='color_blue'>t|->{next:n$391 <span class='color_orange'>update:56</span>, v:n$18 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16</span>; <span class='color_blue'>lseg(n$391,null,[],P0)</span>
    [footprint
       <span class='color_blue'>@f$1 != 0</span> *
       <span class='color_blue'>#GB<src.c>$head = @f$0 <span class='color_orange'>rearrange:38</span>:node*</span>  ]
    where
    P0 = exists [_t$2]. <span class='color_blue'>_t$0|->{next:_t$1 <span class='color_orange'>update:56</span>, v:_t$2 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16</span></span>
    ***** END RESULTS FUNCTION CALL *******
    Instruction Returns
    PROP 1 of 1:
    <span class='color_blue'><span class='color_red'>(-1  &lt;  n$19)</span>; <span class='color_blue'>t != 0</span>; <span class='color_blue'>MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(x)</span>; <span class='color_blue'>MEMma &lt; malloc:38 &gt;  <span class='color_orange'>{vpath: }</span>(_t$1)</span>; <span class='color_red'>DANGL &lt; UNINIT &gt; (n$19)</span>; <span class='color_blue'>DANGL &lt; UNINIT &gt; (n$18)</span> ;
    <span class='color_blue'>x = _t$4 <span class='color_orange'>update:45</span>:node*</span>; <span class='color_blue'>n = null <span class='color_orange'>update:40</span>:node*</span>; <span class='color_blue'>t = n$17 <span class='color_orange'>update:53</span>:node*</span>; <span class='color_blue'>#GB<src.c>$head = _t$1 <span class='color_orange'>update:38</span>:node*</span>; <span class='color_blue'>i = 2 <span class='color_orange'>update:43</span>:int</span>; <span class='color_blue'>return = _t$0 <span class='color_orange'>initial</span>:int</span> ;
    <span class='color_blue'>x|->{next:null <span class='color_orange'>update:46</span>, v:2 <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16</span>; <span class='color_blue'>_t$1|->{next:t <span class='color_orange'>update:56</span>, v:_t$2 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16</span>; <span class='color_blue'>t|->{next:_t$3 <span class='color_orange'>update:56</span>, v:n$18 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16</span>; <span class='color_blue'>lseg(_t$3,null,[],P0)</span>
    [footprint
       <span class='color_blue'>@f$1 != 0</span> *
       <span class='color_blue'>#GB<src.c>$head = @f$0 <span class='color_orange'>rearrange:38</span>:node*</span>  ]
    where
    P0 = exists [_t$2]. <span class='color_blue'>_t$0|->{next:_t$1 <span class='color_orange'>update:56</span>, v:_t$2 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16</span></span>
    
    Instruction <span class='color_green'>REMOVE_TEMPS(n$17,n$18,n$19); [line 54, column 7]</span>
    in vpath_find exp:_t$4
    vpath_find: found x : node*
    in vpath_find exp:_t$1
    vpath_find: found head : node*
    Instruction Returns
    PROP 1 of 1:
    <span class='color_blue'><span class='color_red'>(-1  &lt;  _t$7)</span>; <span class='color_red'>t != 0</span>; <span class='color_red'>MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(x)</span>; <span class='color_blue'>MEMma &lt; malloc:38 &gt;  <span class='color_orange'>{vpath: }</span>(_t$1)</span>; <span class='color_red'>DANGL &lt; UNINIT &gt; (_t$7)</span>; <span class='color_red'>DANGL &lt; UNINIT &gt; (_t$5)</span> ;
    <span class='color_blue'>x = <span class='color_red'>_t$6 <span class='color_orange'>update:45</span></span>:node*</span>; <span class='color_blue'>n = null <span class='color_orange'>update:40</span>:node*</span>; <span class='color_blue'>t = <span class='color_red'>_t$2 <span class='color_orange'>update:53</span></span>:node*</span>; <span class='color_blue'>#GB<src.c>$head = _t$1 <span class='color_orange'>update:38</span>:node*</span>; <span class='color_blue'>i = 2 <span class='color_orange'>update:43</span>:int</span>; <span class='color_blue'>return = _t$0 <span class='color_orange'>initial</span>:int</span> ;
    <span class='color_red'>x|->{next:null <span class='color_orange'>update:46</span>, v:2 <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16</span>; <span class='color_red'>t|->{next:_t$4 <span class='color_orange'>update:56</span>, v:_t$5 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16</span>; <span class='color_blue'>_t$1|->{next:<span class='color_red'>t <span class='color_orange'>update:56</span></span>, v:<span class='color_red'>_t$3 <span class='color_orange'>alloc</span></span>} <span class='color_orange'>alloc</span>:node16</span>; <span class='color_blue'>lseg(_t$4,null,[],P0)</span>
    [footprint
       <span class='color_blue'>@f$1 != 0</span> *
       <span class='color_blue'>#GB<src.c>$head = @f$0 <span class='color_orange'>rearrange:38</span>:node*</span>  ]
    where
    P0 = exists [_t$2]. <span class='color_blue'>_t$0|->{next:_t$1 <span class='color_orange'>update:56</span>, v:_t$2 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16</span></span>
    
    Instruction <span class='color_green'>APPLY_ABSTRACTION; [line 54, column 7]</span>
    in vpath_find exp:_t$6
    vpath_find: found x : node*
    in vpath_find exp:_t$1
    vpath_find: found head : node*
    <span class='color_blue'>t != 0; MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(x); MEMma &lt; malloc:38 &gt;  <span class='color_orange'>{vpath: }</span>(_t$1) ;
    x = _t$4 <span class='color_orange'>update:45</span>:node*; n = null <span class='color_orange'>update:40</span>:node*; t = _t$2 <span class='color_orange'>update:53</span>:node*; #GB<src.c>$head = _t$1 <span class='color_orange'>update:38</span>:node*; i = 2 <span class='color_orange'>update:43</span>:int; return = _t$0 <span class='color_orange'>initial</span>:int ;
    x|->{next:null <span class='color_orange'>update:46</span>, v:2 <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16; _t$1|->{next:t <span class='color_orange'>update:56</span>, v:_t$3 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16; lsegne(t,null,[],P0)
    [footprint
       #GB<src.c>$head = @f$0 <span class='color_orange'>rearrange:38</span>:node*  ]
    where
    P0 = exists [_t$2]. _t$0|->{next:_t$1 <span class='color_orange'>update:56</span>, v:_t$2 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16</span>
    Instruction Returns
    PROP 1 of 1:
    <span class='color_blue'><span class='color_blue'>t != 0</span>; <span class='color_red'>MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(x)</span>; <span class='color_blue'>MEMma &lt; malloc:38 &gt;  <span class='color_orange'>{vpath: }</span>(_t$1)</span> ;
    <span class='color_blue'>x = <span class='color_red'>_t$4 <span class='color_orange'>update:45</span></span>:node*</span>; <span class='color_blue'>n = null <span class='color_orange'>update:40</span>:node*</span>; <span class='color_blue'>t = _t$2 <span class='color_orange'>update:53</span>:node*</span>; <span class='color_blue'>#GB<src.c>$head = _t$1 <span class='color_orange'>update:38</span>:node*</span>; <span class='color_blue'>i = 2 <span class='color_orange'>update:43</span>:int</span>; <span class='color_blue'>return = _t$0 <span class='color_orange'>initial</span>:int</span> ;
    <span class='color_blue'>x|->{next:null <span class='color_orange'>update:46</span>, v:2 <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16</span>; <span class='color_blue'>_t$1|->{next:t <span class='color_orange'>update:56</span>, v:_t$3 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16</span>; <span class='color_blue'>lsegne(t,null,[],P0)</span>
    [footprint
       <span class='color_blue'>#GB<src.c>$head = @f$0 <span class='color_orange'>rearrange:38</span>:node*</span>  ]
    where
    P0 = exists [_t$2]. <span class='color_blue'>_t$0|->{next:_t$1 <span class='color_orange'>update:56</span>, v:_t$2 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16</span></span>
    
    .... After Symbolic Execution ....
    PROP 1 of 1:
    <span class='color_blue'><span class='color_blue'>t != 0</span>; <span class='color_blue'>MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(x)</span>; <span class='color_blue'>MEMma &lt; malloc:38 &gt;  <span class='color_orange'>{vpath: }</span>(_t$1)</span> ;
    <span class='color_blue'>x = _t$4 <span class='color_orange'>update:45</span>:node*</span>; <span class='color_blue'>n = null <span class='color_orange'>update:40</span>:node*</span>; <span class='color_blue'>t = _t$2 <span class='color_orange'>update:53</span>:node*</span>; <span class='color_blue'>#GB<src.c>$head = _t$1 <span class='color_orange'>update:38</span>:node*</span>; <span class='color_blue'>i = 2 <span class='color_orange'>update:43</span>:int</span>; <span class='color_blue'>return = _t$0 <span class='color_orange'>initial</span>:int</span> ;
    <span class='color_blue'>x|->{next:null <span class='color_orange'>update:46</span>, v:2 <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16</span>; <span class='color_blue'>_t$1|->{next:t <span class='color_orange'>update:56</span>, v:_t$3 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16</span>; <span class='color_blue'>lsegne(t,null,[],P0)</span>
    [footprint
       <span class='color_blue'>#GB<src.c>$head = @f$0 <span class='color_orange'>rearrange:38</span>:node*</span>  ]
    where
    P0 = exists [_t$2]. <span class='color_blue'>_t$0|->{next:_t$1 <span class='color_orange'>update:56</span>, v:_t$2 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16</span></span>
    
    
    
  </LISTING></span><hr width="100%">
<a name="session287" href="./../nodes/main.fad58de7366495db4650cfefac2fcd61_node25.html#session287">node25#session287</a>(<a href="./../../src.c.b9996786c0d0c7ca7785f2f6d38e80de.html#LINE54">54</a>) interproc<LISTING><span class='color_black'>**** [FP:Pending] main Node: 25, Procedure: main, Session: 287, Todo: 1 ****
  PROP 1 of 1:
  <span class='color_blue'><span class='color_red'>t != 0</span>; <span class='color_red'>_t$2 != 0</span>; <span class='color_red'>MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(x)</span>; <span class='color_red'>MEMma &lt; malloc:38 &gt;  <span class='color_orange'>{vpath: }</span>(_t$1)</span> ;
  <span class='color_red'>x = _t$6 <span class='color_orange'>update:45</span>:node*</span>; <span class='color_red'>n = null <span class='color_orange'>update:40</span>:node*</span>; <span class='color_red'>t = _t$4 <span class='color_orange'>update:53</span>:node*</span>; <span class='color_red'>#GB<src.c>$head = _t$1 <span class='color_orange'>update:38</span>:node*</span>; <span class='color_red'>i = 2 <span class='color_orange'>update:43</span>:int</span>; <span class='color_red'>return = _t$0 <span class='color_orange'>initial</span>:int</span> ;
  <span class='color_red'>x|->{next:null <span class='color_orange'>update:46</span>, v:2 <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16</span>; <span class='color_red'>_t$2|->{next:t <span class='color_orange'>update:56</span>, v:_t$5 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16</span>; <span class='color_red'>_t$1|->{next:_t$2 <span class='color_orange'>update:56</span>, v:_t$3 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16</span>; <span class='color_red'>lsegne(t,null,[],P0)</span>
  [footprint
     <span class='color_red'>@f$1 != 0</span> *
     <span class='color_red'>#GB<src.c>$head = @f$0 <span class='color_orange'>rearrange:38</span>:node*</span>  ]
  where
  P0 = exists [_t$2]. <span class='color_blue'>_t$0|->{next:_t$1 <span class='color_orange'>update:56</span>, v:_t$2 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16</span></span>
  .... Instructions: .... 
  <span class='color_green'>n$17=*&amp;t:node* [line 54, column 21];
  n$18=*n$17.v:int [line 54, column 21];
  n$19=_fun_printf("%d\n":char const *,n$18:int) [line 54, column 7];
  REMOVE_TEMPS(n$17,n$18,n$19); [line 54, column 7];
  APPLY_ABSTRACTION; [line 54, column 7];
  </span>
  
  Processing prop 1/1
    Instruction <span class='color_green'>n$17=*&amp;t:node* [line 54, column 21]</span>
    in vpath_find exp:n$443
    vpath_find: found head : node*
    in vpath_find exp:n$439
    vpath_find: found x : node*
    .... Rearrangement Start ....
    Exp: &amp;t
    Prop: 
    <span class='color_blue'>t != 0; n$440 != 0; MEMma &lt; malloc:38 &gt;  <span class='color_orange'>{vpath: }</span>(n$443); MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(x) ;
    x = n$439 <span class='color_orange'>update:45</span>:node*; n = null <span class='color_orange'>update:40</span>:node*; t = n$441 <span class='color_orange'>update:53</span>:node*; #GB<src.c>$head = n$443 <span class='color_orange'>update:38</span>:node*; i = 2 <span class='color_orange'>update:43</span>:int; return = n$445 <span class='color_orange'>initial</span>:int ;
    n$443|->{next:n$440 <span class='color_orange'>update:56</span>, v:n$444 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16; n$440|->{next:t <span class='color_orange'>update:56</span>, v:n$442 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16; x|->{next:null <span class='color_orange'>update:46</span>, v:2 <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16; lsegne(t,null,[],P0)
    [footprint
       @f$1 != 0 *
       #GB<src.c>$head = @f$0 <span class='color_orange'>rearrange:38</span>:node*  ]
    where
    P0 = exists [_t$2]. _t$0|->{next:_t$1 <span class='color_orange'>update:56</span>, v:_t$2 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16</span>
    
    in prop_iter_extend_ptsto lexp: &amp;t
    prop before:
    <span class='color_blue'>t != 0; n$440 != 0; MEMma &lt; malloc:38 &gt;  <span class='color_orange'>{vpath: }</span>(n$443); MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(x) ;
    x = n$439 <span class='color_orange'>update:45</span>:node*; n = null <span class='color_orange'>update:40</span>:node*; t = n$441 <span class='color_orange'>update:53</span>:node*; #GB<src.c>$head = n$443 <span class='color_orange'>update:38</span>:node*; i = 2 <span class='color_orange'>update:43</span>:int; return = n$445 <span class='color_orange'>initial</span>:int ;
    n$443|->{next:n$440 <span class='color_orange'>update:56</span>, v:n$444 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16; n$440|->{next:t <span class='color_orange'>update:56</span>, v:n$442 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16; x|->{next:null <span class='color_orange'>update:46</span>, v:2 <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16; lsegne(t,null,[],P0)
    [footprint
       @f$1 != 0 *
       #GB<src.c>$head = @f$0 <span class='color_orange'>rearrange:38</span>:node*  ]
    where
    P0 = exists [_t$2]. _t$0|->{next:_t$1 <span class='color_orange'>update:56</span>, v:_t$2 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16</span>
    
    
    prop list after:
    PROP 1 of 1:
    <span class='color_blue'><span class='color_blue'>t != 0</span>; <span class='color_blue'>n$440 != 0</span>; <span class='color_blue'>MEMma &lt; malloc:38 &gt;  <span class='color_orange'>{vpath: }</span>(n$443)</span>; <span class='color_blue'>MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(x)</span> ;
    <span class='color_blue'>x = n$439 <span class='color_orange'>update:45</span>:node*</span>; <span class='color_blue'>n = null <span class='color_orange'>update:40</span>:node*</span>; <span class='color_blue'>t = n$441 <span class='color_orange'>update:53</span>:node*</span>; <span class='color_blue'>#GB<src.c>$head = n$443 <span class='color_orange'>update:38</span>:node*</span>; <span class='color_blue'>i = 2 <span class='color_orange'>update:43</span>:int</span>; <span class='color_blue'>return = n$445 <span class='color_orange'>initial</span>:int</span> ;
    <span class='color_blue'>n$443|->{next:n$440 <span class='color_orange'>update:56</span>, v:n$444 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16</span>; <span class='color_blue'>n$440|->{next:t <span class='color_orange'>update:56</span>, v:n$442 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16</span>; <span class='color_blue'>x|->{next:null <span class='color_orange'>update:46</span>, v:2 <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16</span>; <span class='color_blue'>lsegne(t,null,[],P0)</span>
    [footprint
       <span class='color_blue'>@f$1 != 0</span> *
       <span class='color_blue'>#GB<src.c>$head = @f$0 <span class='color_orange'>rearrange:38</span>:node*</span>  ]
    where
    P0 = exists [_t$2]. <span class='color_blue'>_t$0|->{next:_t$1 <span class='color_orange'>update:56</span>, v:_t$2 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16</span></span>
    
    
    
    Instruction Returns
    PROP 1 of 1:
    <span class='color_blue'><span class='color_blue'>_t$2 != 0</span>; <span class='color_red'>t != 0</span>; <span class='color_red'>MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(x)</span>; <span class='color_blue'>MEMma &lt; malloc:38 &gt;  <span class='color_orange'>{vpath: }</span>(_t$1)</span> ;
    <span class='color_blue'>x = <span class='color_red'>_t$5 <span class='color_orange'>update:45</span></span>:node*</span>; <span class='color_blue'>n = null <span class='color_orange'>update:40</span>:node*</span>; <span class='color_blue'>t = <span class='color_red'>n$17 <span class='color_orange'>update:53</span></span>:node*</span>; <span class='color_blue'>#GB<src.c>$head = _t$1 <span class='color_orange'>update:38</span>:node*</span>; <span class='color_blue'>i = 2 <span class='color_orange'>update:43</span>:int</span>; <span class='color_blue'>return = _t$0 <span class='color_orange'>initial</span>:int</span> ;
    <span class='color_red'>x|->{next:null <span class='color_orange'>update:46</span>, v:2 <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16</span>; <span class='color_blue'>_t$2|->{next:<span class='color_red'>t <span class='color_orange'>update:56</span></span>, v:<span class='color_red'>_t$4 <span class='color_orange'>alloc</span></span>} <span class='color_orange'>alloc</span>:node16</span>; <span class='color_blue'>_t$1|->{next:_t$2 <span class='color_orange'>update:56</span>, v:_t$3 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16</span>; <span class='color_red'>lsegne(t,null,[],P0)</span>
    [footprint
       <span class='color_blue'>@f$1 != 0</span> *
       <span class='color_blue'>#GB<src.c>$head = @f$0 <span class='color_orange'>rearrange:38</span>:node*</span>  ]
    where
    P0 = exists [_t$2]. <span class='color_blue'>_t$0|->{next:_t$1 <span class='color_orange'>update:56</span>, v:_t$2 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16</span></span>
    
    Instruction <span class='color_green'>n$18=*n$17.v:int [line 54, column 21]</span>
    in vpath_find exp:n$449
    vpath_find: found head : node*
    in vpath_find exp:n$446
    vpath_find: found x : node*
    .... Rearrangement Start ....
    Exp: n$17.v
    Prop: 
    <span class='color_blue'>n$447 != 0; t != 0; MEMma &lt; malloc:38 &gt;  <span class='color_orange'>{vpath: }</span>(n$449); MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(x) ;
    x = n$446 <span class='color_orange'>update:45</span>:node*; n = null <span class='color_orange'>update:40</span>:node*; t = n$17 <span class='color_orange'>update:53</span>:node*; #GB<src.c>$head = n$449 <span class='color_orange'>update:38</span>:node*; i = 2 <span class='color_orange'>update:43</span>:int; return = n$451 <span class='color_orange'>initial</span>:int ;
    n$449|->{next:n$447 <span class='color_orange'>update:56</span>, v:n$450 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16; n$447|->{next:t <span class='color_orange'>update:56</span>, v:n$448 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16; x|->{next:null <span class='color_orange'>update:46</span>, v:2 <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16; lsegne(t,null,[],P0)
    [footprint
       @f$1 != 0 *
       #GB<src.c>$head = @f$0 <span class='color_orange'>rearrange:38</span>:node*  ]
    where
    P0 = exists [_t$2]. _t$0|->{next:_t$1 <span class='color_orange'>update:56</span>, v:_t$2 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16</span>
    
    in prop_iter_extend_ptsto lexp: n$17.v
    prop before:
    <span class='color_blue'>n$447 != 0; t != 0; MEMma &lt; malloc:38 &gt;  <span class='color_orange'>{vpath: }</span>(n$449); MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(x) ;
    x = n$446 <span class='color_orange'>update:45</span>:node*; n = null <span class='color_orange'>update:40</span>:node*; t = n$17 <span class='color_orange'>update:53</span>:node*; #GB<src.c>$head = n$449 <span class='color_orange'>update:38</span>:node*; i = 2 <span class='color_orange'>update:43</span>:int; return = n$451 <span class='color_orange'>initial</span>:int ;
    n$449|->{next:n$447 <span class='color_orange'>update:56</span>, v:n$450 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16; n$447|->{next:t <span class='color_orange'>update:56</span>, v:n$448 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16; x|->{next:null <span class='color_orange'>update:46</span>, v:2 <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16; t|->{next:_t$630 <span class='color_orange'>update:56</span>, v:_t$631 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16; lseg(_t$630,null,[],P0)
    [footprint
       @f$1 != 0 *
       #GB<src.c>$head = @f$0 <span class='color_orange'>rearrange:38</span>:node*  ]
    where
    P0 = exists [_t$2]. _t$0|->{next:_t$1 <span class='color_orange'>update:56</span>, v:_t$2 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16</span>
    
    
    prop list after:
    PROP 1 of 1:
    <span class='color_blue'><span class='color_blue'>n$447 != 0</span>; <span class='color_blue'>t != 0</span>; <span class='color_blue'>MEMma &lt; malloc:38 &gt;  <span class='color_orange'>{vpath: }</span>(n$449)</span>; <span class='color_blue'>MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(x)</span> ;
    <span class='color_blue'>x = n$446 <span class='color_orange'>update:45</span>:node*</span>; <span class='color_blue'>n = null <span class='color_orange'>update:40</span>:node*</span>; <span class='color_blue'>t = n$17 <span class='color_orange'>update:53</span>:node*</span>; <span class='color_blue'>#GB<src.c>$head = n$449 <span class='color_orange'>update:38</span>:node*</span>; <span class='color_blue'>i = 2 <span class='color_orange'>update:43</span>:int</span>; <span class='color_blue'>return = n$451 <span class='color_orange'>initial</span>:int</span> ;
    <span class='color_blue'>n$449|->{next:n$447 <span class='color_orange'>update:56</span>, v:n$450 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16</span>; <span class='color_blue'>n$447|->{next:t <span class='color_orange'>update:56</span>, v:n$448 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16</span>; <span class='color_blue'>x|->{next:null <span class='color_orange'>update:46</span>, v:2 <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16</span>; <span class='color_blue'>t|->{next:_t$630 <span class='color_orange'>update:56</span>, v:_t$631 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16</span>; <span class='color_blue'>lseg(_t$630,null,[],P0)</span>
    [footprint
       <span class='color_blue'>@f$1 != 0</span> *
       <span class='color_blue'>#GB<src.c>$head = @f$0 <span class='color_orange'>rearrange:38</span>:node*</span>  ]
    where
    P0 = exists [_t$2]. <span class='color_blue'>_t$0|->{next:_t$1 <span class='color_orange'>update:56</span>, v:_t$2 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16</span></span>
    
    
    
    Instruction Returns
    PROP 1 of 1:
    <span class='color_blue'><span class='color_blue'>_t$2 != 0</span>; <span class='color_blue'>t != 0</span>; <span class='color_red'>MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(x)</span>; <span class='color_blue'>MEMma &lt; malloc:38 &gt;  <span class='color_orange'>{vpath: }</span>(_t$1)</span>; <span class='color_red'>DANGL &lt; UNINIT &gt; (n$18)</span> ;
    <span class='color_blue'>x = <span class='color_red'>_t$6 <span class='color_orange'>update:45</span></span>:node*</span>; <span class='color_blue'>n = null <span class='color_orange'>update:40</span>:node*</span>; <span class='color_blue'>t = n$17 <span class='color_orange'>update:53</span>:node*</span>; <span class='color_blue'>#GB<src.c>$head = _t$1 <span class='color_orange'>update:38</span>:node*</span>; <span class='color_blue'>i = 2 <span class='color_orange'>update:43</span>:int</span>; <span class='color_blue'>return = _t$0 <span class='color_orange'>initial</span>:int</span> ;
    <span class='color_red'>x|->{next:null <span class='color_orange'>update:46</span>, v:2 <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16</span>; <span class='color_blue'>_t$2|->{next:t <span class='color_orange'>update:56</span>, v:_t$4 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16</span>; <span class='color_blue'>_t$1|->{next:_t$2 <span class='color_orange'>update:56</span>, v:_t$3 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16</span>; <span class='color_blue'>t|->{next:_t$5 <span class='color_orange'>update:56</span>, v:n$18 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16</span>; <span class='color_blue'>lseg(_t$5,null,[],P0)</span>
    [footprint
       <span class='color_blue'>@f$1 != 0</span> *
       <span class='color_blue'>#GB<src.c>$head = @f$0 <span class='color_orange'>rearrange:38</span>:node*</span>  ]
    where
    P0 = exists [_t$2]. <span class='color_blue'>_t$0|->{next:_t$1 <span class='color_orange'>update:56</span>, v:_t$2 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16</span></span>
    
    Instruction <span class='color_green'>n$19=_fun_printf("%d\n":char const *,n$18:int) [line 54, column 7]</span>
    in vpath_find exp:n$455
    vpath_find: found head : node*
    in vpath_find exp:n$452
    vpath_find: found x : node*
    <span class='color_orange'>WARNING: likely use of variable-arguments function, or function prototype missing</span>
    actual parameters: n$18
    formal parameters: 
    Found 1 specs for function printf
    START EXECUTING SPECS FOR printf from state
    <span class='color_blue'>n$453 != 0; t != 0; MEMma &lt; malloc:38 &gt;  <span class='color_orange'>{vpath: }</span>(n$455); MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(x); DANGL &lt; UNINIT &gt; (n$18) ;
    x = n$452 <span class='color_orange'>update:45</span>:node*; n = null <span class='color_orange'>update:40</span>:node*; t = n$17 <span class='color_orange'>update:53</span>:node*; #GB<src.c>$head = n$455 <span class='color_orange'>update:38</span>:node*; i = 2 <span class='color_orange'>update:43</span>:int; return = n$458 <span class='color_orange'>initial</span>:int ;
    n$455|->{next:n$453 <span class='color_orange'>update:56</span>, v:n$456 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16; n$453|->{next:t <span class='color_orange'>update:56</span>, v:n$454 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16; x|->{next:null <span class='color_orange'>update:46</span>, v:2 <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16; t|->{next:n$457 <span class='color_orange'>update:56</span>, v:n$18 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16; lseg(n$457,null,[],P0)
    [footprint
       @f$1 != 0 *
       #GB<src.c>$head = @f$0 <span class='color_orange'>rearrange:38</span>:node*  ]
    where
    P0 = exists [_t$2]. _t$0|->{next:_t$1 <span class='color_orange'>update:56</span>, v:_t$2 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16</span>
    <span class='color_orange'>WARNING: more actual pars than formal pars in fun call (2 vs 1)</span>
    EXECUTING SPEC 1/1
    ACTUAL PRECONDITION =
      <span class='color_blue'>n$453 != 0; t != 0; MEMma &lt; malloc:38 &gt;  <span class='color_orange'>{vpath: }</span>(n$455); MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(x); DANGL &lt; UNINIT &gt; (n$18) ;
      x = n$452 <span class='color_orange'>update:45</span>:node*; n = null <span class='color_orange'>update:40</span>:node*; t = n$17 <span class='color_orange'>update:53</span>:node*; #GB<src.c>$head = n$455 <span class='color_orange'>update:38</span>:node*; i = 2 <span class='color_orange'>update:43</span>:int; format|callee = "%d\n" <span class='color_orange'>actual_precondition</span>:char const *; return = n$458 <span class='color_orange'>initial</span>:int ;
      n$455|->{next:n$453 <span class='color_orange'>update:56</span>, v:n$456 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16; n$453|->{next:t <span class='color_orange'>update:56</span>, v:n$454 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16; x|->{next:null <span class='color_orange'>update:46</span>, v:2 <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16; t|->{next:n$457 <span class='color_orange'>update:56</span>, v:n$18 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16; lseg(n$457,null,[],P0)
      [footprint
         @f$1 != 0 *
         #GB<src.c>$head = @f$0 <span class='color_orange'>rearrange:38</span>:node*  ]
      where
      P0 = exists [_t$2]. _t$0|->{next:_t$1 <span class='color_orange'>update:56</span>, v:_t$2 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16</span>
    SPEC =
      --------------------------- ---------- ---------------------------
      PRE:
      <span class='color_blue'><span class='color_blue'>format|callee = _t$639 <span class='color_orange'>formal</span>:char const *</span></span>
      POST 1 of 1:
      <span class='color_blue'><span class='color_red'>(-1  &lt;  _t$640)</span>; <span class='color_red'>DANGL &lt; UNINIT &gt; (return|callee)</span> ;
      <span class='color_red'>return|callee = _t$640 <span class='color_orange'>update:1114</span>:int</span></span>
      ----------------------------------------------------------------
    pre_check_pure_implication
    pi1:
      n$453 != 0; n$17 != 0; MEMma &lt; malloc:38 &gt;  <span class='color_orange'>{vpath: }</span>(n$455); MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(n$452); DANGL &lt; UNINIT &gt; (n$18)
    pi2:
      
    returns
    sub1: 
      
    sub2: 
      
    Current Implication
    SUB:
      
    <span class='color_blue'>n$453 != 0; t != 0; MEMma &lt; malloc:38 &gt;  <span class='color_orange'>{vpath: }</span>(n$455); MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(x); DANGL &lt; UNINIT &gt; (n$18) ;
    x = n$452 <span class='color_orange'>update:45</span>:node*; n = null <span class='color_orange'>update:40</span>:node*; t = n$17 <span class='color_orange'>update:53</span>:node*; #GB<src.c>$head = n$455 <span class='color_orange'>update:38</span>:node*; i = 2 <span class='color_orange'>update:43</span>:int; format|callee = "%d\n" <span class='color_orange'>actual_precondition</span>:char const *; return = n$458 <span class='color_orange'>initial</span>:int ;
    n$455|->{next:n$453 <span class='color_orange'>update:56</span>, v:n$456 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16; n$453|->{next:t <span class='color_orange'>update:56</span>, v:n$454 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16; x|->{next:null <span class='color_orange'>update:46</span>, v:2 <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16; t|->{next:n$457 <span class='color_orange'>update:56</span>, v:n$18 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16; lseg(n$457,null,[],P0)
    [footprint
       @f$1 != 0 *
       #GB<src.c>$head = @f$0 <span class='color_orange'>rearrange:38</span>:node*  ]
    where
    P0 = exists [_t$2]. _t$0|->{next:_t$1 <span class='color_orange'>update:56</span>, v:_t$2 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16</span>
    |-
    <span class='color_blue'>format|callee = _t$639 <span class='color_orange'>formal</span>:char const *</span>
    
      do_imply "%d\n" _t$639
        Final Implication
        SUB:
          
        <span class='color_blue'>n$453 != 0; t != 0; MEMma &lt; malloc:38 &gt;  <span class='color_orange'>{vpath: }</span>(n$455); MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(x); DANGL &lt; UNINIT &gt; (n$18) ;
        x = n$452 <span class='color_orange'>update:45</span>:node*; n = null <span class='color_orange'>update:40</span>:node*; t = n$17 <span class='color_orange'>update:53</span>:node*; #GB<src.c>$head = n$455 <span class='color_orange'>update:38</span>:node*; i = 2 <span class='color_orange'>update:43</span>:int; return = n$458 <span class='color_orange'>initial</span>:int ;
        n$455|->{next:n$453 <span class='color_orange'>update:56</span>, v:n$456 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16; n$453|->{next:t <span class='color_orange'>update:56</span>, v:n$454 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16; x|->{next:null <span class='color_orange'>update:46</span>, v:2 <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16; t|->{next:n$457 <span class='color_orange'>update:56</span>, v:n$18 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16; lseg(n$457,null,[],P0)
        [footprint
           @f$1 != 0 *
           #GB<src.c>$head = @f$0 <span class='color_orange'>rearrange:38</span>:node*  ]
        where
        P0 = exists [_t$2]. _t$0|->{next:_t$1 <span class='color_orange'>update:56</span>, v:_t$2 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16</span>
        [SUB: 
          _t$639 = "%d\n"]
        |-
        <span class='color_blue'></span>
    Result of Abduction
      SUB:
        
      <span class='color_blue'>n$453 != 0; t != 0; MEMma &lt; malloc:38 &gt;  <span class='color_orange'>{vpath: }</span>(n$455); MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(x); DANGL &lt; UNINIT &gt; (n$18) ;
      x = n$452 <span class='color_orange'>update:45</span>:node*; n = null <span class='color_orange'>update:40</span>:node*; t = n$17 <span class='color_orange'>update:53</span>:node*; #GB<src.c>$head = n$455 <span class='color_orange'>update:38</span>:node*; i = 2 <span class='color_orange'>update:43</span>:int; format|callee = "%d\n" <span class='color_orange'>actual_precondition</span>:char const *; return = n$458 <span class='color_orange'>initial</span>:int ;
      n$455|->{next:n$453 <span class='color_orange'>update:56</span>, v:n$456 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16; n$453|->{next:t <span class='color_orange'>update:56</span>, v:n$454 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16; x|->{next:null <span class='color_orange'>update:46</span>, v:2 <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16; t|->{next:n$457 <span class='color_orange'>update:56</span>, v:n$18 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16; lseg(n$457,null,[],P0)
      [footprint
         @f$1 != 0 *
         #GB<src.c>$head = @f$0 <span class='color_orange'>rearrange:38</span>:node*  ]
      where
      P0 = exists [_t$2]. _t$0|->{next:_t$1 <span class='color_orange'>update:56</span>, v:_t$2 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16</span>
      [SUB: 
        _t$639 = "%d\n"]
      |-
      <span class='color_blue'>format|callee = "%d\n" <span class='color_orange'>formal</span>:char const *</span>
    returning TRUE
      New footprint:
      
      Frame fld:
      
      Missing fld:
      
      Instantiated frame:
      n$455|->{next:n$453 <span class='color_orange'>update:56</span>, v:n$456 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16; n$453|->{next:n$17 <span class='color_orange'>update:56</span>, v:n$454 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16; n$452|->{next:null <span class='color_orange'>update:46</span>, v:2 <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16; n$17|->{next:n$457 <span class='color_orange'>update:56</span>, v:n$18 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16; &amp;x|->n$452 <span class='color_orange'>update:45</span>:node*; &amp;n|->null <span class='color_orange'>update:40</span>:node*; &amp;t|->n$17 <span class='color_orange'>update:53</span>:node*; &amp;#GB<src.c>$head|->n$455 <span class='color_orange'>update:38</span>:node*; &amp;i|->2 <span class='color_orange'>update:43</span>:int; &amp;return|->n$458 <span class='color_orange'>initial</span>:int; lseg(n$457,null,[],lam [_t$0,_t$1,]. exists [_t$2]. _t$0|->{next:_t$1 <span class='color_orange'>update:56</span>, v:_t$2 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16)
      Instantiated post:
      PROP 1 of 1:
      <span class='color_blue'><span class='color_red'>(-1  &lt;  _t$640)</span>; <span class='color_red'>DANGL &lt; UNINIT &gt; (return|callee)</span> ;
      <span class='color_red'>return|callee = _t$640 <span class='color_orange'>update:54</span>:int</span></span>
      
    ***** RESULTS FUNCTION CALL *******
    PROP 1 of 1:
    <span class='color_blue'><span class='color_red'>(-1  &lt;  n$19)</span>; <span class='color_blue'>n$453 != 0</span>; <span class='color_blue'>t != 0</span>; <span class='color_blue'>MEMma &lt; malloc:38 &gt;  <span class='color_orange'>{vpath: }</span>(n$455)</span>; <span class='color_blue'>MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(x)</span>; <span class='color_red'>DANGL &lt; UNINIT &gt; (n$19)</span>; <span class='color_blue'>DANGL &lt; UNINIT &gt; (n$18)</span> ;
    <span class='color_blue'>x = n$452 <span class='color_orange'>update:45</span>:node*</span>; <span class='color_blue'>n = null <span class='color_orange'>update:40</span>:node*</span>; <span class='color_blue'>t = n$17 <span class='color_orange'>update:53</span>:node*</span>; <span class='color_blue'>#GB<src.c>$head = n$455 <span class='color_orange'>update:38</span>:node*</span>; <span class='color_blue'>i = 2 <span class='color_orange'>update:43</span>:int</span>; <span class='color_blue'>return = n$458 <span class='color_orange'>initial</span>:int</span> ;
    <span class='color_blue'>n$455|->{next:n$453 <span class='color_orange'>update:56</span>, v:n$456 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16</span>; <span class='color_blue'>n$453|->{next:t <span class='color_orange'>update:56</span>, v:n$454 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16</span>; <span class='color_blue'>x|->{next:null <span class='color_orange'>update:46</span>, v:2 <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16</span>; <span class='color_blue'>t|->{next:n$457 <span class='color_orange'>update:56</span>, v:n$18 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16</span>; <span class='color_blue'>lseg(n$457,null,[],P0)</span>
    [footprint
       <span class='color_blue'>@f$1 != 0</span> *
       <span class='color_blue'>#GB<src.c>$head = @f$0 <span class='color_orange'>rearrange:38</span>:node*</span>  ]
    where
    P0 = exists [_t$2]. <span class='color_blue'>_t$0|->{next:_t$1 <span class='color_orange'>update:56</span>, v:_t$2 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16</span></span>
    ***** END RESULTS FUNCTION CALL *******
    Instruction Returns
    PROP 1 of 1:
    <span class='color_blue'><span class='color_red'>(-1  &lt;  n$19)</span>; <span class='color_blue'>_t$2 != 0</span>; <span class='color_blue'>t != 0</span>; <span class='color_blue'>MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(x)</span>; <span class='color_blue'>MEMma &lt; malloc:38 &gt;  <span class='color_orange'>{vpath: }</span>(_t$1)</span>; <span class='color_red'>DANGL &lt; UNINIT &gt; (n$19)</span>; <span class='color_blue'>DANGL &lt; UNINIT &gt; (n$18)</span> ;
    <span class='color_blue'>x = _t$6 <span class='color_orange'>update:45</span>:node*</span>; <span class='color_blue'>n = null <span class='color_orange'>update:40</span>:node*</span>; <span class='color_blue'>t = n$17 <span class='color_orange'>update:53</span>:node*</span>; <span class='color_blue'>#GB<src.c>$head = _t$1 <span class='color_orange'>update:38</span>:node*</span>; <span class='color_blue'>i = 2 <span class='color_orange'>update:43</span>:int</span>; <span class='color_blue'>return = _t$0 <span class='color_orange'>initial</span>:int</span> ;
    <span class='color_blue'>x|->{next:null <span class='color_orange'>update:46</span>, v:2 <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16</span>; <span class='color_blue'>_t$2|->{next:t <span class='color_orange'>update:56</span>, v:_t$4 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16</span>; <span class='color_blue'>_t$1|->{next:_t$2 <span class='color_orange'>update:56</span>, v:_t$3 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16</span>; <span class='color_blue'>t|->{next:_t$5 <span class='color_orange'>update:56</span>, v:n$18 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16</span>; <span class='color_blue'>lseg(_t$5,null,[],P0)</span>
    [footprint
       <span class='color_blue'>@f$1 != 0</span> *
       <span class='color_blue'>#GB<src.c>$head = @f$0 <span class='color_orange'>rearrange:38</span>:node*</span>  ]
    where
    P0 = exists [_t$2]. <span class='color_blue'>_t$0|->{next:_t$1 <span class='color_orange'>update:56</span>, v:_t$2 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16</span></span>
    
    Instruction <span class='color_green'>REMOVE_TEMPS(n$17,n$18,n$19); [line 54, column 7]</span>
    in vpath_find exp:_t$6
    vpath_find: found x : node*
    in vpath_find exp:_t$1
    vpath_find: found head : node*
    Instruction Returns
    PROP 1 of 1:
    <span class='color_blue'><span class='color_red'>(-1  &lt;  _t$9)</span>; <span class='color_red'>t != 0</span>; <span class='color_blue'>_t$2 != 0</span>; <span class='color_red'>MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(x)</span>; <span class='color_blue'>MEMma &lt; malloc:38 &gt;  <span class='color_orange'>{vpath: }</span>(_t$1)</span>; <span class='color_red'>DANGL &lt; UNINIT &gt; (_t$9)</span>; <span class='color_red'>DANGL &lt; UNINIT &gt; (_t$7)</span> ;
    <span class='color_blue'>x = <span class='color_red'>_t$8 <span class='color_orange'>update:45</span></span>:node*</span>; <span class='color_blue'>n = null <span class='color_orange'>update:40</span>:node*</span>; <span class='color_blue'>t = <span class='color_red'>_t$4 <span class='color_orange'>update:53</span></span>:node*</span>; <span class='color_blue'>#GB<src.c>$head = _t$1 <span class='color_orange'>update:38</span>:node*</span>; <span class='color_blue'>i = 2 <span class='color_orange'>update:43</span>:int</span>; <span class='color_blue'>return = _t$0 <span class='color_orange'>initial</span>:int</span> ;
    <span class='color_red'>x|->{next:null <span class='color_orange'>update:46</span>, v:2 <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16</span>; <span class='color_red'>t|->{next:_t$6 <span class='color_orange'>update:56</span>, v:_t$7 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16</span>; <span class='color_blue'>_t$2|->{next:<span class='color_red'>t <span class='color_orange'>update:56</span></span>, v:<span class='color_red'>_t$5 <span class='color_orange'>alloc</span></span>} <span class='color_orange'>alloc</span>:node16</span>; <span class='color_blue'>_t$1|->{next:_t$2 <span class='color_orange'>update:56</span>, v:_t$3 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16</span>; <span class='color_blue'>lseg(_t$6,null,[],P0)</span>
    [footprint
       <span class='color_blue'>@f$1 != 0</span> *
       <span class='color_blue'>#GB<src.c>$head = @f$0 <span class='color_orange'>rearrange:38</span>:node*</span>  ]
    where
    P0 = exists [_t$2]. <span class='color_blue'>_t$0|->{next:_t$1 <span class='color_orange'>update:56</span>, v:_t$2 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16</span></span>
    
    Instruction <span class='color_green'>APPLY_ABSTRACTION; [line 54, column 7]</span>
    in vpath_find exp:_t$8
    vpath_find: found x : node*
    in vpath_find exp:_t$1
    vpath_find: found head : node*
    <span class='color_blue'>t != 0; MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(x); MEMma &lt; malloc:38 &gt;  <span class='color_orange'>{vpath: }</span>(_t$1) ;
    x = _t$3 <span class='color_orange'>update:45</span>:node*; n = null <span class='color_orange'>update:40</span>:node*; t = _t$2 <span class='color_orange'>update:53</span>:node*; #GB<src.c>$head = _t$1 <span class='color_orange'>update:38</span>:node*; i = 2 <span class='color_orange'>update:43</span>:int; return = _t$0 <span class='color_orange'>initial</span>:int ;
    x|->{next:null <span class='color_orange'>update:46</span>, v:2 <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16; lsegne(t,null,[],P0); lsegne(_t$1,t,[],P0)
    [footprint
       #GB<src.c>$head = @f$0 <span class='color_orange'>rearrange:38</span>:node*  ]
    where
    P0 = exists [_t$2]. _t$0|->{next:_t$1 <span class='color_orange'>update:56</span>, v:_t$2 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16</span>
    Instruction Returns
    PROP 1 of 1:
    <span class='color_blue'><span class='color_blue'>t != 0</span>; <span class='color_red'>MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(x)</span>; <span class='color_blue'>MEMma &lt; malloc:38 &gt;  <span class='color_orange'>{vpath: }</span>(_t$1)</span> ;
    <span class='color_blue'>x = <span class='color_red'>_t$3 <span class='color_orange'>update:45</span></span>:node*</span>; <span class='color_blue'>n = null <span class='color_orange'>update:40</span>:node*</span>; <span class='color_blue'>t = <span class='color_red'>_t$2 <span class='color_orange'>update:53</span></span>:node*</span>; <span class='color_blue'>#GB<src.c>$head = _t$1 <span class='color_orange'>update:38</span>:node*</span>; <span class='color_blue'>i = 2 <span class='color_orange'>update:43</span>:int</span>; <span class='color_blue'>return = _t$0 <span class='color_orange'>initial</span>:int</span> ;
    <span class='color_red'>x|->{next:null <span class='color_orange'>update:46</span>, v:2 <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16</span>; <span class='color_blue'>lsegne(t,null,[],P0)</span>; <span class='color_blue'>lsegne(_t$1,t,[],P0)</span>
    [footprint
       <span class='color_blue'>#GB<src.c>$head = @f$0 <span class='color_orange'>rearrange:38</span>:node*</span>  ]
    where
    P0 = exists [_t$2]. <span class='color_blue'>_t$0|->{next:_t$1 <span class='color_orange'>update:56</span>, v:_t$2 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16</span></span>
    
    .... After Symbolic Execution ....
    PROP 1 of 1:
    <span class='color_blue'><span class='color_blue'>t != 0</span>; <span class='color_red'>MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(x)</span>; <span class='color_blue'>MEMma &lt; malloc:38 &gt;  <span class='color_orange'>{vpath: }</span>(_t$1)</span> ;
    <span class='color_blue'>x = <span class='color_red'>_t$3 <span class='color_orange'>update:45</span></span>:node*</span>; <span class='color_blue'>n = null <span class='color_orange'>update:40</span>:node*</span>; <span class='color_blue'>t = <span class='color_red'>_t$2 <span class='color_orange'>update:53</span></span>:node*</span>; <span class='color_blue'>#GB<src.c>$head = _t$1 <span class='color_orange'>update:38</span>:node*</span>; <span class='color_blue'>i = 2 <span class='color_orange'>update:43</span>:int</span>; <span class='color_blue'>return = _t$0 <span class='color_orange'>initial</span>:int</span> ;
    <span class='color_red'>x|->{next:null <span class='color_orange'>update:46</span>, v:2 <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16</span>; <span class='color_blue'>lsegne(t,null,[],P0)</span>; <span class='color_blue'>lsegne(_t$1,t,[],P0)</span>
    [footprint
       <span class='color_blue'>#GB<src.c>$head = @f$0 <span class='color_orange'>rearrange:38</span>:node*</span>  ]
    where
    P0 = exists [_t$2]. <span class='color_blue'>_t$0|->{next:_t$1 <span class='color_orange'>update:56</span>, v:_t$2 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16</span></span>
    
    
    
  </LISTING></span><hr width="100%">
<a name="session292" href="./../nodes/main.fad58de7366495db4650cfefac2fcd61_node25.html#session292">node25#session292</a>(<a href="./../../src.c.b9996786c0d0c7ca7785f2f6d38e80de.html#LINE54">54</a>) interproc<LISTING><span class='color_black'>**** [FP:Pending] main Node: 25, Procedure: main, Session: 292, Todo: 1 ****
  PROP 1 of 1:
  <span class='color_blue'><span class='color_red'>t != 0</span>; <span class='color_red'>_t$2 != 0</span>; <span class='color_red'>MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(x)</span>; <span class='color_red'>MEMma &lt; malloc:38 &gt;  <span class='color_orange'>{vpath: }</span>(_t$1)</span> ;
  <span class='color_red'>x = _t$5 <span class='color_orange'>update:45</span>:node*</span>; <span class='color_red'>n = null <span class='color_orange'>update:40</span>:node*</span>; <span class='color_red'>t = _t$3 <span class='color_orange'>update:53</span>:node*</span>; <span class='color_red'>#GB<src.c>$head = _t$1 <span class='color_orange'>update:38</span>:node*</span>; <span class='color_red'>i = 2 <span class='color_orange'>update:43</span>:int</span>; <span class='color_red'>return = _t$0 <span class='color_orange'>initial</span>:int</span> ;
  <span class='color_red'>x|->{next:null <span class='color_orange'>update:46</span>, v:2 <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16</span>; <span class='color_red'>_t$2|->{next:t <span class='color_orange'>update:56</span>, v:_t$4 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16</span>; <span class='color_red'>lsegne(t,null,[],P0)</span>; <span class='color_red'>lsegne(_t$1,_t$2,[],P0)</span>
  [footprint
     <span class='color_red'>@f$1 != 0</span> *
     <span class='color_red'>#GB<src.c>$head = @f$0 <span class='color_orange'>rearrange:38</span>:node*</span>  ]
  where
  P0 = exists [_t$2]. <span class='color_blue'>_t$0|->{next:_t$1 <span class='color_orange'>update:56</span>, v:_t$2 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16</span></span>
  .... Instructions: .... 
  <span class='color_green'>n$17=*&amp;t:node* [line 54, column 21];
  n$18=*n$17.v:int [line 54, column 21];
  n$19=_fun_printf("%d\n":char const *,n$18:int) [line 54, column 7];
  REMOVE_TEMPS(n$17,n$18,n$19); [line 54, column 7];
  APPLY_ABSTRACTION; [line 54, column 7];
  </span>
  
  Processing prop 1/1
    Instruction <span class='color_green'>n$17=*&amp;t:node* [line 54, column 21]</span>
    in vpath_find exp:n$500
    vpath_find: found head : node*
    in vpath_find exp:n$496
    vpath_find: found x : node*
    .... Rearrangement Start ....
    Exp: &amp;t
    Prop: 
    <span class='color_blue'>t != 0; n$497 != 0; MEMma &lt; malloc:38 &gt;  <span class='color_orange'>{vpath: }</span>(n$500); MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(x) ;
    x = n$496 <span class='color_orange'>update:45</span>:node*; n = null <span class='color_orange'>update:40</span>:node*; t = n$498 <span class='color_orange'>update:53</span>:node*; #GB<src.c>$head = n$500 <span class='color_orange'>update:38</span>:node*; i = 2 <span class='color_orange'>update:43</span>:int; return = n$501 <span class='color_orange'>initial</span>:int ;
    n$497|->{next:t <span class='color_orange'>update:56</span>, v:n$499 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16; x|->{next:null <span class='color_orange'>update:46</span>, v:2 <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16; lsegne(n$500,n$497,[],P0); lsegne(t,null,[],P0)
    [footprint
       @f$1 != 0 *
       #GB<src.c>$head = @f$0 <span class='color_orange'>rearrange:38</span>:node*  ]
    where
    P0 = exists [_t$2]. _t$0|->{next:_t$1 <span class='color_orange'>update:56</span>, v:_t$2 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16</span>
    
    in prop_iter_extend_ptsto lexp: &amp;t
    prop before:
    <span class='color_blue'>t != 0; n$497 != 0; MEMma &lt; malloc:38 &gt;  <span class='color_orange'>{vpath: }</span>(n$500); MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(x) ;
    x = n$496 <span class='color_orange'>update:45</span>:node*; n = null <span class='color_orange'>update:40</span>:node*; t = n$498 <span class='color_orange'>update:53</span>:node*; #GB<src.c>$head = n$500 <span class='color_orange'>update:38</span>:node*; i = 2 <span class='color_orange'>update:43</span>:int; return = n$501 <span class='color_orange'>initial</span>:int ;
    n$497|->{next:t <span class='color_orange'>update:56</span>, v:n$499 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16; x|->{next:null <span class='color_orange'>update:46</span>, v:2 <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16; lsegne(n$500,n$497,[],P0); lsegne(t,null,[],P0)
    [footprint
       @f$1 != 0 *
       #GB<src.c>$head = @f$0 <span class='color_orange'>rearrange:38</span>:node*  ]
    where
    P0 = exists [_t$2]. _t$0|->{next:_t$1 <span class='color_orange'>update:56</span>, v:_t$2 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16</span>
    
    
    prop list after:
    PROP 1 of 1:
    <span class='color_blue'><span class='color_blue'>t != 0</span>; <span class='color_blue'>n$497 != 0</span>; <span class='color_blue'>MEMma &lt; malloc:38 &gt;  <span class='color_orange'>{vpath: }</span>(n$500)</span>; <span class='color_blue'>MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(x)</span> ;
    <span class='color_blue'>x = n$496 <span class='color_orange'>update:45</span>:node*</span>; <span class='color_blue'>n = null <span class='color_orange'>update:40</span>:node*</span>; <span class='color_blue'>t = n$498 <span class='color_orange'>update:53</span>:node*</span>; <span class='color_blue'>#GB<src.c>$head = n$500 <span class='color_orange'>update:38</span>:node*</span>; <span class='color_blue'>i = 2 <span class='color_orange'>update:43</span>:int</span>; <span class='color_blue'>return = n$501 <span class='color_orange'>initial</span>:int</span> ;
    <span class='color_blue'>n$497|->{next:t <span class='color_orange'>update:56</span>, v:n$499 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16</span>; <span class='color_blue'>x|->{next:null <span class='color_orange'>update:46</span>, v:2 <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16</span>; <span class='color_blue'>lsegne(n$500,n$497,[],P0)</span>; <span class='color_blue'>lsegne(t,null,[],P0)</span>
    [footprint
       <span class='color_blue'>@f$1 != 0</span> *
       <span class='color_blue'>#GB<src.c>$head = @f$0 <span class='color_orange'>rearrange:38</span>:node*</span>  ]
    where
    P0 = exists [_t$2]. <span class='color_blue'>_t$0|->{next:_t$1 <span class='color_orange'>update:56</span>, v:_t$2 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16</span></span>
    
    
    
    Instruction Returns
    PROP 1 of 1:
    <span class='color_blue'><span class='color_blue'>_t$2 != 0</span>; <span class='color_red'>t != 0</span>; <span class='color_red'>MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(x)</span>; <span class='color_blue'>MEMma &lt; malloc:38 &gt;  <span class='color_orange'>{vpath: }</span>(_t$1)</span> ;
    <span class='color_blue'>x = <span class='color_red'>_t$4 <span class='color_orange'>update:45</span></span>:node*</span>; <span class='color_blue'>n = null <span class='color_orange'>update:40</span>:node*</span>; <span class='color_blue'>t = <span class='color_red'>n$17 <span class='color_orange'>update:53</span></span>:node*</span>; <span class='color_blue'>#GB<src.c>$head = _t$1 <span class='color_orange'>update:38</span>:node*</span>; <span class='color_blue'>i = 2 <span class='color_orange'>update:43</span>:int</span>; <span class='color_blue'>return = _t$0 <span class='color_orange'>initial</span>:int</span> ;
    <span class='color_red'>x|->{next:null <span class='color_orange'>update:46</span>, v:2 <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16</span>; <span class='color_blue'>_t$2|->{next:<span class='color_red'>t <span class='color_orange'>update:56</span></span>, v:<span class='color_red'>_t$3 <span class='color_orange'>alloc</span></span>} <span class='color_orange'>alloc</span>:node16</span>; <span class='color_blue'>lsegne(_t$1,_t$2,[],P0)</span>; <span class='color_red'>lsegne(t,null,[],P0)</span>
    [footprint
       <span class='color_blue'>@f$1 != 0</span> *
       <span class='color_blue'>#GB<src.c>$head = @f$0 <span class='color_orange'>rearrange:38</span>:node*</span>  ]
    where
    P0 = exists [_t$2]. <span class='color_blue'>_t$0|->{next:_t$1 <span class='color_orange'>update:56</span>, v:_t$2 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16</span></span>
    
    Instruction <span class='color_green'>n$18=*n$17.v:int [line 54, column 21]</span>
    in vpath_find exp:n$505
    vpath_find: found head : node*
    in vpath_find exp:n$502
    vpath_find: found x : node*
    .... Rearrangement Start ....
    Exp: n$17.v
    Prop: 
    <span class='color_blue'>n$503 != 0; t != 0; MEMma &lt; malloc:38 &gt;  <span class='color_orange'>{vpath: }</span>(n$505); MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(x) ;
    x = n$502 <span class='color_orange'>update:45</span>:node*; n = null <span class='color_orange'>update:40</span>:node*; t = n$17 <span class='color_orange'>update:53</span>:node*; #GB<src.c>$head = n$505 <span class='color_orange'>update:38</span>:node*; i = 2 <span class='color_orange'>update:43</span>:int; return = n$506 <span class='color_orange'>initial</span>:int ;
    n$503|->{next:t <span class='color_orange'>update:56</span>, v:n$504 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16; x|->{next:null <span class='color_orange'>update:46</span>, v:2 <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16; lsegne(n$505,n$503,[],P0); lsegne(t,null,[],P0)
    [footprint
       @f$1 != 0 *
       #GB<src.c>$head = @f$0 <span class='color_orange'>rearrange:38</span>:node*  ]
    where
    P0 = exists [_t$2]. _t$0|->{next:_t$1 <span class='color_orange'>update:56</span>, v:_t$2 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16</span>
    
    in prop_iter_extend_ptsto lexp: n$17.v
    prop before:
    <span class='color_blue'>n$503 != 0; t != 0; MEMma &lt; malloc:38 &gt;  <span class='color_orange'>{vpath: }</span>(n$505); MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(x) ;
    x = n$502 <span class='color_orange'>update:45</span>:node*; n = null <span class='color_orange'>update:40</span>:node*; t = n$17 <span class='color_orange'>update:53</span>:node*; #GB<src.c>$head = n$505 <span class='color_orange'>update:38</span>:node*; i = 2 <span class='color_orange'>update:43</span>:int; return = n$506 <span class='color_orange'>initial</span>:int ;
    n$503|->{next:t <span class='color_orange'>update:56</span>, v:n$504 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16; x|->{next:null <span class='color_orange'>update:46</span>, v:2 <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16; t|->{next:_t$758 <span class='color_orange'>update:56</span>, v:_t$759 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16; lsegne(n$505,n$503,[],P0); lseg(_t$758,null,[],P0)
    [footprint
       @f$1 != 0 *
       #GB<src.c>$head = @f$0 <span class='color_orange'>rearrange:38</span>:node*  ]
    where
    P0 = exists [_t$2]. _t$0|->{next:_t$1 <span class='color_orange'>update:56</span>, v:_t$2 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16</span>
    
    
    prop list after:
    PROP 1 of 1:
    <span class='color_blue'><span class='color_blue'>n$503 != 0</span>; <span class='color_blue'>t != 0</span>; <span class='color_blue'>MEMma &lt; malloc:38 &gt;  <span class='color_orange'>{vpath: }</span>(n$505)</span>; <span class='color_blue'>MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(x)</span> ;
    <span class='color_blue'>x = n$502 <span class='color_orange'>update:45</span>:node*</span>; <span class='color_blue'>n = null <span class='color_orange'>update:40</span>:node*</span>; <span class='color_blue'>t = n$17 <span class='color_orange'>update:53</span>:node*</span>; <span class='color_blue'>#GB<src.c>$head = n$505 <span class='color_orange'>update:38</span>:node*</span>; <span class='color_blue'>i = 2 <span class='color_orange'>update:43</span>:int</span>; <span class='color_blue'>return = n$506 <span class='color_orange'>initial</span>:int</span> ;
    <span class='color_blue'>n$503|->{next:t <span class='color_orange'>update:56</span>, v:n$504 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16</span>; <span class='color_blue'>x|->{next:null <span class='color_orange'>update:46</span>, v:2 <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16</span>; <span class='color_blue'>t|->{next:_t$758 <span class='color_orange'>update:56</span>, v:_t$759 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16</span>; <span class='color_blue'>lsegne(n$505,n$503,[],P0)</span>; <span class='color_blue'>lseg(_t$758,null,[],P0)</span>
    [footprint
       <span class='color_blue'>@f$1 != 0</span> *
       <span class='color_blue'>#GB<src.c>$head = @f$0 <span class='color_orange'>rearrange:38</span>:node*</span>  ]
    where
    P0 = exists [_t$2]. <span class='color_blue'>_t$0|->{next:_t$1 <span class='color_orange'>update:56</span>, v:_t$2 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16</span></span>
    
    
    
    Instruction Returns
    PROP 1 of 1:
    <span class='color_blue'><span class='color_blue'>_t$2 != 0</span>; <span class='color_blue'>t != 0</span>; <span class='color_red'>MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(x)</span>; <span class='color_blue'>MEMma &lt; malloc:38 &gt;  <span class='color_orange'>{vpath: }</span>(_t$1)</span>; <span class='color_red'>DANGL &lt; UNINIT &gt; (n$18)</span> ;
    <span class='color_blue'>x = <span class='color_red'>_t$5 <span class='color_orange'>update:45</span></span>:node*</span>; <span class='color_blue'>n = null <span class='color_orange'>update:40</span>:node*</span>; <span class='color_blue'>t = n$17 <span class='color_orange'>update:53</span>:node*</span>; <span class='color_blue'>#GB<src.c>$head = _t$1 <span class='color_orange'>update:38</span>:node*</span>; <span class='color_blue'>i = 2 <span class='color_orange'>update:43</span>:int</span>; <span class='color_blue'>return = _t$0 <span class='color_orange'>initial</span>:int</span> ;
    <span class='color_red'>x|->{next:null <span class='color_orange'>update:46</span>, v:2 <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16</span>; <span class='color_blue'>_t$2|->{next:t <span class='color_orange'>update:56</span>, v:_t$3 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16</span>; <span class='color_blue'>t|->{next:_t$4 <span class='color_orange'>update:56</span>, v:n$18 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16</span>; <span class='color_blue'>lsegne(_t$1,_t$2,[],P0)</span>; <span class='color_blue'>lseg(_t$4,null,[],P0)</span>
    [footprint
       <span class='color_blue'>@f$1 != 0</span> *
       <span class='color_blue'>#GB<src.c>$head = @f$0 <span class='color_orange'>rearrange:38</span>:node*</span>  ]
    where
    P0 = exists [_t$2]. <span class='color_blue'>_t$0|->{next:_t$1 <span class='color_orange'>update:56</span>, v:_t$2 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16</span></span>
    
    Instruction <span class='color_green'>n$19=_fun_printf("%d\n":char const *,n$18:int) [line 54, column 7]</span>
    in vpath_find exp:n$511
    vpath_find: found head : node*
    in vpath_find exp:n$507
    vpath_find: found x : node*
    <span class='color_orange'>WARNING: likely use of variable-arguments function, or function prototype missing</span>
    actual parameters: n$18
    formal parameters: 
    Found 1 specs for function printf
    START EXECUTING SPECS FOR printf from state
    <span class='color_blue'>n$508 != 0; t != 0; MEMma &lt; malloc:38 &gt;  <span class='color_orange'>{vpath: }</span>(n$511); MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(x); DANGL &lt; UNINIT &gt; (n$18) ;
    x = n$507 <span class='color_orange'>update:45</span>:node*; n = null <span class='color_orange'>update:40</span>:node*; t = n$17 <span class='color_orange'>update:53</span>:node*; #GB<src.c>$head = n$511 <span class='color_orange'>update:38</span>:node*; i = 2 <span class='color_orange'>update:43</span>:int; return = n$512 <span class='color_orange'>initial</span>:int ;
    n$508|->{next:t <span class='color_orange'>update:56</span>, v:n$509 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16; x|->{next:null <span class='color_orange'>update:46</span>, v:2 <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16; t|->{next:n$510 <span class='color_orange'>update:56</span>, v:n$18 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16; lsegne(n$511,n$508,[],P0); lseg(n$510,null,[],P0)
    [footprint
       @f$1 != 0 *
       #GB<src.c>$head = @f$0 <span class='color_orange'>rearrange:38</span>:node*  ]
    where
    P0 = exists [_t$2]. _t$0|->{next:_t$1 <span class='color_orange'>update:56</span>, v:_t$2 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16</span>
    <span class='color_orange'>WARNING: more actual pars than formal pars in fun call (2 vs 1)</span>
    EXECUTING SPEC 1/1
    ACTUAL PRECONDITION =
      <span class='color_blue'>n$508 != 0; t != 0; MEMma &lt; malloc:38 &gt;  <span class='color_orange'>{vpath: }</span>(n$511); MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(x); DANGL &lt; UNINIT &gt; (n$18) ;
      x = n$507 <span class='color_orange'>update:45</span>:node*; n = null <span class='color_orange'>update:40</span>:node*; t = n$17 <span class='color_orange'>update:53</span>:node*; #GB<src.c>$head = n$511 <span class='color_orange'>update:38</span>:node*; i = 2 <span class='color_orange'>update:43</span>:int; format|callee = "%d\n" <span class='color_orange'>actual_precondition</span>:char const *; return = n$512 <span class='color_orange'>initial</span>:int ;
      n$508|->{next:t <span class='color_orange'>update:56</span>, v:n$509 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16; x|->{next:null <span class='color_orange'>update:46</span>, v:2 <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16; t|->{next:n$510 <span class='color_orange'>update:56</span>, v:n$18 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16; lsegne(n$511,n$508,[],P0); lseg(n$510,null,[],P0)
      [footprint
         @f$1 != 0 *
         #GB<src.c>$head = @f$0 <span class='color_orange'>rearrange:38</span>:node*  ]
      where
      P0 = exists [_t$2]. _t$0|->{next:_t$1 <span class='color_orange'>update:56</span>, v:_t$2 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16</span>
    SPEC =
      --------------------------- ---------- ---------------------------
      PRE:
      <span class='color_blue'><span class='color_blue'>format|callee = _t$766 <span class='color_orange'>formal</span>:char const *</span></span>
      POST 1 of 1:
      <span class='color_blue'><span class='color_red'>(-1  &lt;  _t$767)</span>; <span class='color_red'>DANGL &lt; UNINIT &gt; (return|callee)</span> ;
      <span class='color_red'>return|callee = _t$767 <span class='color_orange'>update:1114</span>:int</span></span>
      ----------------------------------------------------------------
    pre_check_pure_implication
    pi1:
      n$508 != 0; n$17 != 0; MEMma &lt; malloc:38 &gt;  <span class='color_orange'>{vpath: }</span>(n$511); MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(n$507); DANGL &lt; UNINIT &gt; (n$18)
    pi2:
      
    returns
    sub1: 
      
    sub2: 
      
    Current Implication
    SUB:
      
    <span class='color_blue'>n$508 != 0; t != 0; MEMma &lt; malloc:38 &gt;  <span class='color_orange'>{vpath: }</span>(n$511); MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(x); DANGL &lt; UNINIT &gt; (n$18) ;
    x = n$507 <span class='color_orange'>update:45</span>:node*; n = null <span class='color_orange'>update:40</span>:node*; t = n$17 <span class='color_orange'>update:53</span>:node*; #GB<src.c>$head = n$511 <span class='color_orange'>update:38</span>:node*; i = 2 <span class='color_orange'>update:43</span>:int; format|callee = "%d\n" <span class='color_orange'>actual_precondition</span>:char const *; return = n$512 <span class='color_orange'>initial</span>:int ;
    n$508|->{next:t <span class='color_orange'>update:56</span>, v:n$509 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16; x|->{next:null <span class='color_orange'>update:46</span>, v:2 <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16; t|->{next:n$510 <span class='color_orange'>update:56</span>, v:n$18 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16; lsegne(n$511,n$508,[],P0); lseg(n$510,null,[],P0)
    [footprint
       @f$1 != 0 *
       #GB<src.c>$head = @f$0 <span class='color_orange'>rearrange:38</span>:node*  ]
    where
    P0 = exists [_t$2]. _t$0|->{next:_t$1 <span class='color_orange'>update:56</span>, v:_t$2 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16</span>
    |-
    <span class='color_blue'>format|callee = _t$766 <span class='color_orange'>formal</span>:char const *</span>
    
      do_imply "%d\n" _t$766
        Final Implication
        SUB:
          
        <span class='color_blue'>n$508 != 0; t != 0; MEMma &lt; malloc:38 &gt;  <span class='color_orange'>{vpath: }</span>(n$511); MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(x); DANGL &lt; UNINIT &gt; (n$18) ;
        x = n$507 <span class='color_orange'>update:45</span>:node*; n = null <span class='color_orange'>update:40</span>:node*; t = n$17 <span class='color_orange'>update:53</span>:node*; #GB<src.c>$head = n$511 <span class='color_orange'>update:38</span>:node*; i = 2 <span class='color_orange'>update:43</span>:int; return = n$512 <span class='color_orange'>initial</span>:int ;
        n$508|->{next:t <span class='color_orange'>update:56</span>, v:n$509 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16; x|->{next:null <span class='color_orange'>update:46</span>, v:2 <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16; t|->{next:n$510 <span class='color_orange'>update:56</span>, v:n$18 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16; lsegne(n$511,n$508,[],P0); lseg(n$510,null,[],P0)
        [footprint
           @f$1 != 0 *
           #GB<src.c>$head = @f$0 <span class='color_orange'>rearrange:38</span>:node*  ]
        where
        P0 = exists [_t$2]. _t$0|->{next:_t$1 <span class='color_orange'>update:56</span>, v:_t$2 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16</span>
        [SUB: 
          _t$766 = "%d\n"]
        |-
        <span class='color_blue'></span>
    Result of Abduction
      SUB:
        
      <span class='color_blue'>n$508 != 0; t != 0; MEMma &lt; malloc:38 &gt;  <span class='color_orange'>{vpath: }</span>(n$511); MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(x); DANGL &lt; UNINIT &gt; (n$18) ;
      x = n$507 <span class='color_orange'>update:45</span>:node*; n = null <span class='color_orange'>update:40</span>:node*; t = n$17 <span class='color_orange'>update:53</span>:node*; #GB<src.c>$head = n$511 <span class='color_orange'>update:38</span>:node*; i = 2 <span class='color_orange'>update:43</span>:int; format|callee = "%d\n" <span class='color_orange'>actual_precondition</span>:char const *; return = n$512 <span class='color_orange'>initial</span>:int ;
      n$508|->{next:t <span class='color_orange'>update:56</span>, v:n$509 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16; x|->{next:null <span class='color_orange'>update:46</span>, v:2 <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16; t|->{next:n$510 <span class='color_orange'>update:56</span>, v:n$18 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16; lsegne(n$511,n$508,[],P0); lseg(n$510,null,[],P0)
      [footprint
         @f$1 != 0 *
         #GB<src.c>$head = @f$0 <span class='color_orange'>rearrange:38</span>:node*  ]
      where
      P0 = exists [_t$2]. _t$0|->{next:_t$1 <span class='color_orange'>update:56</span>, v:_t$2 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16</span>
      [SUB: 
        _t$766 = "%d\n"]
      |-
      <span class='color_blue'>format|callee = "%d\n" <span class='color_orange'>formal</span>:char const *</span>
    returning TRUE
      New footprint:
      
      Frame fld:
      
      Missing fld:
      
      Instantiated frame:
      n$508|->{next:n$17 <span class='color_orange'>update:56</span>, v:n$509 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16; n$507|->{next:null <span class='color_orange'>update:46</span>, v:2 <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16; n$17|->{next:n$510 <span class='color_orange'>update:56</span>, v:n$18 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16; &amp;x|->n$507 <span class='color_orange'>update:45</span>:node*; &amp;n|->null <span class='color_orange'>update:40</span>:node*; &amp;t|->n$17 <span class='color_orange'>update:53</span>:node*; &amp;#GB<src.c>$head|->n$511 <span class='color_orange'>update:38</span>:node*; &amp;i|->2 <span class='color_orange'>update:43</span>:int; &amp;return|->n$512 <span class='color_orange'>initial</span>:int; lsegne(n$511,n$508,[],lam [_t$0,_t$1,]. exists [_t$2]. _t$0|->{next:_t$1 <span class='color_orange'>update:56</span>, v:_t$2 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16); lseg(n$510,null,[],lam [_t$0,_t$1,]. exists [_t$2]. _t$0|->{next:_t$1 <span class='color_orange'>update:56</span>, v:_t$2 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16)
      Instantiated post:
      PROP 1 of 1:
      <span class='color_blue'><span class='color_red'>(-1  &lt;  _t$767)</span>; <span class='color_red'>DANGL &lt; UNINIT &gt; (return|callee)</span> ;
      <span class='color_red'>return|callee = _t$767 <span class='color_orange'>update:54</span>:int</span></span>
      
    ***** RESULTS FUNCTION CALL *******
    PROP 1 of 1:
    <span class='color_blue'><span class='color_red'>(-1  &lt;  n$19)</span>; <span class='color_blue'>n$508 != 0</span>; <span class='color_blue'>t != 0</span>; <span class='color_blue'>MEMma &lt; malloc:38 &gt;  <span class='color_orange'>{vpath: }</span>(n$511)</span>; <span class='color_blue'>MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(x)</span>; <span class='color_red'>DANGL &lt; UNINIT &gt; (n$19)</span>; <span class='color_blue'>DANGL &lt; UNINIT &gt; (n$18)</span> ;
    <span class='color_blue'>x = n$507 <span class='color_orange'>update:45</span>:node*</span>; <span class='color_blue'>n = null <span class='color_orange'>update:40</span>:node*</span>; <span class='color_blue'>t = n$17 <span class='color_orange'>update:53</span>:node*</span>; <span class='color_blue'>#GB<src.c>$head = n$511 <span class='color_orange'>update:38</span>:node*</span>; <span class='color_blue'>i = 2 <span class='color_orange'>update:43</span>:int</span>; <span class='color_blue'>return = n$512 <span class='color_orange'>initial</span>:int</span> ;
    <span class='color_blue'>n$508|->{next:t <span class='color_orange'>update:56</span>, v:n$509 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16</span>; <span class='color_blue'>x|->{next:null <span class='color_orange'>update:46</span>, v:2 <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16</span>; <span class='color_blue'>t|->{next:n$510 <span class='color_orange'>update:56</span>, v:n$18 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16</span>; <span class='color_blue'>lsegne(n$511,n$508,[],P0)</span>; <span class='color_blue'>lseg(n$510,null,[],P0)</span>
    [footprint
       <span class='color_blue'>@f$1 != 0</span> *
       <span class='color_blue'>#GB<src.c>$head = @f$0 <span class='color_orange'>rearrange:38</span>:node*</span>  ]
    where
    P0 = exists [_t$2]. <span class='color_blue'>_t$0|->{next:_t$1 <span class='color_orange'>update:56</span>, v:_t$2 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16</span></span>
    ***** END RESULTS FUNCTION CALL *******
    Instruction Returns
    PROP 1 of 1:
    <span class='color_blue'><span class='color_red'>(-1  &lt;  n$19)</span>; <span class='color_blue'>_t$2 != 0</span>; <span class='color_blue'>t != 0</span>; <span class='color_blue'>MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(x)</span>; <span class='color_blue'>MEMma &lt; malloc:38 &gt;  <span class='color_orange'>{vpath: }</span>(_t$1)</span>; <span class='color_red'>DANGL &lt; UNINIT &gt; (n$19)</span>; <span class='color_blue'>DANGL &lt; UNINIT &gt; (n$18)</span> ;
    <span class='color_blue'>x = _t$5 <span class='color_orange'>update:45</span>:node*</span>; <span class='color_blue'>n = null <span class='color_orange'>update:40</span>:node*</span>; <span class='color_blue'>t = n$17 <span class='color_orange'>update:53</span>:node*</span>; <span class='color_blue'>#GB<src.c>$head = _t$1 <span class='color_orange'>update:38</span>:node*</span>; <span class='color_blue'>i = 2 <span class='color_orange'>update:43</span>:int</span>; <span class='color_blue'>return = _t$0 <span class='color_orange'>initial</span>:int</span> ;
    <span class='color_blue'>x|->{next:null <span class='color_orange'>update:46</span>, v:2 <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16</span>; <span class='color_blue'>_t$2|->{next:t <span class='color_orange'>update:56</span>, v:_t$3 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16</span>; <span class='color_blue'>t|->{next:_t$4 <span class='color_orange'>update:56</span>, v:n$18 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16</span>; <span class='color_blue'>lsegne(_t$1,_t$2,[],P0)</span>; <span class='color_blue'>lseg(_t$4,null,[],P0)</span>
    [footprint
       <span class='color_blue'>@f$1 != 0</span> *
       <span class='color_blue'>#GB<src.c>$head = @f$0 <span class='color_orange'>rearrange:38</span>:node*</span>  ]
    where
    P0 = exists [_t$2]. <span class='color_blue'>_t$0|->{next:_t$1 <span class='color_orange'>update:56</span>, v:_t$2 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16</span></span>
    
    Instruction <span class='color_green'>REMOVE_TEMPS(n$17,n$18,n$19); [line 54, column 7]</span>
    in vpath_find exp:_t$5
    vpath_find: found x : node*
    in vpath_find exp:_t$1
    vpath_find: found head : node*
    Instruction Returns
    PROP 1 of 1:
    <span class='color_blue'><span class='color_red'>(-1  &lt;  _t$8)</span>; <span class='color_red'>t != 0</span>; <span class='color_blue'>_t$2 != 0</span>; <span class='color_red'>MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(x)</span>; <span class='color_blue'>MEMma &lt; malloc:38 &gt;  <span class='color_orange'>{vpath: }</span>(_t$1)</span>; <span class='color_red'>DANGL &lt; UNINIT &gt; (_t$8)</span>; <span class='color_red'>DANGL &lt; UNINIT &gt; (_t$6)</span> ;
    <span class='color_blue'>x = <span class='color_red'>_t$7 <span class='color_orange'>update:45</span></span>:node*</span>; <span class='color_blue'>n = null <span class='color_orange'>update:40</span>:node*</span>; <span class='color_blue'>t = <span class='color_red'>_t$3 <span class='color_orange'>update:53</span></span>:node*</span>; <span class='color_blue'>#GB<src.c>$head = _t$1 <span class='color_orange'>update:38</span>:node*</span>; <span class='color_blue'>i = 2 <span class='color_orange'>update:43</span>:int</span>; <span class='color_blue'>return = _t$0 <span class='color_orange'>initial</span>:int</span> ;
    <span class='color_red'>x|->{next:null <span class='color_orange'>update:46</span>, v:2 <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16</span>; <span class='color_red'>t|->{next:_t$5 <span class='color_orange'>update:56</span>, v:_t$6 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16</span>; <span class='color_blue'>_t$2|->{next:<span class='color_red'>t <span class='color_orange'>update:56</span></span>, v:<span class='color_red'>_t$4 <span class='color_orange'>alloc</span></span>} <span class='color_orange'>alloc</span>:node16</span>; <span class='color_blue'>lsegne(_t$1,_t$2,[],P0)</span>; <span class='color_blue'>lseg(_t$5,null,[],P0)</span>
    [footprint
       <span class='color_blue'>@f$1 != 0</span> *
       <span class='color_blue'>#GB<src.c>$head = @f$0 <span class='color_orange'>rearrange:38</span>:node*</span>  ]
    where
    P0 = exists [_t$2]. <span class='color_blue'>_t$0|->{next:_t$1 <span class='color_orange'>update:56</span>, v:_t$2 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16</span></span>
    
    Instruction <span class='color_green'>APPLY_ABSTRACTION; [line 54, column 7]</span>
    in vpath_find exp:_t$7
    vpath_find: found x : node*
    in vpath_find exp:_t$1
    vpath_find: found head : node*
    <span class='color_blue'>t != 0; MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(x); MEMma &lt; malloc:38 &gt;  <span class='color_orange'>{vpath: }</span>(_t$1) ;
    x = _t$3 <span class='color_orange'>update:45</span>:node*; n = null <span class='color_orange'>update:40</span>:node*; t = _t$2 <span class='color_orange'>update:53</span>:node*; #GB<src.c>$head = _t$1 <span class='color_orange'>update:38</span>:node*; i = 2 <span class='color_orange'>update:43</span>:int; return = _t$0 <span class='color_orange'>initial</span>:int ;
    x|->{next:null <span class='color_orange'>update:46</span>, v:2 <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16; lsegne(t,null,[],P0); lsegne(_t$1,t,[],P0)
    [footprint
       #GB<src.c>$head = @f$0 <span class='color_orange'>rearrange:38</span>:node*  ]
    where
    P0 = exists [_t$2]. _t$0|->{next:_t$1 <span class='color_orange'>update:56</span>, v:_t$2 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16</span>
    Instruction Returns
    PROP 1 of 1:
    <span class='color_blue'><span class='color_blue'>t != 0</span>; <span class='color_blue'>MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(x)</span>; <span class='color_blue'>MEMma &lt; malloc:38 &gt;  <span class='color_orange'>{vpath: }</span>(_t$1)</span> ;
    <span class='color_blue'>x = <span class='color_red'>_t$3 <span class='color_orange'>update:45</span></span>:node*</span>; <span class='color_blue'>n = null <span class='color_orange'>update:40</span>:node*</span>; <span class='color_blue'>t = <span class='color_red'>_t$2 <span class='color_orange'>update:53</span></span>:node*</span>; <span class='color_blue'>#GB<src.c>$head = _t$1 <span class='color_orange'>update:38</span>:node*</span>; <span class='color_blue'>i = 2 <span class='color_orange'>update:43</span>:int</span>; <span class='color_blue'>return = _t$0 <span class='color_orange'>initial</span>:int</span> ;
    <span class='color_blue'>x|->{next:<span class='color_red'>null <span class='color_orange'>update:46</span></span>, v:<span class='color_red'>2 <span class='color_orange'>update:47</span></span>} <span class='color_orange'>alloc</span>:node16</span>; <span class='color_blue'>lsegne(t,null,[],P0)</span>; <span class='color_blue'>lsegne(_t$1,t,[],P0)</span>
    [footprint
       <span class='color_blue'>#GB<src.c>$head = @f$0 <span class='color_orange'>rearrange:38</span>:node*</span>  ]
    where
    P0 = exists [_t$2]. <span class='color_blue'>_t$0|->{next:_t$1 <span class='color_orange'>update:56</span>, v:_t$2 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16</span></span>
    
    .... After Symbolic Execution ....
    PROP 1 of 1:
    <span class='color_blue'><span class='color_blue'>t != 0</span>; <span class='color_blue'>MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(x)</span>; <span class='color_blue'>MEMma &lt; malloc:38 &gt;  <span class='color_orange'>{vpath: }</span>(_t$1)</span> ;
    <span class='color_blue'>x = <span class='color_red'>_t$3 <span class='color_orange'>update:45</span></span>:node*</span>; <span class='color_blue'>n = null <span class='color_orange'>update:40</span>:node*</span>; <span class='color_blue'>t = <span class='color_red'>_t$2 <span class='color_orange'>update:53</span></span>:node*</span>; <span class='color_blue'>#GB<src.c>$head = _t$1 <span class='color_orange'>update:38</span>:node*</span>; <span class='color_blue'>i = 2 <span class='color_orange'>update:43</span>:int</span>; <span class='color_blue'>return = _t$0 <span class='color_orange'>initial</span>:int</span> ;
    <span class='color_blue'>x|->{next:null <span class='color_orange'>update:46</span>, v:2 <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16</span>; <span class='color_blue'>lsegne(t,null,[],P0)</span>; <span class='color_blue'>lsegne(_t$1,t,[],P0)</span>
    [footprint
       <span class='color_blue'>#GB<src.c>$head = @f$0 <span class='color_orange'>rearrange:38</span>:node*</span>  ]
    where
    P0 = exists [_t$2]. <span class='color_blue'>_t$0|->{next:_t$1 <span class='color_orange'>update:56</span>, v:_t$2 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16</span></span>
    
    
    
  </LISTING></span><hr width="100%">
<a name="session314" href="./../nodes/main.fad58de7366495db4650cfefac2fcd61_node25.html#session314">node25#session314</a>(<a href="./../../src.c.b9996786c0d0c7ca7785f2f6d38e80de.html#LINE54">54</a>) interproc<LISTING><span class='color_black'>**** [FP:Pending] main Node: 25, Procedure: main, Session: 314, Todo: 1 ****
  PROP 1 of 1:
  <span class='color_blue'><span class='color_red'>t != 0</span>; <span class='color_red'>MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(x)</span>; <span class='color_red'>MEMma &lt; malloc:38 &gt;  <span class='color_orange'>{vpath: }</span>(_t$1)</span> ;
  <span class='color_red'>x = _t$4 <span class='color_orange'>update:45</span>:node*</span>; <span class='color_red'>n = null <span class='color_orange'>update:40</span>:node*</span>; <span class='color_red'>t = _t$2 <span class='color_orange'>update:53</span>:node*</span>; <span class='color_red'>#GB<src.c>$head = _t$1 <span class='color_orange'>update:38</span>:node*</span>; <span class='color_red'>i = @f$0 <span class='color_orange'>update:43</span>:int</span>; <span class='color_red'>return = _t$0 <span class='color_orange'>initial</span>:int</span> ;
  <span class='color_red'>x|->{next:null <span class='color_orange'>update:46</span>, v:i <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16</span>; <span class='color_red'>_t$1|->{next:t <span class='color_orange'>update:56</span>, v:_t$3 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16</span>; <span class='color_red'>lsegne(t,null,[],P0)</span>
  [footprint
     <span class='color_red'>@f$2 != 0</span> *
     <span class='color_red'>#GB<src.c>$head = @f$1 <span class='color_orange'>rearrange:38</span>:node*</span>  ]
  where
  P0 = exists [_t$2]. <span class='color_blue'>_t$0|->{next:_t$1 <span class='color_orange'>update:56</span>, v:_t$2 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16</span></span>
  .... Instructions: .... 
  <span class='color_green'>n$17=*&amp;t:node* [line 54, column 21];
  n$18=*n$17.v:int [line 54, column 21];
  n$19=_fun_printf("%d\n":char const *,n$18:int) [line 54, column 7];
  REMOVE_TEMPS(n$17,n$18,n$19); [line 54, column 7];
  APPLY_ABSTRACTION; [line 54, column 7];
  </span>
  
  Processing prop 1/1
    Instruction <span class='color_green'>n$17=*&amp;t:node* [line 54, column 21]</span>
    in vpath_find exp:n$705
    vpath_find: found head : node*
    in vpath_find exp:n$704
    vpath_find: found x : node*
    .... Rearrangement Start ....
    Exp: &amp;t
    Prop: 
    <span class='color_blue'>t != 0; MEMma &lt; malloc:38 &gt;  <span class='color_orange'>{vpath: }</span>(n$705); MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(x) ;
    x = n$704 <span class='color_orange'>update:45</span>:node*; n = null <span class='color_orange'>update:40</span>:node*; t = n$706 <span class='color_orange'>update:53</span>:node*; #GB<src.c>$head = n$705 <span class='color_orange'>update:38</span>:node*; i = @f$0 <span class='color_orange'>update:43</span>:int; return = n$708 <span class='color_orange'>initial</span>:int ;
    n$705|->{next:t <span class='color_orange'>update:56</span>, v:n$707 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16; x|->{next:null <span class='color_orange'>update:46</span>, v:i <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16; lsegne(t,null,[],P0)
    [footprint
       @f$2 != 0 *
       #GB<src.c>$head = @f$1 <span class='color_orange'>rearrange:38</span>:node*  ]
    where
    P0 = exists [_t$2]. _t$0|->{next:_t$1 <span class='color_orange'>update:56</span>, v:_t$2 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16</span>
    
    in prop_iter_extend_ptsto lexp: &amp;t
    prop before:
    <span class='color_blue'>t != 0; MEMma &lt; malloc:38 &gt;  <span class='color_orange'>{vpath: }</span>(n$705); MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(x) ;
    x = n$704 <span class='color_orange'>update:45</span>:node*; n = null <span class='color_orange'>update:40</span>:node*; t = n$706 <span class='color_orange'>update:53</span>:node*; #GB<src.c>$head = n$705 <span class='color_orange'>update:38</span>:node*; i = @f$0 <span class='color_orange'>update:43</span>:int; return = n$708 <span class='color_orange'>initial</span>:int ;
    n$705|->{next:t <span class='color_orange'>update:56</span>, v:n$707 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16; x|->{next:null <span class='color_orange'>update:46</span>, v:i <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16; lsegne(t,null,[],P0)
    [footprint
       @f$2 != 0 *
       #GB<src.c>$head = @f$1 <span class='color_orange'>rearrange:38</span>:node*  ]
    where
    P0 = exists [_t$2]. _t$0|->{next:_t$1 <span class='color_orange'>update:56</span>, v:_t$2 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16</span>
    
    
    prop list after:
    PROP 1 of 1:
    <span class='color_blue'><span class='color_blue'>t != 0</span>; <span class='color_blue'>MEMma &lt; malloc:38 &gt;  <span class='color_orange'>{vpath: }</span>(n$705)</span>; <span class='color_blue'>MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(x)</span> ;
    <span class='color_blue'>x = n$704 <span class='color_orange'>update:45</span>:node*</span>; <span class='color_blue'>n = null <span class='color_orange'>update:40</span>:node*</span>; <span class='color_blue'>t = n$706 <span class='color_orange'>update:53</span>:node*</span>; <span class='color_blue'>#GB<src.c>$head = n$705 <span class='color_orange'>update:38</span>:node*</span>; <span class='color_blue'>i = @f$0 <span class='color_orange'>update:43</span>:int</span>; <span class='color_blue'>return = n$708 <span class='color_orange'>initial</span>:int</span> ;
    <span class='color_blue'>n$705|->{next:t <span class='color_orange'>update:56</span>, v:n$707 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16</span>; <span class='color_blue'>x|->{next:null <span class='color_orange'>update:46</span>, v:i <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16</span>; <span class='color_blue'>lsegne(t,null,[],P0)</span>
    [footprint
       <span class='color_blue'>@f$2 != 0</span> *
       <span class='color_blue'>#GB<src.c>$head = @f$1 <span class='color_orange'>rearrange:38</span>:node*</span>  ]
    where
    P0 = exists [_t$2]. <span class='color_blue'>_t$0|->{next:_t$1 <span class='color_orange'>update:56</span>, v:_t$2 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16</span></span>
    
    
    
    Instruction Returns
    PROP 1 of 1:
    <span class='color_blue'><span class='color_red'>t != 0</span>; <span class='color_red'>MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(x)</span>; <span class='color_blue'>MEMma &lt; malloc:38 &gt;  <span class='color_orange'>{vpath: }</span>(_t$1)</span> ;
    <span class='color_blue'>x = <span class='color_red'>_t$3 <span class='color_orange'>update:45</span></span>:node*</span>; <span class='color_blue'>n = null <span class='color_orange'>update:40</span>:node*</span>; <span class='color_blue'>t = <span class='color_red'>n$17 <span class='color_orange'>update:53</span></span>:node*</span>; <span class='color_blue'>#GB<src.c>$head = _t$1 <span class='color_orange'>update:38</span>:node*</span>; <span class='color_blue'>i = @f$0 <span class='color_orange'>update:43</span>:int</span>; <span class='color_blue'>return = _t$0 <span class='color_orange'>initial</span>:int</span> ;
    <span class='color_red'>x|->{next:null <span class='color_orange'>update:46</span>, v:i <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16</span>; <span class='color_blue'>_t$1|->{next:<span class='color_red'>t <span class='color_orange'>update:56</span></span>, v:<span class='color_red'>_t$2 <span class='color_orange'>alloc</span></span>} <span class='color_orange'>alloc</span>:node16</span>; <span class='color_red'>lsegne(t,null,[],P0)</span>
    [footprint
       <span class='color_blue'>@f$2 != 0</span> *
       <span class='color_blue'>#GB<src.c>$head = @f$1 <span class='color_orange'>rearrange:38</span>:node*</span>  ]
    where
    P0 = exists [_t$2]. <span class='color_blue'>_t$0|->{next:_t$1 <span class='color_orange'>update:56</span>, v:_t$2 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16</span></span>
    
    Instruction <span class='color_green'>n$18=*n$17.v:int [line 54, column 21]</span>
    in vpath_find exp:n$710
    vpath_find: found head : node*
    in vpath_find exp:n$709
    vpath_find: found x : node*
    .... Rearrangement Start ....
    Exp: n$17.v
    Prop: 
    <span class='color_blue'>t != 0; MEMma &lt; malloc:38 &gt;  <span class='color_orange'>{vpath: }</span>(n$710); MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(x) ;
    x = n$709 <span class='color_orange'>update:45</span>:node*; n = null <span class='color_orange'>update:40</span>:node*; t = n$17 <span class='color_orange'>update:53</span>:node*; #GB<src.c>$head = n$710 <span class='color_orange'>update:38</span>:node*; i = @f$0 <span class='color_orange'>update:43</span>:int; return = n$712 <span class='color_orange'>initial</span>:int ;
    n$710|->{next:t <span class='color_orange'>update:56</span>, v:n$711 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16; x|->{next:null <span class='color_orange'>update:46</span>, v:i <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16; lsegne(t,null,[],P0)
    [footprint
       @f$2 != 0 *
       #GB<src.c>$head = @f$1 <span class='color_orange'>rearrange:38</span>:node*  ]
    where
    P0 = exists [_t$2]. _t$0|->{next:_t$1 <span class='color_orange'>update:56</span>, v:_t$2 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16</span>
    
    in prop_iter_extend_ptsto lexp: n$17.v
    prop before:
    <span class='color_blue'>t != 0; MEMma &lt; malloc:38 &gt;  <span class='color_orange'>{vpath: }</span>(n$710); MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(x) ;
    x = n$709 <span class='color_orange'>update:45</span>:node*; n = null <span class='color_orange'>update:40</span>:node*; t = n$17 <span class='color_orange'>update:53</span>:node*; #GB<src.c>$head = n$710 <span class='color_orange'>update:38</span>:node*; i = @f$0 <span class='color_orange'>update:43</span>:int; return = n$712 <span class='color_orange'>initial</span>:int ;
    n$710|->{next:t <span class='color_orange'>update:56</span>, v:n$711 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16; x|->{next:null <span class='color_orange'>update:46</span>, v:i <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16; t|->{next:_t$1126 <span class='color_orange'>update:56</span>, v:_t$1127 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16; lseg(_t$1126,null,[],P0)
    [footprint
       @f$2 != 0 *
       #GB<src.c>$head = @f$1 <span class='color_orange'>rearrange:38</span>:node*  ]
    where
    P0 = exists [_t$2]. _t$0|->{next:_t$1 <span class='color_orange'>update:56</span>, v:_t$2 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16</span>
    
    
    prop list after:
    PROP 1 of 1:
    <span class='color_blue'><span class='color_blue'>t != 0</span>; <span class='color_blue'>MEMma &lt; malloc:38 &gt;  <span class='color_orange'>{vpath: }</span>(n$710)</span>; <span class='color_blue'>MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(x)</span> ;
    <span class='color_blue'>x = n$709 <span class='color_orange'>update:45</span>:node*</span>; <span class='color_blue'>n = null <span class='color_orange'>update:40</span>:node*</span>; <span class='color_blue'>t = n$17 <span class='color_orange'>update:53</span>:node*</span>; <span class='color_blue'>#GB<src.c>$head = n$710 <span class='color_orange'>update:38</span>:node*</span>; <span class='color_blue'>i = @f$0 <span class='color_orange'>update:43</span>:int</span>; <span class='color_blue'>return = n$712 <span class='color_orange'>initial</span>:int</span> ;
    <span class='color_blue'>n$710|->{next:t <span class='color_orange'>update:56</span>, v:n$711 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16</span>; <span class='color_blue'>x|->{next:null <span class='color_orange'>update:46</span>, v:i <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16</span>; <span class='color_blue'>t|->{next:_t$1126 <span class='color_orange'>update:56</span>, v:_t$1127 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16</span>; <span class='color_blue'>lseg(_t$1126,null,[],P0)</span>
    [footprint
       <span class='color_blue'>@f$2 != 0</span> *
       <span class='color_blue'>#GB<src.c>$head = @f$1 <span class='color_orange'>rearrange:38</span>:node*</span>  ]
    where
    P0 = exists [_t$2]. <span class='color_blue'>_t$0|->{next:_t$1 <span class='color_orange'>update:56</span>, v:_t$2 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16</span></span>
    
    
    
    Instruction Returns
    PROP 1 of 1:
    <span class='color_blue'><span class='color_blue'>t != 0</span>; <span class='color_red'>MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(x)</span>; <span class='color_blue'>MEMma &lt; malloc:38 &gt;  <span class='color_orange'>{vpath: }</span>(_t$1)</span>; <span class='color_red'>DANGL &lt; UNINIT &gt; (n$18)</span> ;
    <span class='color_blue'>x = <span class='color_red'>_t$4 <span class='color_orange'>update:45</span></span>:node*</span>; <span class='color_blue'>n = null <span class='color_orange'>update:40</span>:node*</span>; <span class='color_blue'>t = n$17 <span class='color_orange'>update:53</span>:node*</span>; <span class='color_blue'>#GB<src.c>$head = _t$1 <span class='color_orange'>update:38</span>:node*</span>; <span class='color_blue'>i = @f$0 <span class='color_orange'>update:43</span>:int</span>; <span class='color_blue'>return = _t$0 <span class='color_orange'>initial</span>:int</span> ;
    <span class='color_red'>x|->{next:null <span class='color_orange'>update:46</span>, v:i <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16</span>; <span class='color_blue'>_t$1|->{next:t <span class='color_orange'>update:56</span>, v:_t$2 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16</span>; <span class='color_blue'>t|->{next:_t$3 <span class='color_orange'>update:56</span>, v:n$18 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16</span>; <span class='color_blue'>lseg(_t$3,null,[],P0)</span>
    [footprint
       <span class='color_blue'>@f$2 != 0</span> *
       <span class='color_blue'>#GB<src.c>$head = @f$1 <span class='color_orange'>rearrange:38</span>:node*</span>  ]
    where
    P0 = exists [_t$2]. <span class='color_blue'>_t$0|->{next:_t$1 <span class='color_orange'>update:56</span>, v:_t$2 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16</span></span>
    
    Instruction <span class='color_green'>n$19=_fun_printf("%d\n":char const *,n$18:int) [line 54, column 7]</span>
    in vpath_find exp:n$714
    vpath_find: found head : node*
    in vpath_find exp:n$713
    vpath_find: found x : node*
    <span class='color_orange'>WARNING: likely use of variable-arguments function, or function prototype missing</span>
    actual parameters: n$18
    formal parameters: 
    Found 1 specs for function printf
    START EXECUTING SPECS FOR printf from state
    <span class='color_blue'>t != 0; MEMma &lt; malloc:38 &gt;  <span class='color_orange'>{vpath: }</span>(n$714); MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(x); DANGL &lt; UNINIT &gt; (n$18) ;
    x = n$713 <span class='color_orange'>update:45</span>:node*; n = null <span class='color_orange'>update:40</span>:node*; t = n$17 <span class='color_orange'>update:53</span>:node*; #GB<src.c>$head = n$714 <span class='color_orange'>update:38</span>:node*; i = @f$0 <span class='color_orange'>update:43</span>:int; return = n$717 <span class='color_orange'>initial</span>:int ;
    n$714|->{next:t <span class='color_orange'>update:56</span>, v:n$715 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16; x|->{next:null <span class='color_orange'>update:46</span>, v:i <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16; t|->{next:n$716 <span class='color_orange'>update:56</span>, v:n$18 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16; lseg(n$716,null,[],P0)
    [footprint
       @f$2 != 0 *
       #GB<src.c>$head = @f$1 <span class='color_orange'>rearrange:38</span>:node*  ]
    where
    P0 = exists [_t$2]. _t$0|->{next:_t$1 <span class='color_orange'>update:56</span>, v:_t$2 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16</span>
    <span class='color_orange'>WARNING: more actual pars than formal pars in fun call (2 vs 1)</span>
    EXECUTING SPEC 1/1
    ACTUAL PRECONDITION =
      <span class='color_blue'>t != 0; MEMma &lt; malloc:38 &gt;  <span class='color_orange'>{vpath: }</span>(n$714); MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(x); DANGL &lt; UNINIT &gt; (n$18) ;
      x = n$713 <span class='color_orange'>update:45</span>:node*; n = null <span class='color_orange'>update:40</span>:node*; t = n$17 <span class='color_orange'>update:53</span>:node*; #GB<src.c>$head = n$714 <span class='color_orange'>update:38</span>:node*; i = @f$0 <span class='color_orange'>update:43</span>:int; format|callee = "%d\n" <span class='color_orange'>actual_precondition</span>:char const *; return = n$717 <span class='color_orange'>initial</span>:int ;
      n$714|->{next:t <span class='color_orange'>update:56</span>, v:n$715 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16; x|->{next:null <span class='color_orange'>update:46</span>, v:i <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16; t|->{next:n$716 <span class='color_orange'>update:56</span>, v:n$18 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16; lseg(n$716,null,[],P0)
      [footprint
         @f$2 != 0 *
         #GB<src.c>$head = @f$1 <span class='color_orange'>rearrange:38</span>:node*  ]
      where
      P0 = exists [_t$2]. _t$0|->{next:_t$1 <span class='color_orange'>update:56</span>, v:_t$2 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16</span>
    SPEC =
      --------------------------- ---------- ---------------------------
      PRE:
      <span class='color_blue'><span class='color_blue'>format|callee = _t$1133 <span class='color_orange'>formal</span>:char const *</span></span>
      POST 1 of 1:
      <span class='color_blue'><span class='color_red'>(-1  &lt;  _t$1134)</span>; <span class='color_red'>DANGL &lt; UNINIT &gt; (return|callee)</span> ;
      <span class='color_red'>return|callee = _t$1134 <span class='color_orange'>update:1114</span>:int</span></span>
      ----------------------------------------------------------------
    pre_check_pure_implication
    pi1:
      n$17 != 0; MEMma &lt; malloc:38 &gt;  <span class='color_orange'>{vpath: }</span>(n$714); MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(n$713); DANGL &lt; UNINIT &gt; (n$18)
    pi2:
      
    returns
    sub1: 
      
    sub2: 
      
    Current Implication
    SUB:
      
    <span class='color_blue'>t != 0; MEMma &lt; malloc:38 &gt;  <span class='color_orange'>{vpath: }</span>(n$714); MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(x); DANGL &lt; UNINIT &gt; (n$18) ;
    x = n$713 <span class='color_orange'>update:45</span>:node*; n = null <span class='color_orange'>update:40</span>:node*; t = n$17 <span class='color_orange'>update:53</span>:node*; #GB<src.c>$head = n$714 <span class='color_orange'>update:38</span>:node*; i = @f$0 <span class='color_orange'>update:43</span>:int; format|callee = "%d\n" <span class='color_orange'>actual_precondition</span>:char const *; return = n$717 <span class='color_orange'>initial</span>:int ;
    n$714|->{next:t <span class='color_orange'>update:56</span>, v:n$715 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16; x|->{next:null <span class='color_orange'>update:46</span>, v:i <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16; t|->{next:n$716 <span class='color_orange'>update:56</span>, v:n$18 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16; lseg(n$716,null,[],P0)
    [footprint
       @f$2 != 0 *
       #GB<src.c>$head = @f$1 <span class='color_orange'>rearrange:38</span>:node*  ]
    where
    P0 = exists [_t$2]. _t$0|->{next:_t$1 <span class='color_orange'>update:56</span>, v:_t$2 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16</span>
    |-
    <span class='color_blue'>format|callee = _t$1133 <span class='color_orange'>formal</span>:char const *</span>
    
      do_imply "%d\n" _t$1133
        Final Implication
        SUB:
          
        <span class='color_blue'>t != 0; MEMma &lt; malloc:38 &gt;  <span class='color_orange'>{vpath: }</span>(n$714); MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(x); DANGL &lt; UNINIT &gt; (n$18) ;
        x = n$713 <span class='color_orange'>update:45</span>:node*; n = null <span class='color_orange'>update:40</span>:node*; t = n$17 <span class='color_orange'>update:53</span>:node*; #GB<src.c>$head = n$714 <span class='color_orange'>update:38</span>:node*; i = @f$0 <span class='color_orange'>update:43</span>:int; return = n$717 <span class='color_orange'>initial</span>:int ;
        n$714|->{next:t <span class='color_orange'>update:56</span>, v:n$715 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16; x|->{next:null <span class='color_orange'>update:46</span>, v:i <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16; t|->{next:n$716 <span class='color_orange'>update:56</span>, v:n$18 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16; lseg(n$716,null,[],P0)
        [footprint
           @f$2 != 0 *
           #GB<src.c>$head = @f$1 <span class='color_orange'>rearrange:38</span>:node*  ]
        where
        P0 = exists [_t$2]. _t$0|->{next:_t$1 <span class='color_orange'>update:56</span>, v:_t$2 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16</span>
        [SUB: 
          _t$1133 = "%d\n"]
        |-
        <span class='color_blue'></span>
    Result of Abduction
      SUB:
        
      <span class='color_blue'>t != 0; MEMma &lt; malloc:38 &gt;  <span class='color_orange'>{vpath: }</span>(n$714); MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(x); DANGL &lt; UNINIT &gt; (n$18) ;
      x = n$713 <span class='color_orange'>update:45</span>:node*; n = null <span class='color_orange'>update:40</span>:node*; t = n$17 <span class='color_orange'>update:53</span>:node*; #GB<src.c>$head = n$714 <span class='color_orange'>update:38</span>:node*; i = @f$0 <span class='color_orange'>update:43</span>:int; format|callee = "%d\n" <span class='color_orange'>actual_precondition</span>:char const *; return = n$717 <span class='color_orange'>initial</span>:int ;
      n$714|->{next:t <span class='color_orange'>update:56</span>, v:n$715 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16; x|->{next:null <span class='color_orange'>update:46</span>, v:i <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16; t|->{next:n$716 <span class='color_orange'>update:56</span>, v:n$18 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16; lseg(n$716,null,[],P0)
      [footprint
         @f$2 != 0 *
         #GB<src.c>$head = @f$1 <span class='color_orange'>rearrange:38</span>:node*  ]
      where
      P0 = exists [_t$2]. _t$0|->{next:_t$1 <span class='color_orange'>update:56</span>, v:_t$2 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16</span>
      [SUB: 
        _t$1133 = "%d\n"]
      |-
      <span class='color_blue'>format|callee = "%d\n" <span class='color_orange'>formal</span>:char const *</span>
    returning TRUE
      New footprint:
      
      Frame fld:
      
      Missing fld:
      
      Instantiated frame:
      n$714|->{next:n$17 <span class='color_orange'>update:56</span>, v:n$715 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16; n$713|->{next:null <span class='color_orange'>update:46</span>, v:@f$0 <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16; n$17|->{next:n$716 <span class='color_orange'>update:56</span>, v:n$18 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16; &amp;x|->n$713 <span class='color_orange'>update:45</span>:node*; &amp;n|->null <span class='color_orange'>update:40</span>:node*; &amp;t|->n$17 <span class='color_orange'>update:53</span>:node*; &amp;#GB<src.c>$head|->n$714 <span class='color_orange'>update:38</span>:node*; &amp;i|->@f$0 <span class='color_orange'>update:43</span>:int; &amp;return|->n$717 <span class='color_orange'>initial</span>:int; lseg(n$716,null,[],lam [_t$0,_t$1,]. exists [_t$2]. _t$0|->{next:_t$1 <span class='color_orange'>update:56</span>, v:_t$2 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16)
      Instantiated post:
      PROP 1 of 1:
      <span class='color_blue'><span class='color_red'>(-1  &lt;  _t$1134)</span>; <span class='color_red'>DANGL &lt; UNINIT &gt; (return|callee)</span> ;
      <span class='color_red'>return|callee = _t$1134 <span class='color_orange'>update:54</span>:int</span></span>
      
    ***** RESULTS FUNCTION CALL *******
    PROP 1 of 1:
    <span class='color_blue'><span class='color_red'>(-1  &lt;  n$19)</span>; <span class='color_blue'>t != 0</span>; <span class='color_blue'>MEMma &lt; malloc:38 &gt;  <span class='color_orange'>{vpath: }</span>(n$714)</span>; <span class='color_blue'>MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(x)</span>; <span class='color_red'>DANGL &lt; UNINIT &gt; (n$19)</span>; <span class='color_blue'>DANGL &lt; UNINIT &gt; (n$18)</span> ;
    <span class='color_blue'>x = n$713 <span class='color_orange'>update:45</span>:node*</span>; <span class='color_blue'>n = null <span class='color_orange'>update:40</span>:node*</span>; <span class='color_blue'>t = n$17 <span class='color_orange'>update:53</span>:node*</span>; <span class='color_blue'>#GB<src.c>$head = n$714 <span class='color_orange'>update:38</span>:node*</span>; <span class='color_blue'>i = @f$0 <span class='color_orange'>update:43</span>:int</span>; <span class='color_blue'>return = n$717 <span class='color_orange'>initial</span>:int</span> ;
    <span class='color_blue'>n$714|->{next:t <span class='color_orange'>update:56</span>, v:n$715 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16</span>; <span class='color_blue'>x|->{next:null <span class='color_orange'>update:46</span>, v:i <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16</span>; <span class='color_blue'>t|->{next:n$716 <span class='color_orange'>update:56</span>, v:n$18 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16</span>; <span class='color_blue'>lseg(n$716,null,[],P0)</span>
    [footprint
       <span class='color_blue'>@f$2 != 0</span> *
       <span class='color_blue'>#GB<src.c>$head = @f$1 <span class='color_orange'>rearrange:38</span>:node*</span>  ]
    where
    P0 = exists [_t$2]. <span class='color_blue'>_t$0|->{next:_t$1 <span class='color_orange'>update:56</span>, v:_t$2 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16</span></span>
    ***** END RESULTS FUNCTION CALL *******
    Instruction Returns
    PROP 1 of 1:
    <span class='color_blue'><span class='color_red'>(-1  &lt;  n$19)</span>; <span class='color_blue'>t != 0</span>; <span class='color_blue'>MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(x)</span>; <span class='color_blue'>MEMma &lt; malloc:38 &gt;  <span class='color_orange'>{vpath: }</span>(_t$1)</span>; <span class='color_red'>DANGL &lt; UNINIT &gt; (n$19)</span>; <span class='color_blue'>DANGL &lt; UNINIT &gt; (n$18)</span> ;
    <span class='color_blue'>x = _t$4 <span class='color_orange'>update:45</span>:node*</span>; <span class='color_blue'>n = null <span class='color_orange'>update:40</span>:node*</span>; <span class='color_blue'>t = n$17 <span class='color_orange'>update:53</span>:node*</span>; <span class='color_blue'>#GB<src.c>$head = _t$1 <span class='color_orange'>update:38</span>:node*</span>; <span class='color_blue'>i = @f$0 <span class='color_orange'>update:43</span>:int</span>; <span class='color_blue'>return = _t$0 <span class='color_orange'>initial</span>:int</span> ;
    <span class='color_blue'>x|->{next:null <span class='color_orange'>update:46</span>, v:i <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16</span>; <span class='color_blue'>_t$1|->{next:t <span class='color_orange'>update:56</span>, v:_t$2 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16</span>; <span class='color_blue'>t|->{next:_t$3 <span class='color_orange'>update:56</span>, v:n$18 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16</span>; <span class='color_blue'>lseg(_t$3,null,[],P0)</span>
    [footprint
       <span class='color_blue'>@f$2 != 0</span> *
       <span class='color_blue'>#GB<src.c>$head = @f$1 <span class='color_orange'>rearrange:38</span>:node*</span>  ]
    where
    P0 = exists [_t$2]. <span class='color_blue'>_t$0|->{next:_t$1 <span class='color_orange'>update:56</span>, v:_t$2 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16</span></span>
    
    Instruction <span class='color_green'>REMOVE_TEMPS(n$17,n$18,n$19); [line 54, column 7]</span>
    in vpath_find exp:_t$4
    vpath_find: found x : node*
    in vpath_find exp:_t$1
    vpath_find: found head : node*
    Instruction Returns
    PROP 1 of 1:
    <span class='color_blue'><span class='color_red'>(-1  &lt;  _t$7)</span>; <span class='color_red'>t != 0</span>; <span class='color_red'>MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(x)</span>; <span class='color_blue'>MEMma &lt; malloc:38 &gt;  <span class='color_orange'>{vpath: }</span>(_t$1)</span>; <span class='color_red'>DANGL &lt; UNINIT &gt; (_t$7)</span>; <span class='color_red'>DANGL &lt; UNINIT &gt; (_t$5)</span> ;
    <span class='color_blue'>x = <span class='color_red'>_t$6 <span class='color_orange'>update:45</span></span>:node*</span>; <span class='color_blue'>n = null <span class='color_orange'>update:40</span>:node*</span>; <span class='color_blue'>t = <span class='color_red'>_t$2 <span class='color_orange'>update:53</span></span>:node*</span>; <span class='color_blue'>#GB<src.c>$head = _t$1 <span class='color_orange'>update:38</span>:node*</span>; <span class='color_blue'>i = @f$0 <span class='color_orange'>update:43</span>:int</span>; <span class='color_blue'>return = _t$0 <span class='color_orange'>initial</span>:int</span> ;
    <span class='color_red'>x|->{next:null <span class='color_orange'>update:46</span>, v:i <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16</span>; <span class='color_red'>t|->{next:_t$4 <span class='color_orange'>update:56</span>, v:_t$5 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16</span>; <span class='color_blue'>_t$1|->{next:<span class='color_red'>t <span class='color_orange'>update:56</span></span>, v:<span class='color_red'>_t$3 <span class='color_orange'>alloc</span></span>} <span class='color_orange'>alloc</span>:node16</span>; <span class='color_blue'>lseg(_t$4,null,[],P0)</span>
    [footprint
       <span class='color_blue'>@f$2 != 0</span> *
       <span class='color_blue'>#GB<src.c>$head = @f$1 <span class='color_orange'>rearrange:38</span>:node*</span>  ]
    where
    P0 = exists [_t$2]. <span class='color_blue'>_t$0|->{next:_t$1 <span class='color_orange'>update:56</span>, v:_t$2 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16</span></span>
    
    Instruction <span class='color_green'>APPLY_ABSTRACTION; [line 54, column 7]</span>
    in vpath_find exp:_t$6
    vpath_find: found x : node*
    in vpath_find exp:_t$1
    vpath_find: found head : node*
    <span class='color_blue'>t != 0; MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(x); MEMma &lt; malloc:38 &gt;  <span class='color_orange'>{vpath: }</span>(_t$1) ;
    x = _t$4 <span class='color_orange'>update:45</span>:node*; n = null <span class='color_orange'>update:40</span>:node*; t = _t$2 <span class='color_orange'>update:53</span>:node*; #GB<src.c>$head = _t$1 <span class='color_orange'>update:38</span>:node*; i = @f$0 <span class='color_orange'>update:43</span>:int; return = _t$0 <span class='color_orange'>initial</span>:int ;
    x|->{next:null <span class='color_orange'>update:46</span>, v:i <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16; _t$1|->{next:t <span class='color_orange'>update:56</span>, v:_t$3 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16; lsegne(t,null,[],P0)
    [footprint
       #GB<src.c>$head = @f$1 <span class='color_orange'>rearrange:38</span>:node*  ]
    where
    P0 = exists [_t$2]. _t$0|->{next:_t$1 <span class='color_orange'>update:56</span>, v:_t$2 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16</span>
    Instruction Returns
    PROP 1 of 1:
    <span class='color_blue'><span class='color_blue'>t != 0</span>; <span class='color_red'>MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(x)</span>; <span class='color_blue'>MEMma &lt; malloc:38 &gt;  <span class='color_orange'>{vpath: }</span>(_t$1)</span> ;
    <span class='color_blue'>x = <span class='color_red'>_t$4 <span class='color_orange'>update:45</span></span>:node*</span>; <span class='color_blue'>n = null <span class='color_orange'>update:40</span>:node*</span>; <span class='color_blue'>t = _t$2 <span class='color_orange'>update:53</span>:node*</span>; <span class='color_blue'>#GB<src.c>$head = _t$1 <span class='color_orange'>update:38</span>:node*</span>; <span class='color_blue'>i = @f$0 <span class='color_orange'>update:43</span>:int</span>; <span class='color_blue'>return = _t$0 <span class='color_orange'>initial</span>:int</span> ;
    <span class='color_blue'>x|->{next:null <span class='color_orange'>update:46</span>, v:i <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16</span>; <span class='color_blue'>_t$1|->{next:t <span class='color_orange'>update:56</span>, v:_t$3 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16</span>; <span class='color_blue'>lsegne(t,null,[],P0)</span>
    [footprint
       <span class='color_blue'>#GB<src.c>$head = @f$1 <span class='color_orange'>rearrange:38</span>:node*</span>  ]
    where
    P0 = exists [_t$2]. <span class='color_blue'>_t$0|->{next:_t$1 <span class='color_orange'>update:56</span>, v:_t$2 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16</span></span>
    
    .... After Symbolic Execution ....
    PROP 1 of 1:
    <span class='color_blue'><span class='color_blue'>t != 0</span>; <span class='color_blue'>MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(x)</span>; <span class='color_blue'>MEMma &lt; malloc:38 &gt;  <span class='color_orange'>{vpath: }</span>(_t$1)</span> ;
    <span class='color_blue'>x = _t$4 <span class='color_orange'>update:45</span>:node*</span>; <span class='color_blue'>n = null <span class='color_orange'>update:40</span>:node*</span>; <span class='color_blue'>t = _t$2 <span class='color_orange'>update:53</span>:node*</span>; <span class='color_blue'>#GB<src.c>$head = _t$1 <span class='color_orange'>update:38</span>:node*</span>; <span class='color_blue'>i = @f$0 <span class='color_orange'>update:43</span>:int</span>; <span class='color_blue'>return = _t$0 <span class='color_orange'>initial</span>:int</span> ;
    <span class='color_blue'>x|->{next:null <span class='color_orange'>update:46</span>, v:i <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16</span>; <span class='color_blue'>_t$1|->{next:t <span class='color_orange'>update:56</span>, v:_t$3 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16</span>; <span class='color_blue'>lsegne(t,null,[],P0)</span>
    [footprint
       <span class='color_blue'>#GB<src.c>$head = @f$1 <span class='color_orange'>rearrange:38</span>:node*</span>  ]
    where
    P0 = exists [_t$2]. <span class='color_blue'>_t$0|->{next:_t$1 <span class='color_orange'>update:56</span>, v:_t$2 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16</span></span>
    
    
    
  </LISTING></span><hr width="100%">
<a name="session319" href="./../nodes/main.fad58de7366495db4650cfefac2fcd61_node25.html#session319">node25#session319</a>(<a href="./../../src.c.b9996786c0d0c7ca7785f2f6d38e80de.html#LINE54">54</a>) interproc<LISTING><span class='color_black'>**** [FP:Pending] main Node: 25, Procedure: main, Session: 319, Todo: 1 ****
  PROP 1 of 1:
  <span class='color_blue'><span class='color_red'>t != 0</span>; <span class='color_red'>_t$2 != 0</span>; <span class='color_red'>MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(x)</span>; <span class='color_red'>MEMma &lt; malloc:38 &gt;  <span class='color_orange'>{vpath: }</span>(_t$1)</span> ;
  <span class='color_red'>x = _t$5 <span class='color_orange'>update:45</span>:node*</span>; <span class='color_red'>n = null <span class='color_orange'>update:40</span>:node*</span>; <span class='color_red'>t = _t$3 <span class='color_orange'>update:53</span>:node*</span>; <span class='color_red'>#GB<src.c>$head = _t$1 <span class='color_orange'>update:38</span>:node*</span>; <span class='color_red'>i = @f$0 <span class='color_orange'>update:43</span>:int</span>; <span class='color_red'>return = _t$0 <span class='color_orange'>initial</span>:int</span> ;
  <span class='color_red'>x|->{next:null <span class='color_orange'>update:46</span>, v:i <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16</span>; <span class='color_red'>_t$2|->{next:t <span class='color_orange'>update:56</span>, v:_t$4 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16</span>; <span class='color_red'>lsegne(t,null,[],P0)</span>; <span class='color_red'>lsegne(_t$1,_t$2,[],P0)</span>
  [footprint
     <span class='color_red'>@f$2 != 0</span> *
     <span class='color_red'>#GB<src.c>$head = @f$1 <span class='color_orange'>rearrange:38</span>:node*</span>  ]
  where
  P0 = exists [_t$2]. <span class='color_blue'>_t$0|->{next:_t$1 <span class='color_orange'>update:56</span>, v:_t$2 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16</span></span>
  .... Instructions: .... 
  <span class='color_green'>n$17=*&amp;t:node* [line 54, column 21];
  n$18=*n$17.v:int [line 54, column 21];
  n$19=_fun_printf("%d\n":char const *,n$18:int) [line 54, column 7];
  REMOVE_TEMPS(n$17,n$18,n$19); [line 54, column 7];
  APPLY_ABSTRACTION; [line 54, column 7];
  </span>
  
  Processing prop 1/1
    Instruction <span class='color_green'>n$17=*&amp;t:node* [line 54, column 21]</span>
    in vpath_find exp:n$759
    vpath_find: found head : node*
    in vpath_find exp:n$755
    vpath_find: found x : node*
    .... Rearrangement Start ....
    Exp: &amp;t
    Prop: 
    <span class='color_blue'>t != 0; n$756 != 0; MEMma &lt; malloc:38 &gt;  <span class='color_orange'>{vpath: }</span>(n$759); MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(x) ;
    x = n$755 <span class='color_orange'>update:45</span>:node*; n = null <span class='color_orange'>update:40</span>:node*; t = n$757 <span class='color_orange'>update:53</span>:node*; #GB<src.c>$head = n$759 <span class='color_orange'>update:38</span>:node*; i = @f$0 <span class='color_orange'>update:43</span>:int; return = n$760 <span class='color_orange'>initial</span>:int ;
    n$756|->{next:t <span class='color_orange'>update:56</span>, v:n$758 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16; x|->{next:null <span class='color_orange'>update:46</span>, v:i <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16; lsegne(n$759,n$756,[],P0); lsegne(t,null,[],P0)
    [footprint
       @f$2 != 0 *
       #GB<src.c>$head = @f$1 <span class='color_orange'>rearrange:38</span>:node*  ]
    where
    P0 = exists [_t$2]. _t$0|->{next:_t$1 <span class='color_orange'>update:56</span>, v:_t$2 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16</span>
    
    in prop_iter_extend_ptsto lexp: &amp;t
    prop before:
    <span class='color_blue'>t != 0; n$756 != 0; MEMma &lt; malloc:38 &gt;  <span class='color_orange'>{vpath: }</span>(n$759); MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(x) ;
    x = n$755 <span class='color_orange'>update:45</span>:node*; n = null <span class='color_orange'>update:40</span>:node*; t = n$757 <span class='color_orange'>update:53</span>:node*; #GB<src.c>$head = n$759 <span class='color_orange'>update:38</span>:node*; i = @f$0 <span class='color_orange'>update:43</span>:int; return = n$760 <span class='color_orange'>initial</span>:int ;
    n$756|->{next:t <span class='color_orange'>update:56</span>, v:n$758 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16; x|->{next:null <span class='color_orange'>update:46</span>, v:i <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16; lsegne(n$759,n$756,[],P0); lsegne(t,null,[],P0)
    [footprint
       @f$2 != 0 *
       #GB<src.c>$head = @f$1 <span class='color_orange'>rearrange:38</span>:node*  ]
    where
    P0 = exists [_t$2]. _t$0|->{next:_t$1 <span class='color_orange'>update:56</span>, v:_t$2 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16</span>
    
    
    prop list after:
    PROP 1 of 1:
    <span class='color_blue'><span class='color_blue'>t != 0</span>; <span class='color_blue'>n$756 != 0</span>; <span class='color_blue'>MEMma &lt; malloc:38 &gt;  <span class='color_orange'>{vpath: }</span>(n$759)</span>; <span class='color_blue'>MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(x)</span> ;
    <span class='color_blue'>x = n$755 <span class='color_orange'>update:45</span>:node*</span>; <span class='color_blue'>n = null <span class='color_orange'>update:40</span>:node*</span>; <span class='color_blue'>t = n$757 <span class='color_orange'>update:53</span>:node*</span>; <span class='color_blue'>#GB<src.c>$head = n$759 <span class='color_orange'>update:38</span>:node*</span>; <span class='color_blue'>i = @f$0 <span class='color_orange'>update:43</span>:int</span>; <span class='color_blue'>return = n$760 <span class='color_orange'>initial</span>:int</span> ;
    <span class='color_blue'>n$756|->{next:t <span class='color_orange'>update:56</span>, v:n$758 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16</span>; <span class='color_blue'>x|->{next:null <span class='color_orange'>update:46</span>, v:i <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16</span>; <span class='color_blue'>lsegne(n$759,n$756,[],P0)</span>; <span class='color_blue'>lsegne(t,null,[],P0)</span>
    [footprint
       <span class='color_blue'>@f$2 != 0</span> *
       <span class='color_blue'>#GB<src.c>$head = @f$1 <span class='color_orange'>rearrange:38</span>:node*</span>  ]
    where
    P0 = exists [_t$2]. <span class='color_blue'>_t$0|->{next:_t$1 <span class='color_orange'>update:56</span>, v:_t$2 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16</span></span>
    
    
    
    Instruction Returns
    PROP 1 of 1:
    <span class='color_blue'><span class='color_blue'>_t$2 != 0</span>; <span class='color_red'>t != 0</span>; <span class='color_red'>MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(x)</span>; <span class='color_blue'>MEMma &lt; malloc:38 &gt;  <span class='color_orange'>{vpath: }</span>(_t$1)</span> ;
    <span class='color_blue'>x = <span class='color_red'>_t$4 <span class='color_orange'>update:45</span></span>:node*</span>; <span class='color_blue'>n = null <span class='color_orange'>update:40</span>:node*</span>; <span class='color_blue'>t = <span class='color_red'>n$17 <span class='color_orange'>update:53</span></span>:node*</span>; <span class='color_blue'>#GB<src.c>$head = _t$1 <span class='color_orange'>update:38</span>:node*</span>; <span class='color_blue'>i = @f$0 <span class='color_orange'>update:43</span>:int</span>; <span class='color_blue'>return = _t$0 <span class='color_orange'>initial</span>:int</span> ;
    <span class='color_red'>x|->{next:null <span class='color_orange'>update:46</span>, v:i <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16</span>; <span class='color_blue'>_t$2|->{next:<span class='color_red'>t <span class='color_orange'>update:56</span></span>, v:<span class='color_red'>_t$3 <span class='color_orange'>alloc</span></span>} <span class='color_orange'>alloc</span>:node16</span>; <span class='color_blue'>lsegne(_t$1,_t$2,[],P0)</span>; <span class='color_red'>lsegne(t,null,[],P0)</span>
    [footprint
       <span class='color_blue'>@f$2 != 0</span> *
       <span class='color_blue'>#GB<src.c>$head = @f$1 <span class='color_orange'>rearrange:38</span>:node*</span>  ]
    where
    P0 = exists [_t$2]. <span class='color_blue'>_t$0|->{next:_t$1 <span class='color_orange'>update:56</span>, v:_t$2 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16</span></span>
    
    Instruction <span class='color_green'>n$18=*n$17.v:int [line 54, column 21]</span>
    in vpath_find exp:n$764
    vpath_find: found head : node*
    in vpath_find exp:n$761
    vpath_find: found x : node*
    .... Rearrangement Start ....
    Exp: n$17.v
    Prop: 
    <span class='color_blue'>n$762 != 0; t != 0; MEMma &lt; malloc:38 &gt;  <span class='color_orange'>{vpath: }</span>(n$764); MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(x) ;
    x = n$761 <span class='color_orange'>update:45</span>:node*; n = null <span class='color_orange'>update:40</span>:node*; t = n$17 <span class='color_orange'>update:53</span>:node*; #GB<src.c>$head = n$764 <span class='color_orange'>update:38</span>:node*; i = @f$0 <span class='color_orange'>update:43</span>:int; return = n$765 <span class='color_orange'>initial</span>:int ;
    n$762|->{next:t <span class='color_orange'>update:56</span>, v:n$763 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16; x|->{next:null <span class='color_orange'>update:46</span>, v:i <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16; lsegne(n$764,n$762,[],P0); lsegne(t,null,[],P0)
    [footprint
       @f$2 != 0 *
       #GB<src.c>$head = @f$1 <span class='color_orange'>rearrange:38</span>:node*  ]
    where
    P0 = exists [_t$2]. _t$0|->{next:_t$1 <span class='color_orange'>update:56</span>, v:_t$2 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16</span>
    
    in prop_iter_extend_ptsto lexp: n$17.v
    prop before:
    <span class='color_blue'>n$762 != 0; t != 0; MEMma &lt; malloc:38 &gt;  <span class='color_orange'>{vpath: }</span>(n$764); MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(x) ;
    x = n$761 <span class='color_orange'>update:45</span>:node*; n = null <span class='color_orange'>update:40</span>:node*; t = n$17 <span class='color_orange'>update:53</span>:node*; #GB<src.c>$head = n$764 <span class='color_orange'>update:38</span>:node*; i = @f$0 <span class='color_orange'>update:43</span>:int; return = n$765 <span class='color_orange'>initial</span>:int ;
    n$762|->{next:t <span class='color_orange'>update:56</span>, v:n$763 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16; x|->{next:null <span class='color_orange'>update:46</span>, v:i <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16; t|->{next:_t$1228 <span class='color_orange'>update:56</span>, v:_t$1229 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16; lsegne(n$764,n$762,[],P0); lseg(_t$1228,null,[],P0)
    [footprint
       @f$2 != 0 *
       #GB<src.c>$head = @f$1 <span class='color_orange'>rearrange:38</span>:node*  ]
    where
    P0 = exists [_t$2]. _t$0|->{next:_t$1 <span class='color_orange'>update:56</span>, v:_t$2 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16</span>
    
    
    prop list after:
    PROP 1 of 1:
    <span class='color_blue'><span class='color_blue'>n$762 != 0</span>; <span class='color_blue'>t != 0</span>; <span class='color_blue'>MEMma &lt; malloc:38 &gt;  <span class='color_orange'>{vpath: }</span>(n$764)</span>; <span class='color_blue'>MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(x)</span> ;
    <span class='color_blue'>x = n$761 <span class='color_orange'>update:45</span>:node*</span>; <span class='color_blue'>n = null <span class='color_orange'>update:40</span>:node*</span>; <span class='color_blue'>t = n$17 <span class='color_orange'>update:53</span>:node*</span>; <span class='color_blue'>#GB<src.c>$head = n$764 <span class='color_orange'>update:38</span>:node*</span>; <span class='color_blue'>i = @f$0 <span class='color_orange'>update:43</span>:int</span>; <span class='color_blue'>return = n$765 <span class='color_orange'>initial</span>:int</span> ;
    <span class='color_blue'>n$762|->{next:t <span class='color_orange'>update:56</span>, v:n$763 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16</span>; <span class='color_blue'>x|->{next:null <span class='color_orange'>update:46</span>, v:i <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16</span>; <span class='color_blue'>t|->{next:_t$1228 <span class='color_orange'>update:56</span>, v:_t$1229 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16</span>; <span class='color_blue'>lsegne(n$764,n$762,[],P0)</span>; <span class='color_blue'>lseg(_t$1228,null,[],P0)</span>
    [footprint
       <span class='color_blue'>@f$2 != 0</span> *
       <span class='color_blue'>#GB<src.c>$head = @f$1 <span class='color_orange'>rearrange:38</span>:node*</span>  ]
    where
    P0 = exists [_t$2]. <span class='color_blue'>_t$0|->{next:_t$1 <span class='color_orange'>update:56</span>, v:_t$2 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16</span></span>
    
    
    
    Instruction Returns
    PROP 1 of 1:
    <span class='color_blue'><span class='color_blue'>_t$2 != 0</span>; <span class='color_blue'>t != 0</span>; <span class='color_red'>MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(x)</span>; <span class='color_blue'>MEMma &lt; malloc:38 &gt;  <span class='color_orange'>{vpath: }</span>(_t$1)</span>; <span class='color_red'>DANGL &lt; UNINIT &gt; (n$18)</span> ;
    <span class='color_blue'>x = <span class='color_red'>_t$5 <span class='color_orange'>update:45</span></span>:node*</span>; <span class='color_blue'>n = null <span class='color_orange'>update:40</span>:node*</span>; <span class='color_blue'>t = n$17 <span class='color_orange'>update:53</span>:node*</span>; <span class='color_blue'>#GB<src.c>$head = _t$1 <span class='color_orange'>update:38</span>:node*</span>; <span class='color_blue'>i = @f$0 <span class='color_orange'>update:43</span>:int</span>; <span class='color_blue'>return = _t$0 <span class='color_orange'>initial</span>:int</span> ;
    <span class='color_red'>x|->{next:null <span class='color_orange'>update:46</span>, v:i <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16</span>; <span class='color_blue'>_t$2|->{next:t <span class='color_orange'>update:56</span>, v:_t$3 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16</span>; <span class='color_blue'>t|->{next:_t$4 <span class='color_orange'>update:56</span>, v:n$18 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16</span>; <span class='color_blue'>lsegne(_t$1,_t$2,[],P0)</span>; <span class='color_blue'>lseg(_t$4,null,[],P0)</span>
    [footprint
       <span class='color_blue'>@f$2 != 0</span> *
       <span class='color_blue'>#GB<src.c>$head = @f$1 <span class='color_orange'>rearrange:38</span>:node*</span>  ]
    where
    P0 = exists [_t$2]. <span class='color_blue'>_t$0|->{next:_t$1 <span class='color_orange'>update:56</span>, v:_t$2 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16</span></span>
    
    Instruction <span class='color_green'>n$19=_fun_printf("%d\n":char const *,n$18:int) [line 54, column 7]</span>
    in vpath_find exp:n$770
    vpath_find: found head : node*
    in vpath_find exp:n$766
    vpath_find: found x : node*
    <span class='color_orange'>WARNING: likely use of variable-arguments function, or function prototype missing</span>
    actual parameters: n$18
    formal parameters: 
    Found 1 specs for function printf
    START EXECUTING SPECS FOR printf from state
    <span class='color_blue'>n$767 != 0; t != 0; MEMma &lt; malloc:38 &gt;  <span class='color_orange'>{vpath: }</span>(n$770); MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(x); DANGL &lt; UNINIT &gt; (n$18) ;
    x = n$766 <span class='color_orange'>update:45</span>:node*; n = null <span class='color_orange'>update:40</span>:node*; t = n$17 <span class='color_orange'>update:53</span>:node*; #GB<src.c>$head = n$770 <span class='color_orange'>update:38</span>:node*; i = @f$0 <span class='color_orange'>update:43</span>:int; return = n$771 <span class='color_orange'>initial</span>:int ;
    n$767|->{next:t <span class='color_orange'>update:56</span>, v:n$768 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16; x|->{next:null <span class='color_orange'>update:46</span>, v:i <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16; t|->{next:n$769 <span class='color_orange'>update:56</span>, v:n$18 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16; lsegne(n$770,n$767,[],P0); lseg(n$769,null,[],P0)
    [footprint
       @f$2 != 0 *
       #GB<src.c>$head = @f$1 <span class='color_orange'>rearrange:38</span>:node*  ]
    where
    P0 = exists [_t$2]. _t$0|->{next:_t$1 <span class='color_orange'>update:56</span>, v:_t$2 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16</span>
    <span class='color_orange'>WARNING: more actual pars than formal pars in fun call (2 vs 1)</span>
    EXECUTING SPEC 1/1
    ACTUAL PRECONDITION =
      <span class='color_blue'>n$767 != 0; t != 0; MEMma &lt; malloc:38 &gt;  <span class='color_orange'>{vpath: }</span>(n$770); MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(x); DANGL &lt; UNINIT &gt; (n$18) ;
      x = n$766 <span class='color_orange'>update:45</span>:node*; n = null <span class='color_orange'>update:40</span>:node*; t = n$17 <span class='color_orange'>update:53</span>:node*; #GB<src.c>$head = n$770 <span class='color_orange'>update:38</span>:node*; i = @f$0 <span class='color_orange'>update:43</span>:int; format|callee = "%d\n" <span class='color_orange'>actual_precondition</span>:char const *; return = n$771 <span class='color_orange'>initial</span>:int ;
      n$767|->{next:t <span class='color_orange'>update:56</span>, v:n$768 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16; x|->{next:null <span class='color_orange'>update:46</span>, v:i <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16; t|->{next:n$769 <span class='color_orange'>update:56</span>, v:n$18 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16; lsegne(n$770,n$767,[],P0); lseg(n$769,null,[],P0)
      [footprint
         @f$2 != 0 *
         #GB<src.c>$head = @f$1 <span class='color_orange'>rearrange:38</span>:node*  ]
      where
      P0 = exists [_t$2]. _t$0|->{next:_t$1 <span class='color_orange'>update:56</span>, v:_t$2 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16</span>
    SPEC =
      --------------------------- ---------- ---------------------------
      PRE:
      <span class='color_blue'><span class='color_blue'>format|callee = _t$1236 <span class='color_orange'>formal</span>:char const *</span></span>
      POST 1 of 1:
      <span class='color_blue'><span class='color_red'>(-1  &lt;  _t$1237)</span>; <span class='color_red'>DANGL &lt; UNINIT &gt; (return|callee)</span> ;
      <span class='color_red'>return|callee = _t$1237 <span class='color_orange'>update:1114</span>:int</span></span>
      ----------------------------------------------------------------
    pre_check_pure_implication
    pi1:
      n$767 != 0; n$17 != 0; MEMma &lt; malloc:38 &gt;  <span class='color_orange'>{vpath: }</span>(n$770); MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(n$766); DANGL &lt; UNINIT &gt; (n$18)
    pi2:
      
    returns
    sub1: 
      
    sub2: 
      
    Current Implication
    SUB:
      
    <span class='color_blue'>n$767 != 0; t != 0; MEMma &lt; malloc:38 &gt;  <span class='color_orange'>{vpath: }</span>(n$770); MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(x); DANGL &lt; UNINIT &gt; (n$18) ;
    x = n$766 <span class='color_orange'>update:45</span>:node*; n = null <span class='color_orange'>update:40</span>:node*; t = n$17 <span class='color_orange'>update:53</span>:node*; #GB<src.c>$head = n$770 <span class='color_orange'>update:38</span>:node*; i = @f$0 <span class='color_orange'>update:43</span>:int; format|callee = "%d\n" <span class='color_orange'>actual_precondition</span>:char const *; return = n$771 <span class='color_orange'>initial</span>:int ;
    n$767|->{next:t <span class='color_orange'>update:56</span>, v:n$768 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16; x|->{next:null <span class='color_orange'>update:46</span>, v:i <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16; t|->{next:n$769 <span class='color_orange'>update:56</span>, v:n$18 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16; lsegne(n$770,n$767,[],P0); lseg(n$769,null,[],P0)
    [footprint
       @f$2 != 0 *
       #GB<src.c>$head = @f$1 <span class='color_orange'>rearrange:38</span>:node*  ]
    where
    P0 = exists [_t$2]. _t$0|->{next:_t$1 <span class='color_orange'>update:56</span>, v:_t$2 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16</span>
    |-
    <span class='color_blue'>format|callee = _t$1236 <span class='color_orange'>formal</span>:char const *</span>
    
      do_imply "%d\n" _t$1236
        Final Implication
        SUB:
          
        <span class='color_blue'>n$767 != 0; t != 0; MEMma &lt; malloc:38 &gt;  <span class='color_orange'>{vpath: }</span>(n$770); MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(x); DANGL &lt; UNINIT &gt; (n$18) ;
        x = n$766 <span class='color_orange'>update:45</span>:node*; n = null <span class='color_orange'>update:40</span>:node*; t = n$17 <span class='color_orange'>update:53</span>:node*; #GB<src.c>$head = n$770 <span class='color_orange'>update:38</span>:node*; i = @f$0 <span class='color_orange'>update:43</span>:int; return = n$771 <span class='color_orange'>initial</span>:int ;
        n$767|->{next:t <span class='color_orange'>update:56</span>, v:n$768 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16; x|->{next:null <span class='color_orange'>update:46</span>, v:i <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16; t|->{next:n$769 <span class='color_orange'>update:56</span>, v:n$18 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16; lsegne(n$770,n$767,[],P0); lseg(n$769,null,[],P0)
        [footprint
           @f$2 != 0 *
           #GB<src.c>$head = @f$1 <span class='color_orange'>rearrange:38</span>:node*  ]
        where
        P0 = exists [_t$2]. _t$0|->{next:_t$1 <span class='color_orange'>update:56</span>, v:_t$2 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16</span>
        [SUB: 
          _t$1236 = "%d\n"]
        |-
        <span class='color_blue'></span>
    Result of Abduction
      SUB:
        
      <span class='color_blue'>n$767 != 0; t != 0; MEMma &lt; malloc:38 &gt;  <span class='color_orange'>{vpath: }</span>(n$770); MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(x); DANGL &lt; UNINIT &gt; (n$18) ;
      x = n$766 <span class='color_orange'>update:45</span>:node*; n = null <span class='color_orange'>update:40</span>:node*; t = n$17 <span class='color_orange'>update:53</span>:node*; #GB<src.c>$head = n$770 <span class='color_orange'>update:38</span>:node*; i = @f$0 <span class='color_orange'>update:43</span>:int; format|callee = "%d\n" <span class='color_orange'>actual_precondition</span>:char const *; return = n$771 <span class='color_orange'>initial</span>:int ;
      n$767|->{next:t <span class='color_orange'>update:56</span>, v:n$768 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16; x|->{next:null <span class='color_orange'>update:46</span>, v:i <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16; t|->{next:n$769 <span class='color_orange'>update:56</span>, v:n$18 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16; lsegne(n$770,n$767,[],P0); lseg(n$769,null,[],P0)
      [footprint
         @f$2 != 0 *
         #GB<src.c>$head = @f$1 <span class='color_orange'>rearrange:38</span>:node*  ]
      where
      P0 = exists [_t$2]. _t$0|->{next:_t$1 <span class='color_orange'>update:56</span>, v:_t$2 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16</span>
      [SUB: 
        _t$1236 = "%d\n"]
      |-
      <span class='color_blue'>format|callee = "%d\n" <span class='color_orange'>formal</span>:char const *</span>
    returning TRUE
      New footprint:
      
      Frame fld:
      
      Missing fld:
      
      Instantiated frame:
      n$767|->{next:n$17 <span class='color_orange'>update:56</span>, v:n$768 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16; n$766|->{next:null <span class='color_orange'>update:46</span>, v:@f$0 <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16; n$17|->{next:n$769 <span class='color_orange'>update:56</span>, v:n$18 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16; &amp;x|->n$766 <span class='color_orange'>update:45</span>:node*; &amp;n|->null <span class='color_orange'>update:40</span>:node*; &amp;t|->n$17 <span class='color_orange'>update:53</span>:node*; &amp;#GB<src.c>$head|->n$770 <span class='color_orange'>update:38</span>:node*; &amp;i|->@f$0 <span class='color_orange'>update:43</span>:int; &amp;return|->n$771 <span class='color_orange'>initial</span>:int; lsegne(n$770,n$767,[],lam [_t$0,_t$1,]. exists [_t$2]. _t$0|->{next:_t$1 <span class='color_orange'>update:56</span>, v:_t$2 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16); lseg(n$769,null,[],lam [_t$0,_t$1,]. exists [_t$2]. _t$0|->{next:_t$1 <span class='color_orange'>update:56</span>, v:_t$2 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16)
      Instantiated post:
      PROP 1 of 1:
      <span class='color_blue'><span class='color_red'>(-1  &lt;  _t$1237)</span>; <span class='color_red'>DANGL &lt; UNINIT &gt; (return|callee)</span> ;
      <span class='color_red'>return|callee = _t$1237 <span class='color_orange'>update:54</span>:int</span></span>
      
    ***** RESULTS FUNCTION CALL *******
    PROP 1 of 1:
    <span class='color_blue'><span class='color_red'>(-1  &lt;  n$19)</span>; <span class='color_blue'>n$767 != 0</span>; <span class='color_blue'>t != 0</span>; <span class='color_blue'>MEMma &lt; malloc:38 &gt;  <span class='color_orange'>{vpath: }</span>(n$770)</span>; <span class='color_blue'>MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(x)</span>; <span class='color_red'>DANGL &lt; UNINIT &gt; (n$19)</span>; <span class='color_blue'>DANGL &lt; UNINIT &gt; (n$18)</span> ;
    <span class='color_blue'>x = n$766 <span class='color_orange'>update:45</span>:node*</span>; <span class='color_blue'>n = null <span class='color_orange'>update:40</span>:node*</span>; <span class='color_blue'>t = n$17 <span class='color_orange'>update:53</span>:node*</span>; <span class='color_blue'>#GB<src.c>$head = n$770 <span class='color_orange'>update:38</span>:node*</span>; <span class='color_blue'>i = @f$0 <span class='color_orange'>update:43</span>:int</span>; <span class='color_blue'>return = n$771 <span class='color_orange'>initial</span>:int</span> ;
    <span class='color_blue'>n$767|->{next:t <span class='color_orange'>update:56</span>, v:n$768 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16</span>; <span class='color_blue'>x|->{next:null <span class='color_orange'>update:46</span>, v:i <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16</span>; <span class='color_blue'>t|->{next:n$769 <span class='color_orange'>update:56</span>, v:n$18 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16</span>; <span class='color_blue'>lsegne(n$770,n$767,[],P0)</span>; <span class='color_blue'>lseg(n$769,null,[],P0)</span>
    [footprint
       <span class='color_blue'>@f$2 != 0</span> *
       <span class='color_blue'>#GB<src.c>$head = @f$1 <span class='color_orange'>rearrange:38</span>:node*</span>  ]
    where
    P0 = exists [_t$2]. <span class='color_blue'>_t$0|->{next:_t$1 <span class='color_orange'>update:56</span>, v:_t$2 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16</span></span>
    ***** END RESULTS FUNCTION CALL *******
    Instruction Returns
    PROP 1 of 1:
    <span class='color_blue'><span class='color_red'>(-1  &lt;  n$19)</span>; <span class='color_blue'>_t$2 != 0</span>; <span class='color_blue'>t != 0</span>; <span class='color_blue'>MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(x)</span>; <span class='color_blue'>MEMma &lt; malloc:38 &gt;  <span class='color_orange'>{vpath: }</span>(_t$1)</span>; <span class='color_red'>DANGL &lt; UNINIT &gt; (n$19)</span>; <span class='color_blue'>DANGL &lt; UNINIT &gt; (n$18)</span> ;
    <span class='color_blue'>x = _t$5 <span class='color_orange'>update:45</span>:node*</span>; <span class='color_blue'>n = null <span class='color_orange'>update:40</span>:node*</span>; <span class='color_blue'>t = n$17 <span class='color_orange'>update:53</span>:node*</span>; <span class='color_blue'>#GB<src.c>$head = _t$1 <span class='color_orange'>update:38</span>:node*</span>; <span class='color_blue'>i = @f$0 <span class='color_orange'>update:43</span>:int</span>; <span class='color_blue'>return = _t$0 <span class='color_orange'>initial</span>:int</span> ;
    <span class='color_blue'>x|->{next:null <span class='color_orange'>update:46</span>, v:i <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16</span>; <span class='color_blue'>_t$2|->{next:t <span class='color_orange'>update:56</span>, v:_t$3 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16</span>; <span class='color_blue'>t|->{next:_t$4 <span class='color_orange'>update:56</span>, v:n$18 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16</span>; <span class='color_blue'>lsegne(_t$1,_t$2,[],P0)</span>; <span class='color_blue'>lseg(_t$4,null,[],P0)</span>
    [footprint
       <span class='color_blue'>@f$2 != 0</span> *
       <span class='color_blue'>#GB<src.c>$head = @f$1 <span class='color_orange'>rearrange:38</span>:node*</span>  ]
    where
    P0 = exists [_t$2]. <span class='color_blue'>_t$0|->{next:_t$1 <span class='color_orange'>update:56</span>, v:_t$2 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16</span></span>
    
    Instruction <span class='color_green'>REMOVE_TEMPS(n$17,n$18,n$19); [line 54, column 7]</span>
    in vpath_find exp:_t$5
    vpath_find: found x : node*
    in vpath_find exp:_t$1
    vpath_find: found head : node*
    Instruction Returns
    PROP 1 of 1:
    <span class='color_blue'><span class='color_red'>(-1  &lt;  _t$8)</span>; <span class='color_red'>t != 0</span>; <span class='color_blue'>_t$2 != 0</span>; <span class='color_red'>MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(x)</span>; <span class='color_blue'>MEMma &lt; malloc:38 &gt;  <span class='color_orange'>{vpath: }</span>(_t$1)</span>; <span class='color_red'>DANGL &lt; UNINIT &gt; (_t$8)</span>; <span class='color_red'>DANGL &lt; UNINIT &gt; (_t$6)</span> ;
    <span class='color_blue'>x = <span class='color_red'>_t$7 <span class='color_orange'>update:45</span></span>:node*</span>; <span class='color_blue'>n = null <span class='color_orange'>update:40</span>:node*</span>; <span class='color_blue'>t = <span class='color_red'>_t$3 <span class='color_orange'>update:53</span></span>:node*</span>; <span class='color_blue'>#GB<src.c>$head = _t$1 <span class='color_orange'>update:38</span>:node*</span>; <span class='color_blue'>i = @f$0 <span class='color_orange'>update:43</span>:int</span>; <span class='color_blue'>return = _t$0 <span class='color_orange'>initial</span>:int</span> ;
    <span class='color_red'>x|->{next:null <span class='color_orange'>update:46</span>, v:i <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16</span>; <span class='color_red'>t|->{next:_t$5 <span class='color_orange'>update:56</span>, v:_t$6 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16</span>; <span class='color_blue'>_t$2|->{next:<span class='color_red'>t <span class='color_orange'>update:56</span></span>, v:<span class='color_red'>_t$4 <span class='color_orange'>alloc</span></span>} <span class='color_orange'>alloc</span>:node16</span>; <span class='color_blue'>lsegne(_t$1,_t$2,[],P0)</span>; <span class='color_blue'>lseg(_t$5,null,[],P0)</span>
    [footprint
       <span class='color_blue'>@f$2 != 0</span> *
       <span class='color_blue'>#GB<src.c>$head = @f$1 <span class='color_orange'>rearrange:38</span>:node*</span>  ]
    where
    P0 = exists [_t$2]. <span class='color_blue'>_t$0|->{next:_t$1 <span class='color_orange'>update:56</span>, v:_t$2 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16</span></span>
    
    Instruction <span class='color_green'>APPLY_ABSTRACTION; [line 54, column 7]</span>
    in vpath_find exp:_t$7
    vpath_find: found x : node*
    in vpath_find exp:_t$1
    vpath_find: found head : node*
    <span class='color_blue'>t != 0; MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(x); MEMma &lt; malloc:38 &gt;  <span class='color_orange'>{vpath: }</span>(_t$1) ;
    x = _t$3 <span class='color_orange'>update:45</span>:node*; n = null <span class='color_orange'>update:40</span>:node*; t = _t$2 <span class='color_orange'>update:53</span>:node*; #GB<src.c>$head = _t$1 <span class='color_orange'>update:38</span>:node*; i = @f$0 <span class='color_orange'>update:43</span>:int; return = _t$0 <span class='color_orange'>initial</span>:int ;
    x|->{next:null <span class='color_orange'>update:46</span>, v:i <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16; lsegne(t,null,[],P0); lsegne(_t$1,t,[],P0)
    [footprint
       #GB<src.c>$head = @f$1 <span class='color_orange'>rearrange:38</span>:node*  ]
    where
    P0 = exists [_t$2]. _t$0|->{next:_t$1 <span class='color_orange'>update:56</span>, v:_t$2 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16</span>
    Instruction Returns
    PROP 1 of 1:
    <span class='color_blue'><span class='color_blue'>t != 0</span>; <span class='color_blue'>MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(x)</span>; <span class='color_blue'>MEMma &lt; malloc:38 &gt;  <span class='color_orange'>{vpath: }</span>(_t$1)</span> ;
    <span class='color_blue'>x = <span class='color_red'>_t$3 <span class='color_orange'>update:45</span></span>:node*</span>; <span class='color_blue'>n = null <span class='color_orange'>update:40</span>:node*</span>; <span class='color_blue'>t = <span class='color_red'>_t$2 <span class='color_orange'>update:53</span></span>:node*</span>; <span class='color_blue'>#GB<src.c>$head = _t$1 <span class='color_orange'>update:38</span>:node*</span>; <span class='color_blue'>i = @f$0 <span class='color_orange'>update:43</span>:int</span>; <span class='color_blue'>return = _t$0 <span class='color_orange'>initial</span>:int</span> ;
    <span class='color_blue'>x|->{next:<span class='color_red'>null <span class='color_orange'>update:46</span></span>, v:<span class='color_red'>i <span class='color_orange'>update:47</span></span>} <span class='color_orange'>alloc</span>:node16</span>; <span class='color_blue'>lsegne(t,null,[],P0)</span>; <span class='color_blue'>lsegne(_t$1,t,[],P0)</span>
    [footprint
       <span class='color_blue'>#GB<src.c>$head = @f$1 <span class='color_orange'>rearrange:38</span>:node*</span>  ]
    where
    P0 = exists [_t$2]. <span class='color_blue'>_t$0|->{next:_t$1 <span class='color_orange'>update:56</span>, v:_t$2 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16</span></span>
    
    .... After Symbolic Execution ....
    PROP 1 of 1:
    <span class='color_blue'><span class='color_blue'>t != 0</span>; <span class='color_blue'>MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(x)</span>; <span class='color_blue'>MEMma &lt; malloc:38 &gt;  <span class='color_orange'>{vpath: }</span>(_t$1)</span> ;
    <span class='color_blue'>x = <span class='color_red'>_t$3 <span class='color_orange'>update:45</span></span>:node*</span>; <span class='color_blue'>n = null <span class='color_orange'>update:40</span>:node*</span>; <span class='color_blue'>t = <span class='color_red'>_t$2 <span class='color_orange'>update:53</span></span>:node*</span>; <span class='color_blue'>#GB<src.c>$head = _t$1 <span class='color_orange'>update:38</span>:node*</span>; <span class='color_blue'>i = @f$0 <span class='color_orange'>update:43</span>:int</span>; <span class='color_blue'>return = _t$0 <span class='color_orange'>initial</span>:int</span> ;
    <span class='color_blue'>x|->{next:null <span class='color_orange'>update:46</span>, v:i <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16</span>; <span class='color_blue'>lsegne(t,null,[],P0)</span>; <span class='color_blue'>lsegne(_t$1,t,[],P0)</span>
    [footprint
       <span class='color_blue'>#GB<src.c>$head = @f$1 <span class='color_orange'>rearrange:38</span>:node*</span>  ]
    where
    P0 = exists [_t$2]. <span class='color_blue'>_t$0|->{next:_t$1 <span class='color_orange'>update:56</span>, v:_t$2 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16</span></span>
    
    
    
  </LISTING></span><hr width="100%">
<a name="session343" href="./../nodes/main.fad58de7366495db4650cfefac2fcd61_node25.html#session343">node25#session343</a>(<a href="./../../src.c.b9996786c0d0c7ca7785f2f6d38e80de.html#LINE54">54</a>) interproc<LISTING><span class='color_black'>**** [FP:Pending] main Node: 25, Procedure: main, Session: 343, Todo: 3 ****
  PROP 1 of 3:
  <span class='color_blue'><span class='color_red'>(@f$0  &lt;=  8)</span>; <span class='color_red'>t != 0</span>; <span class='color_red'>MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(x)</span>; <span class='color_red'>MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(_t$4)</span>; <span class='color_red'>MEMma &lt; malloc:38 &gt;  <span class='color_orange'>{vpath: }</span>(_t$1)</span> ;
  <span class='color_red'>x = _t$5 <span class='color_orange'>update:45</span>:node*</span>; <span class='color_red'>n = null <span class='color_orange'>update:40</span>:node*</span>; <span class='color_red'>t = _t$2 <span class='color_orange'>update:53</span>:node*</span>; <span class='color_red'>#GB<src.c>$head = _t$1 <span class='color_orange'>update:38</span>:node*</span>; <span class='color_red'>i = (@f$0 + 1) <span class='color_orange'>update:43</span>:int</span>; <span class='color_red'>return = _t$0 <span class='color_orange'>initial</span>:int</span> ;
  <span class='color_red'>x|->{next:null <span class='color_orange'>update:46</span>, v:(@f$0 + 1) <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16</span>; <span class='color_red'>_t$4|->{next:null <span class='color_orange'>update:46</span>, v:@f$0 <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16</span>; <span class='color_red'>_t$1|->{next:t <span class='color_orange'>update:56</span>, v:_t$3 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16</span>; <span class='color_red'>lseg(t,_t$4,[],P0)</span>
  [footprint
     <span class='color_red'>(@f$0  &lt;=  8)</span>; <span class='color_red'>@f$2 != 0</span> *
     <span class='color_red'>#GB<src.c>$head = @f$1 <span class='color_orange'>rearrange:38</span>:node*</span>  ]
  where
  P0 = exists [_t$2]. <span class='color_blue'>_t$0|->{next:_t$1 <span class='color_orange'>update:56</span>, v:_t$2 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16</span></span>
  PROP 2 of 3:
  <span class='color_blue'><span class='color_red'>t != 0</span>; <span class='color_red'>MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(x)</span>; <span class='color_red'>MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(n)</span>; <span class='color_red'>MEMma &lt; malloc:38 &gt;  <span class='color_orange'>{vpath: }</span>(_t$1)</span> ;
  <span class='color_red'>x = _t$5 <span class='color_orange'>update:45</span>:node*</span>; <span class='color_red'>n = _t$4 <span class='color_orange'>update:58</span>:node*</span>; <span class='color_red'>t = _t$2 <span class='color_orange'>update:53</span>:node*</span>; <span class='color_red'>#GB<src.c>$head = _t$1 <span class='color_orange'>update:38</span>:node*</span>; <span class='color_red'>i = 4 <span class='color_orange'>update:43</span>:int</span>; <span class='color_red'>return = _t$0 <span class='color_orange'>initial</span>:int</span> ;
  <span class='color_red'>x|->{next:null <span class='color_orange'>update:46</span>, v:4 <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16</span>; <span class='color_red'>n|->{next:null <span class='color_orange'>update:46</span>, v:3 <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16</span>; <span class='color_red'>_t$1|->{next:t <span class='color_orange'>update:56</span>, v:_t$3 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16</span>; <span class='color_red'>lseg(t,n,[],P0)</span>
  [footprint
     <span class='color_red'>@f$1 != 0</span> *
     <span class='color_red'>#GB<src.c>$head = @f$0 <span class='color_orange'>rearrange:38</span>:node*</span>  ]
  where
  P0 = exists [_t$2]. <span class='color_blue'>_t$0|->{next:_t$1 <span class='color_orange'>update:56</span>, v:_t$2 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16</span></span>
  PROP 3 of 3:
  <span class='color_blue'><span class='color_red'>(@f$0  &lt;=  8)</span>; <span class='color_red'>t != 0</span>; <span class='color_red'>MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(x)</span>; <span class='color_red'>MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(t)</span>; <span class='color_red'>MEMma &lt; malloc:38 &gt;  <span class='color_orange'>{vpath: }</span>(_t$1)</span> ;
  <span class='color_red'>x = _t$4 <span class='color_orange'>update:45</span>:node*</span>; <span class='color_red'>n = null <span class='color_orange'>update:40</span>:node*</span>; <span class='color_red'>t = _t$2 <span class='color_orange'>update:53</span>:node*</span>; <span class='color_red'>#GB<src.c>$head = _t$1 <span class='color_orange'>update:38</span>:node*</span>; <span class='color_red'>i = (@f$0 + 1) <span class='color_orange'>update:43</span>:int</span>; <span class='color_red'>return = _t$0 <span class='color_orange'>initial</span>:int</span> ;
  <span class='color_red'>x|->{next:null <span class='color_orange'>update:46</span>, v:(@f$0 + 1) <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16</span>; <span class='color_red'>t|->{next:null <span class='color_orange'>update:46</span>, v:@f$0 <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16</span>; <span class='color_red'>_t$1|->{next:t <span class='color_orange'>update:56</span>, v:_t$3 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16</span>
  [footprint
     <span class='color_red'>(@f$0  &lt;=  8)</span>; <span class='color_red'>@f$2 != 0</span> *
     <span class='color_red'>#GB<src.c>$head = @f$1 <span class='color_orange'>rearrange:38</span>:node*</span>  ]</span>
  .... Instructions: .... 
  <span class='color_green'>n$17=*&amp;t:node* [line 54, column 21];
  n$18=*n$17.v:int [line 54, column 21];
  n$19=_fun_printf("%d\n":char const *,n$18:int) [line 54, column 7];
  REMOVE_TEMPS(n$17,n$18,n$19); [line 54, column 7];
  APPLY_ABSTRACTION; [line 54, column 7];
  </span>
  
  Processing prop 1/3
    Instruction <span class='color_green'>n$17=*&amp;t:node* [line 54, column 21]</span>
    in vpath_find exp:n$1162
    vpath_find: found head : node*
    in vpath_find exp:n$1161
    vpath_find: cannot find n$1161
    in vpath_find exp:n$1160
    vpath_find: found x : node*
    .... Rearrangement Start ....
    Exp: &amp;t
    Prop: 
    <span class='color_blue'>(@f$0  &lt;=  8); t != 0; MEMma &lt; malloc:38 &gt;  <span class='color_orange'>{vpath: }</span>(n$1162); MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(n$1161); MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(x) ;
    x = n$1160 <span class='color_orange'>update:45</span>:node*; n = null <span class='color_orange'>update:40</span>:node*; t = n$1163 <span class='color_orange'>update:53</span>:node*; #GB<src.c>$head = n$1162 <span class='color_orange'>update:38</span>:node*; i = (@f$0 + 1) <span class='color_orange'>update:43</span>:int; return = n$1165 <span class='color_orange'>initial</span>:int ;
    n$1162|->{next:t <span class='color_orange'>update:56</span>, v:n$1164 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16; n$1161|->{next:null <span class='color_orange'>update:46</span>, v:@f$0 <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16; x|->{next:null <span class='color_orange'>update:46</span>, v:(@f$0 + 1) <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16; lseg(t,n$1161,[],P0)
    [footprint
       (@f$0  &lt;=  8); @f$2 != 0 *
       #GB<src.c>$head = @f$1 <span class='color_orange'>rearrange:38</span>:node*  ]
    where
    P0 = exists [_t$2]. _t$0|->{next:_t$1 <span class='color_orange'>update:56</span>, v:_t$2 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16</span>
    
    in prop_iter_extend_ptsto lexp: &amp;t
    prop before:
    <span class='color_blue'>(@f$0  &lt;=  8); t != 0; MEMma &lt; malloc:38 &gt;  <span class='color_orange'>{vpath: }</span>(n$1162); MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(n$1161); MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(x) ;
    x = n$1160 <span class='color_orange'>update:45</span>:node*; n = null <span class='color_orange'>update:40</span>:node*; t = n$1163 <span class='color_orange'>update:53</span>:node*; #GB<src.c>$head = n$1162 <span class='color_orange'>update:38</span>:node*; i = (@f$0 + 1) <span class='color_orange'>update:43</span>:int; return = n$1165 <span class='color_orange'>initial</span>:int ;
    n$1162|->{next:t <span class='color_orange'>update:56</span>, v:n$1164 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16; n$1161|->{next:null <span class='color_orange'>update:46</span>, v:@f$0 <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16; x|->{next:null <span class='color_orange'>update:46</span>, v:(@f$0 + 1) <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16; lseg(t,n$1161,[],P0)
    [footprint
       (@f$0  &lt;=  8); @f$2 != 0 *
       #GB<src.c>$head = @f$1 <span class='color_orange'>rearrange:38</span>:node*  ]
    where
    P0 = exists [_t$2]. _t$0|->{next:_t$1 <span class='color_orange'>update:56</span>, v:_t$2 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16</span>
    
    
    prop list after:
    PROP 1 of 1:
    <span class='color_blue'><span class='color_blue'>(@f$0  &lt;=  8)</span>; <span class='color_blue'>t != 0</span>; <span class='color_blue'>MEMma &lt; malloc:38 &gt;  <span class='color_orange'>{vpath: }</span>(n$1162)</span>; <span class='color_blue'>MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(n$1161)</span>; <span class='color_blue'>MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(x)</span> ;
    <span class='color_blue'>x = n$1160 <span class='color_orange'>update:45</span>:node*</span>; <span class='color_blue'>n = null <span class='color_orange'>update:40</span>:node*</span>; <span class='color_blue'>t = n$1163 <span class='color_orange'>update:53</span>:node*</span>; <span class='color_blue'>#GB<src.c>$head = n$1162 <span class='color_orange'>update:38</span>:node*</span>; <span class='color_blue'>i = (@f$0 + 1) <span class='color_orange'>update:43</span>:int</span>; <span class='color_blue'>return = n$1165 <span class='color_orange'>initial</span>:int</span> ;
    <span class='color_blue'>n$1162|->{next:t <span class='color_orange'>update:56</span>, v:n$1164 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16</span>; <span class='color_blue'>n$1161|->{next:null <span class='color_orange'>update:46</span>, v:@f$0 <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16</span>; <span class='color_blue'>x|->{next:null <span class='color_orange'>update:46</span>, v:(@f$0 + 1) <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16</span>; <span class='color_blue'>lseg(t,n$1161,[],P0)</span>
    [footprint
       <span class='color_blue'>(@f$0  &lt;=  8)</span>; <span class='color_blue'>@f$2 != 0</span> *
       <span class='color_blue'>#GB<src.c>$head = @f$1 <span class='color_orange'>rearrange:38</span>:node*</span>  ]
    where
    P0 = exists [_t$2]. <span class='color_blue'>_t$0|->{next:_t$1 <span class='color_orange'>update:56</span>, v:_t$2 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16</span></span>
    
    
    
    Instruction Returns
    PROP 1 of 1:
    <span class='color_blue'><span class='color_blue'>(@f$0  &lt;=  8)</span>; <span class='color_red'>t != 0</span>; <span class='color_blue'>MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(x)</span>; <span class='color_red'>MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(_t$3)</span>; <span class='color_blue'>MEMma &lt; malloc:38 &gt;  <span class='color_orange'>{vpath: }</span>(_t$1)</span> ;
    <span class='color_blue'>x = <span class='color_red'>_t$4 <span class='color_orange'>update:45</span></span>:node*</span>; <span class='color_blue'>n = null <span class='color_orange'>update:40</span>:node*</span>; <span class='color_blue'>t = <span class='color_red'>n$17 <span class='color_orange'>update:53</span></span>:node*</span>; <span class='color_blue'>#GB<src.c>$head = _t$1 <span class='color_orange'>update:38</span>:node*</span>; <span class='color_blue'>i = (@f$0 + 1) <span class='color_orange'>update:43</span>:int</span>; <span class='color_blue'>return = _t$0 <span class='color_orange'>initial</span>:int</span> ;
    <span class='color_blue'>x|->{next:null <span class='color_orange'>update:46</span>, v:<span class='color_red'>(@f$0 + 1) <span class='color_orange'>update:47</span></span>} <span class='color_orange'>alloc</span>:node16</span>; <span class='color_red'>_t$3|->{next:null <span class='color_orange'>update:46</span>, v:@f$0 <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16</span>; <span class='color_blue'>_t$1|->{next:<span class='color_red'>t <span class='color_orange'>update:56</span></span>, v:<span class='color_red'>_t$2 <span class='color_orange'>alloc</span></span>} <span class='color_orange'>alloc</span>:node16</span>; <span class='color_red'>lseg(t,_t$3,[],P0)</span>
    [footprint
       <span class='color_blue'>(@f$0  &lt;=  8)</span>; <span class='color_blue'>@f$2 != 0</span> *
       <span class='color_blue'>#GB<src.c>$head = @f$1 <span class='color_orange'>rearrange:38</span>:node*</span>  ]
    where
    P0 = exists [_t$2]. <span class='color_blue'>_t$0|->{next:_t$1 <span class='color_orange'>update:56</span>, v:_t$2 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16</span></span>
    
    Instruction <span class='color_green'>n$18=*n$17.v:int [line 54, column 21]</span>
    in vpath_find exp:n$1168
    vpath_find: found head : node*
    in vpath_find exp:n$1167
    vpath_find: cannot find n$1167
    in vpath_find exp:n$1166
    vpath_find: found x : node*
    .... Rearrangement Start ....
    Exp: n$17.v
    Prop: 
    <span class='color_blue'>(@f$0  &lt;=  8); t != 0; MEMma &lt; malloc:38 &gt;  <span class='color_orange'>{vpath: }</span>(n$1168); MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(n$1167); MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(x) ;
    x = n$1166 <span class='color_orange'>update:45</span>:node*; n = null <span class='color_orange'>update:40</span>:node*; t = n$17 <span class='color_orange'>update:53</span>:node*; #GB<src.c>$head = n$1168 <span class='color_orange'>update:38</span>:node*; i = (@f$0 + 1) <span class='color_orange'>update:43</span>:int; return = n$1170 <span class='color_orange'>initial</span>:int ;
    n$1168|->{next:t <span class='color_orange'>update:56</span>, v:n$1169 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16; n$1167|->{next:null <span class='color_orange'>update:46</span>, v:@f$0 <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16; x|->{next:null <span class='color_orange'>update:46</span>, v:(@f$0 + 1) <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16; lseg(t,n$1167,[],P0)
    [footprint
       (@f$0  &lt;=  8); @f$2 != 0 *
       #GB<src.c>$head = @f$1 <span class='color_orange'>rearrange:38</span>:node*  ]
    where
    P0 = exists [_t$2]. _t$0|->{next:_t$1 <span class='color_orange'>update:56</span>, v:_t$2 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16</span>
    
    in prop_iter_extend_ptsto lexp: n$17.v
    prop before:
    <span class='color_blue'>(@f$0  &lt;=  8); t != 0; MEMma &lt; malloc:38 &gt;  <span class='color_orange'>{vpath: }</span>(n$1168); MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(n$1167); MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(x) ;
    x = n$1166 <span class='color_orange'>update:45</span>:node*; n = null <span class='color_orange'>update:40</span>:node*; t = n$17 <span class='color_orange'>update:53</span>:node*; #GB<src.c>$head = n$1168 <span class='color_orange'>update:38</span>:node*; i = (@f$0 + 1) <span class='color_orange'>update:43</span>:int; return = n$1170 <span class='color_orange'>initial</span>:int ;
    n$1168|->{next:t <span class='color_orange'>update:56</span>, v:n$1169 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16; n$1167|->{next:null <span class='color_orange'>update:46</span>, v:@f$0 <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16; x|->{next:null <span class='color_orange'>update:46</span>, v:(@f$0 + 1) <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16; t|->{next:_t$1965 <span class='color_orange'>update:56</span>, v:_t$1966 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16; lseg(_t$1965,n$1167,[],P0)
    [footprint
       (@f$0  &lt;=  8); @f$2 != 0 *
       #GB<src.c>$head = @f$1 <span class='color_orange'>rearrange:38</span>:node*  ]
    where
    P0 = exists [_t$2]. _t$0|->{next:_t$1 <span class='color_orange'>update:56</span>, v:_t$2 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16</span>
    
    
    prop list after:
    PROP 1 of 1:
    <span class='color_blue'><span class='color_blue'>(@f$0  &lt;=  8)</span>; <span class='color_blue'>t != 0</span>; <span class='color_blue'>MEMma &lt; malloc:38 &gt;  <span class='color_orange'>{vpath: }</span>(n$1168)</span>; <span class='color_blue'>MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(n$1167)</span>; <span class='color_blue'>MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(x)</span> ;
    <span class='color_blue'>x = n$1166 <span class='color_orange'>update:45</span>:node*</span>; <span class='color_blue'>n = null <span class='color_orange'>update:40</span>:node*</span>; <span class='color_blue'>t = n$17 <span class='color_orange'>update:53</span>:node*</span>; <span class='color_blue'>#GB<src.c>$head = n$1168 <span class='color_orange'>update:38</span>:node*</span>; <span class='color_blue'>i = (@f$0 + 1) <span class='color_orange'>update:43</span>:int</span>; <span class='color_blue'>return = n$1170 <span class='color_orange'>initial</span>:int</span> ;
    <span class='color_blue'>n$1168|->{next:t <span class='color_orange'>update:56</span>, v:n$1169 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16</span>; <span class='color_blue'>n$1167|->{next:null <span class='color_orange'>update:46</span>, v:@f$0 <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16</span>; <span class='color_blue'>x|->{next:null <span class='color_orange'>update:46</span>, v:(@f$0 + 1) <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16</span>; <span class='color_blue'>t|->{next:_t$1965 <span class='color_orange'>update:56</span>, v:_t$1966 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16</span>; <span class='color_blue'>lseg(_t$1965,n$1167,[],P0)</span>
    [footprint
       <span class='color_blue'>(@f$0  &lt;=  8)</span>; <span class='color_blue'>@f$2 != 0</span> *
       <span class='color_blue'>#GB<src.c>$head = @f$1 <span class='color_orange'>rearrange:38</span>:node*</span>  ]
    where
    P0 = exists [_t$2]. <span class='color_blue'>_t$0|->{next:_t$1 <span class='color_orange'>update:56</span>, v:_t$2 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16</span></span>
    
    
    
    in prop_iter_extend_ptsto lexp: n$17.v
    prop before:
    <span class='color_blue'>n$1167 = t ;
    (@f$0  &lt;=  8); t != 0; MEMma &lt; malloc:38 &gt;  <span class='color_orange'>{vpath: }</span>(n$1168); MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(x); MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(t) ;
    x = n$1166 <span class='color_orange'>update:45</span>:node*; n = null <span class='color_orange'>update:40</span>:node*; t = n$17 <span class='color_orange'>update:53</span>:node*; #GB<src.c>$head = n$1168 <span class='color_orange'>update:38</span>:node*; i = (@f$0 + 1) <span class='color_orange'>update:43</span>:int; return = n$1170 <span class='color_orange'>initial</span>:int ;
    n$1168|->{next:t <span class='color_orange'>update:56</span>, v:n$1169 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16; x|->{next:null <span class='color_orange'>update:46</span>, v:(@f$0 + 1) <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16; t|->{next:null <span class='color_orange'>update:46</span>, v:@f$0 <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16
    [footprint
       n$1167 = t; (@f$0  &lt;=  8); @f$2 != 0 *
       #GB<src.c>$head = @f$1 <span class='color_orange'>rearrange:38</span>:node*  ]</span>
    
    
    prop list after:
    PROP 1 of 1:
    <span class='color_blue'><span class='color_blue'>n$1167 = t</span> ;
    <span class='color_blue'>(@f$0  &lt;=  8)</span>; <span class='color_blue'>t != 0</span>; <span class='color_blue'>MEMma &lt; malloc:38 &gt;  <span class='color_orange'>{vpath: }</span>(n$1168)</span>; <span class='color_blue'>MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(x)</span>; <span class='color_blue'>MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(t)</span> ;
    <span class='color_blue'>x = n$1166 <span class='color_orange'>update:45</span>:node*</span>; <span class='color_blue'>n = null <span class='color_orange'>update:40</span>:node*</span>; <span class='color_blue'>t = n$17 <span class='color_orange'>update:53</span>:node*</span>; <span class='color_blue'>#GB<src.c>$head = n$1168 <span class='color_orange'>update:38</span>:node*</span>; <span class='color_blue'>i = (@f$0 + 1) <span class='color_orange'>update:43</span>:int</span>; <span class='color_blue'>return = n$1170 <span class='color_orange'>initial</span>:int</span> ;
    <span class='color_blue'>n$1168|->{next:t <span class='color_orange'>update:56</span>, v:n$1169 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16</span>; <span class='color_blue'>x|->{next:null <span class='color_orange'>update:46</span>, v:(@f$0 + 1) <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16</span>; <span class='color_blue'>t|->{next:null <span class='color_orange'>update:46</span>, v:@f$0 <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16</span>
    [footprint
       <span class='color_blue'>n$1167 = t</span>; <span class='color_blue'>(@f$0  &lt;=  8)</span>; <span class='color_blue'>@f$2 != 0</span> *
       <span class='color_blue'>#GB<src.c>$head = @f$1 <span class='color_orange'>rearrange:38</span>:node*</span>  ]</span>
    
    
    
    Instruction Returns
    PROP 1 of 2:
    <span class='color_blue'><span class='color_blue'>(@f$0  &lt;=  8)</span>; <span class='color_blue'>t != 0</span>; <span class='color_red'>MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(x)</span>; <span class='color_blue'>MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(_t$4)</span>; <span class='color_blue'>MEMma &lt; malloc:38 &gt;  <span class='color_orange'>{vpath: }</span>(_t$1)</span>; <span class='color_red'>DANGL &lt; UNINIT &gt; (n$18)</span> ;
    <span class='color_blue'>x = <span class='color_red'>_t$5 <span class='color_orange'>update:45</span></span>:node*</span>; <span class='color_blue'>n = null <span class='color_orange'>update:40</span>:node*</span>; <span class='color_blue'>t = n$17 <span class='color_orange'>update:53</span>:node*</span>; <span class='color_blue'>#GB<src.c>$head = _t$1 <span class='color_orange'>update:38</span>:node*</span>; <span class='color_blue'>i = (@f$0 + 1) <span class='color_orange'>update:43</span>:int</span>; <span class='color_blue'>return = _t$0 <span class='color_orange'>initial</span>:int</span> ;
    <span class='color_red'>x|->{next:null <span class='color_orange'>update:46</span>, v:(@f$0 + 1) <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16</span>; <span class='color_blue'>_t$4|->{next:null <span class='color_orange'>update:46</span>, v:<span class='color_red'>@f$0 <span class='color_orange'>update:47</span></span>} <span class='color_orange'>alloc</span>:node16</span>; <span class='color_blue'>_t$1|->{next:t <span class='color_orange'>update:56</span>, v:_t$2 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16</span>; <span class='color_blue'>t|->{next:_t$3 <span class='color_orange'>update:56</span>, v:n$18 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16</span>; <span class='color_blue'>lseg(_t$3,_t$4,[],P0)</span>
    [footprint
       <span class='color_blue'>(@f$0  &lt;=  8)</span>; <span class='color_blue'>@f$2 != 0</span> *
       <span class='color_blue'>#GB<src.c>$head = @f$1 <span class='color_orange'>rearrange:38</span>:node*</span>  ]
    where
    P0 = exists [_t$2]. <span class='color_blue'>_t$0|->{next:_t$1 <span class='color_orange'>update:56</span>, v:_t$2 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16</span></span>
    PROP 2 of 2:
    <span class='color_blue'><span class='color_red'>n$18 = @f$0</span> ;
    <span class='color_blue'>(@f$0  &lt;=  8)</span>; <span class='color_blue'>t != 0</span>; <span class='color_blue'>MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(x)</span>; <span class='color_blue'>MEMma &lt; malloc:38 &gt;  <span class='color_orange'>{vpath: }</span>(_t$1)</span>; <span class='color_blue'>MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(t)</span> ;
    <span class='color_blue'>x = <span class='color_red'>_t$3 <span class='color_orange'>update:45</span></span>:node*</span>; <span class='color_blue'>n = null <span class='color_orange'>update:40</span>:node*</span>; <span class='color_blue'>t = n$17 <span class='color_orange'>update:53</span>:node*</span>; <span class='color_blue'>#GB<src.c>$head = _t$1 <span class='color_orange'>update:38</span>:node*</span>; <span class='color_blue'>i = (@f$0 + 1) <span class='color_orange'>update:43</span>:int</span>; <span class='color_blue'>return = _t$0 <span class='color_orange'>initial</span>:int</span> ;
    <span class='color_blue'>x|->{next:null <span class='color_orange'>update:46</span>, v:<span class='color_red'>(@f$0 + 1) <span class='color_orange'>update:47</span></span>} <span class='color_orange'>alloc</span>:node16</span>; <span class='color_blue'>_t$1|->{next:t <span class='color_orange'>update:56</span>, v:_t$2 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16</span>; <span class='color_blue'>t|->{next:null <span class='color_orange'>update:46</span>, v:@f$0 <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16</span>
    [footprint
       <span class='color_red'>t = @f$2</span>; <span class='color_blue'>(@f$0  &lt;=  8)</span>; <span class='color_red'>@f$3 != 0</span> *
       <span class='color_blue'>#GB<src.c>$head = @f$1 <span class='color_orange'>rearrange:38</span>:node*</span>  ]</span>
    
    Instruction <span class='color_green'>n$19=_fun_printf("%d\n":char const *,n$18:int) [line 54, column 7]</span>
    in vpath_find exp:n$1173
    vpath_find: found head : node*
    in vpath_find exp:n$1172
    vpath_find: cannot find n$1172
    in vpath_find exp:n$1171
    vpath_find: found x : node*
    <span class='color_orange'>WARNING: likely use of variable-arguments function, or function prototype missing</span>
    actual parameters: n$18
    formal parameters: 
    Found 1 specs for function printf
    START EXECUTING SPECS FOR printf from state
    <span class='color_blue'>(@f$0  &lt;=  8); t != 0; MEMma &lt; malloc:38 &gt;  <span class='color_orange'>{vpath: }</span>(n$1173); MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(n$1172); MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(x); DANGL &lt; UNINIT &gt; (n$18) ;
    x = n$1171 <span class='color_orange'>update:45</span>:node*; n = null <span class='color_orange'>update:40</span>:node*; t = n$17 <span class='color_orange'>update:53</span>:node*; #GB<src.c>$head = n$1173 <span class='color_orange'>update:38</span>:node*; i = (@f$0 + 1) <span class='color_orange'>update:43</span>:int; return = n$1176 <span class='color_orange'>initial</span>:int ;
    n$1173|->{next:t <span class='color_orange'>update:56</span>, v:n$1174 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16; n$1172|->{next:null <span class='color_orange'>update:46</span>, v:@f$0 <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16; x|->{next:null <span class='color_orange'>update:46</span>, v:(@f$0 + 1) <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16; t|->{next:n$1175 <span class='color_orange'>update:56</span>, v:n$18 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16; lseg(n$1175,n$1172,[],P0)
    [footprint
       (@f$0  &lt;=  8); @f$2 != 0 *
       #GB<src.c>$head = @f$1 <span class='color_orange'>rearrange:38</span>:node*  ]
    where
    P0 = exists [_t$2]. _t$0|->{next:_t$1 <span class='color_orange'>update:56</span>, v:_t$2 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16</span>
    <span class='color_orange'>WARNING: more actual pars than formal pars in fun call (2 vs 1)</span>
    EXECUTING SPEC 1/1
    ACTUAL PRECONDITION =
      <span class='color_blue'>(@f$0  &lt;=  8); t != 0; MEMma &lt; malloc:38 &gt;  <span class='color_orange'>{vpath: }</span>(n$1173); MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(n$1172); MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(x); DANGL &lt; UNINIT &gt; (n$18) ;
      x = n$1171 <span class='color_orange'>update:45</span>:node*; n = null <span class='color_orange'>update:40</span>:node*; t = n$17 <span class='color_orange'>update:53</span>:node*; #GB<src.c>$head = n$1173 <span class='color_orange'>update:38</span>:node*; i = (@f$0 + 1) <span class='color_orange'>update:43</span>:int; format|callee = "%d\n" <span class='color_orange'>actual_precondition</span>:char const *; return = n$1176 <span class='color_orange'>initial</span>:int ;
      n$1173|->{next:t <span class='color_orange'>update:56</span>, v:n$1174 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16; n$1172|->{next:null <span class='color_orange'>update:46</span>, v:@f$0 <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16; x|->{next:null <span class='color_orange'>update:46</span>, v:(@f$0 + 1) <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16; t|->{next:n$1175 <span class='color_orange'>update:56</span>, v:n$18 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16; lseg(n$1175,n$1172,[],P0)
      [footprint
         (@f$0  &lt;=  8); @f$2 != 0 *
         #GB<src.c>$head = @f$1 <span class='color_orange'>rearrange:38</span>:node*  ]
      where
      P0 = exists [_t$2]. _t$0|->{next:_t$1 <span class='color_orange'>update:56</span>, v:_t$2 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16</span>
    SPEC =
      --------------------------- ---------- ---------------------------
      PRE:
      <span class='color_blue'><span class='color_blue'>format|callee = _t$1979 <span class='color_orange'>formal</span>:char const *</span></span>
      POST 1 of 1:
      <span class='color_blue'><span class='color_red'>(-1  &lt;  _t$1980)</span>; <span class='color_red'>DANGL &lt; UNINIT &gt; (return|callee)</span> ;
      <span class='color_red'>return|callee = _t$1980 <span class='color_orange'>update:1114</span>:int</span></span>
      ----------------------------------------------------------------
    pre_check_pure_implication
    pi1:
      (@f$0  &lt;=  8); n$17 != 0; MEMma &lt; malloc:38 &gt;  <span class='color_orange'>{vpath: }</span>(n$1173); MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(n$1172); MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(n$1171); DANGL &lt; UNINIT &gt; (n$18)
    pi2:
      
    returns
    sub1: 
      
    sub2: 
      
    Current Implication
    SUB:
      
    <span class='color_blue'>(@f$0  &lt;=  8); t != 0; MEMma &lt; malloc:38 &gt;  <span class='color_orange'>{vpath: }</span>(n$1173); MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(n$1172); MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(x); DANGL &lt; UNINIT &gt; (n$18) ;
    x = n$1171 <span class='color_orange'>update:45</span>:node*; n = null <span class='color_orange'>update:40</span>:node*; t = n$17 <span class='color_orange'>update:53</span>:node*; #GB<src.c>$head = n$1173 <span class='color_orange'>update:38</span>:node*; i = (@f$0 + 1) <span class='color_orange'>update:43</span>:int; format|callee = "%d\n" <span class='color_orange'>actual_precondition</span>:char const *; return = n$1176 <span class='color_orange'>initial</span>:int ;
    n$1173|->{next:t <span class='color_orange'>update:56</span>, v:n$1174 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16; n$1172|->{next:null <span class='color_orange'>update:46</span>, v:@f$0 <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16; x|->{next:null <span class='color_orange'>update:46</span>, v:(@f$0 + 1) <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16; t|->{next:n$1175 <span class='color_orange'>update:56</span>, v:n$18 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16; lseg(n$1175,n$1172,[],P0)
    [footprint
       (@f$0  &lt;=  8); @f$2 != 0 *
       #GB<src.c>$head = @f$1 <span class='color_orange'>rearrange:38</span>:node*  ]
    where
    P0 = exists [_t$2]. _t$0|->{next:_t$1 <span class='color_orange'>update:56</span>, v:_t$2 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16</span>
    |-
    <span class='color_blue'>format|callee = _t$1979 <span class='color_orange'>formal</span>:char const *</span>
    
      do_imply "%d\n" _t$1979
        Final Implication
        SUB:
          
        <span class='color_blue'>(@f$0  &lt;=  8); t != 0; MEMma &lt; malloc:38 &gt;  <span class='color_orange'>{vpath: }</span>(n$1173); MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(n$1172); MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(x); DANGL &lt; UNINIT &gt; (n$18) ;
        x = n$1171 <span class='color_orange'>update:45</span>:node*; n = null <span class='color_orange'>update:40</span>:node*; t = n$17 <span class='color_orange'>update:53</span>:node*; #GB<src.c>$head = n$1173 <span class='color_orange'>update:38</span>:node*; i = (@f$0 + 1) <span class='color_orange'>update:43</span>:int; return = n$1176 <span class='color_orange'>initial</span>:int ;
        n$1173|->{next:t <span class='color_orange'>update:56</span>, v:n$1174 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16; n$1172|->{next:null <span class='color_orange'>update:46</span>, v:@f$0 <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16; x|->{next:null <span class='color_orange'>update:46</span>, v:(@f$0 + 1) <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16; t|->{next:n$1175 <span class='color_orange'>update:56</span>, v:n$18 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16; lseg(n$1175,n$1172,[],P0)
        [footprint
           (@f$0  &lt;=  8); @f$2 != 0 *
           #GB<src.c>$head = @f$1 <span class='color_orange'>rearrange:38</span>:node*  ]
        where
        P0 = exists [_t$2]. _t$0|->{next:_t$1 <span class='color_orange'>update:56</span>, v:_t$2 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16</span>
        [SUB: 
          _t$1979 = "%d\n"]
        |-
        <span class='color_blue'></span>
    Result of Abduction
      SUB:
        
      <span class='color_blue'>(@f$0  &lt;=  8); t != 0; MEMma &lt; malloc:38 &gt;  <span class='color_orange'>{vpath: }</span>(n$1173); MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(n$1172); MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(x); DANGL &lt; UNINIT &gt; (n$18) ;
      x = n$1171 <span class='color_orange'>update:45</span>:node*; n = null <span class='color_orange'>update:40</span>:node*; t = n$17 <span class='color_orange'>update:53</span>:node*; #GB<src.c>$head = n$1173 <span class='color_orange'>update:38</span>:node*; i = (@f$0 + 1) <span class='color_orange'>update:43</span>:int; format|callee = "%d\n" <span class='color_orange'>actual_precondition</span>:char const *; return = n$1176 <span class='color_orange'>initial</span>:int ;
      n$1173|->{next:t <span class='color_orange'>update:56</span>, v:n$1174 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16; n$1172|->{next:null <span class='color_orange'>update:46</span>, v:@f$0 <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16; x|->{next:null <span class='color_orange'>update:46</span>, v:(@f$0 + 1) <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16; t|->{next:n$1175 <span class='color_orange'>update:56</span>, v:n$18 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16; lseg(n$1175,n$1172,[],P0)
      [footprint
         (@f$0  &lt;=  8); @f$2 != 0 *
         #GB<src.c>$head = @f$1 <span class='color_orange'>rearrange:38</span>:node*  ]
      where
      P0 = exists [_t$2]. _t$0|->{next:_t$1 <span class='color_orange'>update:56</span>, v:_t$2 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16</span>
      [SUB: 
        _t$1979 = "%d\n"]
      |-
      <span class='color_blue'>format|callee = "%d\n" <span class='color_orange'>formal</span>:char const *</span>
    returning TRUE
      New footprint:
      
      Frame fld:
      
      Missing fld:
      
      Instantiated frame:
      n$1173|->{next:n$17 <span class='color_orange'>update:56</span>, v:n$1174 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16; n$1172|->{next:null <span class='color_orange'>update:46</span>, v:@f$0 <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16; n$1171|->{next:null <span class='color_orange'>update:46</span>, v:(@f$0 + 1) <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16; n$17|->{next:n$1175 <span class='color_orange'>update:56</span>, v:n$18 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16; &amp;x|->n$1171 <span class='color_orange'>update:45</span>:node*; &amp;n|->null <span class='color_orange'>update:40</span>:node*; &amp;t|->n$17 <span class='color_orange'>update:53</span>:node*; &amp;#GB<src.c>$head|->n$1173 <span class='color_orange'>update:38</span>:node*; &amp;i|->(@f$0 + 1) <span class='color_orange'>update:43</span>:int; &amp;return|->n$1176 <span class='color_orange'>initial</span>:int; lseg(n$1175,n$1172,[],lam [_t$0,_t$1,]. exists [_t$2]. _t$0|->{next:_t$1 <span class='color_orange'>update:56</span>, v:_t$2 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16)
      Instantiated post:
      PROP 1 of 1:
      <span class='color_blue'><span class='color_red'>(-1  &lt;  _t$1980)</span>; <span class='color_red'>DANGL &lt; UNINIT &gt; (return|callee)</span> ;
      <span class='color_red'>return|callee = _t$1980 <span class='color_orange'>update:54</span>:int</span></span>
      
    ***** RESULTS FUNCTION CALL *******
    PROP 1 of 1:
    <span class='color_blue'><span class='color_red'>(-1  &lt;  n$19)</span>; <span class='color_blue'>(@f$0  &lt;=  8)</span>; <span class='color_blue'>t != 0</span>; <span class='color_blue'>MEMma &lt; malloc:38 &gt;  <span class='color_orange'>{vpath: }</span>(n$1173)</span>; <span class='color_blue'>MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(n$1172)</span>; <span class='color_blue'>MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(x)</span>; <span class='color_red'>DANGL &lt; UNINIT &gt; (n$19)</span>; <span class='color_blue'>DANGL &lt; UNINIT &gt; (n$18)</span> ;
    <span class='color_blue'>x = n$1171 <span class='color_orange'>update:45</span>:node*</span>; <span class='color_blue'>n = null <span class='color_orange'>update:40</span>:node*</span>; <span class='color_blue'>t = n$17 <span class='color_orange'>update:53</span>:node*</span>; <span class='color_blue'>#GB<src.c>$head = n$1173 <span class='color_orange'>update:38</span>:node*</span>; <span class='color_blue'>i = (@f$0 + 1) <span class='color_orange'>update:43</span>:int</span>; <span class='color_blue'>return = n$1176 <span class='color_orange'>initial</span>:int</span> ;
    <span class='color_blue'>n$1173|->{next:t <span class='color_orange'>update:56</span>, v:n$1174 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16</span>; <span class='color_blue'>n$1172|->{next:null <span class='color_orange'>update:46</span>, v:@f$0 <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16</span>; <span class='color_blue'>x|->{next:null <span class='color_orange'>update:46</span>, v:(@f$0 + 1) <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16</span>; <span class='color_blue'>t|->{next:n$1175 <span class='color_orange'>update:56</span>, v:n$18 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16</span>; <span class='color_blue'>lseg(n$1175,n$1172,[],P0)</span>
    [footprint
       <span class='color_blue'>(@f$0  &lt;=  8)</span>; <span class='color_blue'>@f$2 != 0</span> *
       <span class='color_blue'>#GB<src.c>$head = @f$1 <span class='color_orange'>rearrange:38</span>:node*</span>  ]
    where
    P0 = exists [_t$2]. <span class='color_blue'>_t$0|->{next:_t$1 <span class='color_orange'>update:56</span>, v:_t$2 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16</span></span>
    ***** END RESULTS FUNCTION CALL *******
    Instruction Returns
    PROP 1 of 1:
    <span class='color_blue'><span class='color_red'>(-1  &lt;  n$19)</span>; <span class='color_blue'>(@f$0  &lt;=  8)</span>; <span class='color_blue'>t != 0</span>; <span class='color_blue'>MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(x)</span>; <span class='color_blue'>MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(_t$4)</span>; <span class='color_blue'>MEMma &lt; malloc:38 &gt;  <span class='color_orange'>{vpath: }</span>(_t$1)</span>; <span class='color_red'>DANGL &lt; UNINIT &gt; (n$19)</span>; <span class='color_blue'>DANGL &lt; UNINIT &gt; (n$18)</span> ;
    <span class='color_blue'>x = _t$5 <span class='color_orange'>update:45</span>:node*</span>; <span class='color_blue'>n = null <span class='color_orange'>update:40</span>:node*</span>; <span class='color_blue'>t = n$17 <span class='color_orange'>update:53</span>:node*</span>; <span class='color_blue'>#GB<src.c>$head = _t$1 <span class='color_orange'>update:38</span>:node*</span>; <span class='color_blue'>i = (@f$0 + 1) <span class='color_orange'>update:43</span>:int</span>; <span class='color_blue'>return = _t$0 <span class='color_orange'>initial</span>:int</span> ;
    <span class='color_blue'>x|->{next:null <span class='color_orange'>update:46</span>, v:(@f$0 + 1) <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16</span>; <span class='color_blue'>_t$4|->{next:null <span class='color_orange'>update:46</span>, v:@f$0 <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16</span>; <span class='color_blue'>_t$1|->{next:t <span class='color_orange'>update:56</span>, v:_t$2 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16</span>; <span class='color_blue'>t|->{next:_t$3 <span class='color_orange'>update:56</span>, v:n$18 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16</span>; <span class='color_blue'>lseg(_t$3,_t$4,[],P0)</span>
    [footprint
       <span class='color_blue'>(@f$0  &lt;=  8)</span>; <span class='color_blue'>@f$2 != 0</span> *
       <span class='color_blue'>#GB<src.c>$head = @f$1 <span class='color_orange'>rearrange:38</span>:node*</span>  ]
    where
    P0 = exists [_t$2]. <span class='color_blue'>_t$0|->{next:_t$1 <span class='color_orange'>update:56</span>, v:_t$2 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16</span></span>
    
    Instruction <span class='color_green'>n$19=_fun_printf("%d\n":char const *,n$18:int) [line 54, column 7]</span>
    in vpath_find exp:n$1178
    vpath_find: found head : node*
    in vpath_find exp:n$1177
    vpath_find: found x : node*
    in vpath_find exp:n$17
    vpath_find: found head->next : node*
    <span class='color_orange'>WARNING: likely use of variable-arguments function, or function prototype missing</span>
    actual parameters: @f$0
    formal parameters: 
    Found 1 specs for function printf
    START EXECUTING SPECS FOR printf from state
    <span class='color_blue'>n$18 = @f$0 ;
    (@f$0  &lt;=  8); t != 0; MEMma &lt; malloc:38 &gt;  <span class='color_orange'>{vpath: }</span>(n$1178); MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(x); MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(t) ;
    x = n$1177 <span class='color_orange'>update:45</span>:node*; n = null <span class='color_orange'>update:40</span>:node*; t = n$17 <span class='color_orange'>update:53</span>:node*; #GB<src.c>$head = n$1178 <span class='color_orange'>update:38</span>:node*; i = (@f$0 + 1) <span class='color_orange'>update:43</span>:int; return = n$1180 <span class='color_orange'>initial</span>:int ;
    n$1178|->{next:t <span class='color_orange'>update:56</span>, v:n$1179 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16; x|->{next:null <span class='color_orange'>update:46</span>, v:(@f$0 + 1) <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16; t|->{next:null <span class='color_orange'>update:46</span>, v:@f$0 <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16
    [footprint
       t = @f$2; (@f$0  &lt;=  8); @f$3 != 0 *
       #GB<src.c>$head = @f$1 <span class='color_orange'>rearrange:38</span>:node*  ]</span>
    <span class='color_orange'>WARNING: more actual pars than formal pars in fun call (2 vs 1)</span>
    EXECUTING SPEC 1/1
    ACTUAL PRECONDITION =
      <span class='color_blue'>n$18 = @f$0 ;
      (@f$0  &lt;=  8); t != 0; MEMma &lt; malloc:38 &gt;  <span class='color_orange'>{vpath: }</span>(n$1178); MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(x); MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(t) ;
      x = n$1177 <span class='color_orange'>update:45</span>:node*; n = null <span class='color_orange'>update:40</span>:node*; t = n$17 <span class='color_orange'>update:53</span>:node*; #GB<src.c>$head = n$1178 <span class='color_orange'>update:38</span>:node*; i = (@f$0 + 1) <span class='color_orange'>update:43</span>:int; format|callee = "%d\n" <span class='color_orange'>actual_precondition</span>:char const *; return = n$1180 <span class='color_orange'>initial</span>:int ;
      n$1178|->{next:t <span class='color_orange'>update:56</span>, v:n$1179 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16; x|->{next:null <span class='color_orange'>update:46</span>, v:(@f$0 + 1) <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16; t|->{next:null <span class='color_orange'>update:46</span>, v:@f$0 <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16
      [footprint
         t = @f$2; (@f$0  &lt;=  8); @f$3 != 0 *
         #GB<src.c>$head = @f$1 <span class='color_orange'>rearrange:38</span>:node*  ]</span>
    SPEC =
      --------------------------- ---------- ---------------------------
      PRE:
      <span class='color_blue'><span class='color_blue'>format|callee = _t$1987 <span class='color_orange'>formal</span>:char const *</span></span>
      POST 1 of 1:
      <span class='color_blue'><span class='color_red'>(-1  &lt;  _t$1988)</span>; <span class='color_red'>DANGL &lt; UNINIT &gt; (return|callee)</span> ;
      <span class='color_red'>return|callee = _t$1988 <span class='color_orange'>update:1114</span>:int</span></span>
      ----------------------------------------------------------------
    pre_check_pure_implication
    pi1:
      n$18 = @f$0; (@f$0  &lt;=  8); n$17 != 0; MEMma &lt; malloc:38 &gt;  <span class='color_orange'>{vpath: }</span>(n$1178); MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(n$1177); MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(n$17)
    pi2:
      
    returns
    sub1: 
      n$18 = @f$0
    sub2: 
      
    Current Implication
    SUB:
      n$18 = @f$0
    <span class='color_blue'>(@f$0  &lt;=  8); t != 0; MEMma &lt; malloc:38 &gt;  <span class='color_orange'>{vpath: }</span>(n$1178); MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(x); MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(t); @f$0 = @f$0 ;
    x = n$1177 <span class='color_orange'>update:45</span>:node*; n = null <span class='color_orange'>update:40</span>:node*; t = n$17 <span class='color_orange'>update:53</span>:node*; #GB<src.c>$head = n$1178 <span class='color_orange'>update:38</span>:node*; i = (@f$0 + 1) <span class='color_orange'>update:43</span>:int; format|callee = "%d\n" <span class='color_orange'>actual_precondition</span>:char const *; return = n$1180 <span class='color_orange'>initial</span>:int ;
    n$1178|->{next:t <span class='color_orange'>update:56</span>, v:n$1179 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16; x|->{next:null <span class='color_orange'>update:46</span>, v:(@f$0 + 1) <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16; t|->{next:null <span class='color_orange'>update:46</span>, v:@f$0 <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16
    [footprint
       t = @f$2; (@f$0  &lt;=  8); @f$3 != 0 *
       #GB<src.c>$head = @f$1 <span class='color_orange'>rearrange:38</span>:node*  ]</span>
    |-
    <span class='color_blue'>format|callee = _t$1987 <span class='color_orange'>formal</span>:char const *</span>
    
      do_imply "%d\n" _t$1987
        Final Implication
        SUB:
          n$18 = @f$0
        <span class='color_blue'>(@f$0  &lt;=  8); t != 0; MEMma &lt; malloc:38 &gt;  <span class='color_orange'>{vpath: }</span>(n$1178); MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(x); MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(t); @f$0 = @f$0 ;
        x = n$1177 <span class='color_orange'>update:45</span>:node*; n = null <span class='color_orange'>update:40</span>:node*; t = n$17 <span class='color_orange'>update:53</span>:node*; #GB<src.c>$head = n$1178 <span class='color_orange'>update:38</span>:node*; i = (@f$0 + 1) <span class='color_orange'>update:43</span>:int; return = n$1180 <span class='color_orange'>initial</span>:int ;
        n$1178|->{next:t <span class='color_orange'>update:56</span>, v:n$1179 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16; x|->{next:null <span class='color_orange'>update:46</span>, v:(@f$0 + 1) <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16; t|->{next:null <span class='color_orange'>update:46</span>, v:@f$0 <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16
        [footprint
           t = @f$2; (@f$0  &lt;=  8); @f$3 != 0 *
           #GB<src.c>$head = @f$1 <span class='color_orange'>rearrange:38</span>:node*  ]</span>
        [SUB: 
          _t$1987 = "%d\n"]
        |-
        <span class='color_blue'></span>
    Result of Abduction
      SUB:
        n$18 = @f$0
      <span class='color_blue'>(@f$0  &lt;=  8); t != 0; MEMma &lt; malloc:38 &gt;  <span class='color_orange'>{vpath: }</span>(n$1178); MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(x); MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(t); @f$0 = @f$0 ;
      x = n$1177 <span class='color_orange'>update:45</span>:node*; n = null <span class='color_orange'>update:40</span>:node*; t = n$17 <span class='color_orange'>update:53</span>:node*; #GB<src.c>$head = n$1178 <span class='color_orange'>update:38</span>:node*; i = (@f$0 + 1) <span class='color_orange'>update:43</span>:int; format|callee = "%d\n" <span class='color_orange'>actual_precondition</span>:char const *; return = n$1180 <span class='color_orange'>initial</span>:int ;
      n$1178|->{next:t <span class='color_orange'>update:56</span>, v:n$1179 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16; x|->{next:null <span class='color_orange'>update:46</span>, v:(@f$0 + 1) <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16; t|->{next:null <span class='color_orange'>update:46</span>, v:@f$0 <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16
      [footprint
         t = @f$2; (@f$0  &lt;=  8); @f$3 != 0 *
         #GB<src.c>$head = @f$1 <span class='color_orange'>rearrange:38</span>:node*  ]</span>
      [SUB: 
        _t$1987 = "%d\n"]
      |-
      <span class='color_blue'>format|callee = "%d\n" <span class='color_orange'>formal</span>:char const *</span>
    returning TRUE
      New footprint:
      
      Frame fld:
      
      Missing fld:
      
      Instantiated frame:
      n$1178|->{next:n$17 <span class='color_orange'>update:56</span>, v:n$1179 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16; n$1177|->{next:null <span class='color_orange'>update:46</span>, v:(@f$0 + 1) <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16; n$17|->{next:null <span class='color_orange'>update:46</span>, v:@f$0 <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16; &amp;x|->n$1177 <span class='color_orange'>update:45</span>:node*; &amp;n|->null <span class='color_orange'>update:40</span>:node*; &amp;t|->n$17 <span class='color_orange'>update:53</span>:node*; &amp;#GB<src.c>$head|->n$1178 <span class='color_orange'>update:38</span>:node*; &amp;i|->(@f$0 + 1) <span class='color_orange'>update:43</span>:int; &amp;return|->n$1180 <span class='color_orange'>initial</span>:int
      Instantiated post:
      PROP 1 of 1:
      <span class='color_blue'><span class='color_red'>(-1  &lt;  _t$1988)</span>; <span class='color_red'>DANGL &lt; UNINIT &gt; (return|callee)</span> ;
      <span class='color_red'>return|callee = _t$1988 <span class='color_orange'>update:54</span>:int</span></span>
      
    ***** RESULTS FUNCTION CALL *******
    PROP 1 of 1:
    <span class='color_blue'><span class='color_blue'>n$18 = @f$0</span> ;
    <span class='color_red'>(-1  &lt;  n$19)</span>; <span class='color_blue'>(@f$0  &lt;=  8)</span>; <span class='color_blue'>t != 0</span>; <span class='color_blue'>MEMma &lt; malloc:38 &gt;  <span class='color_orange'>{vpath: }</span>(n$1178)</span>; <span class='color_blue'>MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(x)</span>; <span class='color_blue'>MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(t)</span>; <span class='color_red'>DANGL &lt; UNINIT &gt; (n$19)</span> ;
    <span class='color_blue'>x = n$1177 <span class='color_orange'>update:45</span>:node*</span>; <span class='color_blue'>n = null <span class='color_orange'>update:40</span>:node*</span>; <span class='color_blue'>t = n$17 <span class='color_orange'>update:53</span>:node*</span>; <span class='color_blue'>#GB<src.c>$head = n$1178 <span class='color_orange'>update:38</span>:node*</span>; <span class='color_blue'>i = (@f$0 + 1) <span class='color_orange'>update:43</span>:int</span>; <span class='color_blue'>return = n$1180 <span class='color_orange'>initial</span>:int</span> ;
    <span class='color_blue'>n$1178|->{next:t <span class='color_orange'>update:56</span>, v:n$1179 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16</span>; <span class='color_blue'>x|->{next:null <span class='color_orange'>update:46</span>, v:(@f$0 + 1) <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16</span>; <span class='color_blue'>t|->{next:null <span class='color_orange'>update:46</span>, v:@f$0 <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16</span>
    [footprint
       <span class='color_blue'>t = @f$2</span>; <span class='color_blue'>(@f$0  &lt;=  8)</span>; <span class='color_blue'>@f$3 != 0</span> *
       <span class='color_blue'>#GB<src.c>$head = @f$1 <span class='color_orange'>rearrange:38</span>:node*</span>  ]</span>
    ***** END RESULTS FUNCTION CALL *******
    Instruction Returns
    PROP 1 of 1:
    <span class='color_blue'><span class='color_blue'>n$18 = @f$0</span> ;
    <span class='color_red'>(-1  &lt;  n$19)</span>; <span class='color_blue'>(@f$0  &lt;=  8)</span>; <span class='color_blue'>t != 0</span>; <span class='color_blue'>MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(x)</span>; <span class='color_blue'>MEMma &lt; malloc:38 &gt;  <span class='color_orange'>{vpath: }</span>(_t$1)</span>; <span class='color_blue'>MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(t)</span>; <span class='color_red'>DANGL &lt; UNINIT &gt; (n$19)</span> ;
    <span class='color_blue'>x = _t$3 <span class='color_orange'>update:45</span>:node*</span>; <span class='color_blue'>n = null <span class='color_orange'>update:40</span>:node*</span>; <span class='color_blue'>t = n$17 <span class='color_orange'>update:53</span>:node*</span>; <span class='color_blue'>#GB<src.c>$head = _t$1 <span class='color_orange'>update:38</span>:node*</span>; <span class='color_blue'>i = (@f$0 + 1) <span class='color_orange'>update:43</span>:int</span>; <span class='color_blue'>return = _t$0 <span class='color_orange'>initial</span>:int</span> ;
    <span class='color_blue'>x|->{next:null <span class='color_orange'>update:46</span>, v:(@f$0 + 1) <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16</span>; <span class='color_blue'>_t$1|->{next:t <span class='color_orange'>update:56</span>, v:_t$2 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16</span>; <span class='color_blue'>t|->{next:null <span class='color_orange'>update:46</span>, v:@f$0 <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16</span>
    [footprint
       <span class='color_blue'>t = @f$2</span>; <span class='color_blue'>(@f$0  &lt;=  8)</span>; <span class='color_blue'>@f$3 != 0</span> *
       <span class='color_blue'>#GB<src.c>$head = @f$1 <span class='color_orange'>rearrange:38</span>:node*</span>  ]</span>
    
    Instruction <span class='color_green'>REMOVE_TEMPS(n$17,n$18,n$19); [line 54, column 7]</span>
    in vpath_find exp:_t$5
    vpath_find: found x : node*
    in vpath_find exp:_t$4
    vpath_find: cannot find _t$4
    in vpath_find exp:_t$1
    vpath_find: found head : node*
    Instruction Returns
    PROP 1 of 1:
    <span class='color_blue'><span class='color_red'>(-1  &lt;  _t$8)</span>; <span class='color_blue'>(@f$0  &lt;=  8)</span>; <span class='color_red'>t != 0</span>; <span class='color_red'>MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(x)</span>; <span class='color_red'>MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(_t$6)</span>; <span class='color_blue'>MEMma &lt; malloc:38 &gt;  <span class='color_orange'>{vpath: }</span>(_t$1)</span>; <span class='color_red'>DANGL &lt; UNINIT &gt; (_t$8)</span>; <span class='color_blue'>DANGL &lt; UNINIT &gt; (_t$5)</span> ;
    <span class='color_blue'>x = <span class='color_red'>_t$7 <span class='color_orange'>update:45</span></span>:node*</span>; <span class='color_blue'>n = null <span class='color_orange'>update:40</span>:node*</span>; <span class='color_blue'>t = <span class='color_red'>_t$2 <span class='color_orange'>update:53</span></span>:node*</span>; <span class='color_blue'>#GB<src.c>$head = _t$1 <span class='color_orange'>update:38</span>:node*</span>; <span class='color_blue'>i = (@f$0 + 1) <span class='color_orange'>update:43</span>:int</span>; <span class='color_blue'>return = _t$0 <span class='color_orange'>initial</span>:int</span> ;
    <span class='color_red'>x|->{next:null <span class='color_orange'>update:46</span>, v:(@f$0 + 1) <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16</span>; <span class='color_red'>_t$6|->{next:null <span class='color_orange'>update:46</span>, v:@f$0 <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16</span>; <span class='color_red'>t|->{next:_t$4 <span class='color_orange'>update:56</span>, v:_t$5 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16</span>; <span class='color_blue'>_t$1|->{next:<span class='color_red'>t <span class='color_orange'>update:56</span></span>, v:<span class='color_red'>_t$3 <span class='color_orange'>alloc</span></span>} <span class='color_orange'>alloc</span>:node16</span>; <span class='color_blue'>lseg(_t$4,_t$6,[],P0)</span>
    [footprint
       <span class='color_blue'>(@f$0  &lt;=  8)</span>; <span class='color_blue'>@f$2 != 0</span> *
       <span class='color_blue'>#GB<src.c>$head = @f$1 <span class='color_orange'>rearrange:38</span>:node*</span>  ]
    where
    P0 = exists [_t$2]. <span class='color_blue'>_t$0|->{next:_t$1 <span class='color_orange'>update:56</span>, v:_t$2 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16</span></span>
    
    Instruction <span class='color_green'>REMOVE_TEMPS(n$17,n$18,n$19); [line 54, column 7]</span>
    in vpath_find exp:_t$3
    vpath_find: found x : node*
    in vpath_find exp:_t$1
    vpath_find: found head : node*
    in vpath_find exp:n$17
    vpath_find: found t : node*
    Instruction Returns
    PROP 1 of 1:
    <span class='color_blue'><span class='color_red'>(-1  &lt;  _t$5)</span>; <span class='color_blue'>(@f$0  &lt;=  8)</span>; <span class='color_red'>t != 0</span>; <span class='color_red'>MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(x)</span>; <span class='color_red'>MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(t)</span>; <span class='color_blue'>MEMma &lt; malloc:38 &gt;  <span class='color_orange'>{vpath: }</span>(_t$1)</span>; <span class='color_red'>DANGL &lt; UNINIT &gt; (_t$5)</span> ;
    <span class='color_blue'>x = <span class='color_red'>_t$4 <span class='color_orange'>update:45</span></span>:node*</span>; <span class='color_blue'>n = null <span class='color_orange'>update:40</span>:node*</span>; <span class='color_blue'>t = <span class='color_red'>_t$2 <span class='color_orange'>update:53</span></span>:node*</span>; <span class='color_blue'>#GB<src.c>$head = _t$1 <span class='color_orange'>update:38</span>:node*</span>; <span class='color_blue'>i = (@f$0 + 1) <span class='color_orange'>update:43</span>:int</span>; <span class='color_blue'>return = _t$0 <span class='color_orange'>initial</span>:int</span> ;
    <span class='color_red'>x|->{next:null <span class='color_orange'>update:46</span>, v:(@f$0 + 1) <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16</span>; <span class='color_red'>t|->{next:null <span class='color_orange'>update:46</span>, v:@f$0 <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16</span>; <span class='color_blue'>_t$1|->{next:<span class='color_red'>t <span class='color_orange'>update:56</span></span>, v:<span class='color_red'>_t$3 <span class='color_orange'>alloc</span></span>} <span class='color_orange'>alloc</span>:node16</span>
    [footprint
       <span class='color_blue'>@f$3 = @f$2</span>; <span class='color_blue'>(@f$0  &lt;=  8)</span>; <span class='color_red'>@f$4 != 0</span> *
       <span class='color_blue'>#GB<src.c>$head = @f$1 <span class='color_orange'>rearrange:38</span>:node*</span>  ]</span>
    
    Instruction <span class='color_green'>APPLY_ABSTRACTION; [line 54, column 7]</span>
    in vpath_find exp:_t$7
    vpath_find: found x : node*
    in vpath_find exp:_t$6
    vpath_find: cannot find _t$6
    in vpath_find exp:_t$1
    vpath_find: found head : node*
    <span class='color_blue'>(@f$0  &lt;=  8); t != 0; MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(x); MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(_t$4); MEMma &lt; malloc:38 &gt;  <span class='color_orange'>{vpath: }</span>(_t$1) ;
    x = _t$5 <span class='color_orange'>update:45</span>:node*; n = null <span class='color_orange'>update:40</span>:node*; t = _t$2 <span class='color_orange'>update:53</span>:node*; #GB<src.c>$head = _t$1 <span class='color_orange'>update:38</span>:node*; i = (@f$0 + 1) <span class='color_orange'>update:43</span>:int; return = _t$0 <span class='color_orange'>initial</span>:int ;
    x|->{next:null <span class='color_orange'>update:46</span>, v:(@f$0 + 1) <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16; _t$4|->{next:null <span class='color_orange'>update:46</span>, v:@f$0 <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16; _t$1|->{next:t <span class='color_orange'>update:56</span>, v:_t$3 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16; lsegne(t,_t$4,[],P0)
    [footprint
       (@f$0  &lt;=  8) *
       #GB<src.c>$head = @f$1 <span class='color_orange'>rearrange:38</span>:node*  ]
    where
    P0 = exists [_t$2]. _t$0|->{next:_t$1 <span class='color_orange'>update:56</span>, v:_t$2 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16</span>
    Instruction Returns
    PROP 1 of 1:
    <span class='color_blue'><span class='color_blue'>(@f$0  &lt;=  8)</span>; <span class='color_blue'>t != 0</span>; <span class='color_blue'>MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(x)</span>; <span class='color_red'>MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(_t$4)</span>; <span class='color_blue'>MEMma &lt; malloc:38 &gt;  <span class='color_orange'>{vpath: }</span>(_t$1)</span> ;
    <span class='color_blue'>x = <span class='color_red'>_t$5 <span class='color_orange'>update:45</span></span>:node*</span>; <span class='color_blue'>n = null <span class='color_orange'>update:40</span>:node*</span>; <span class='color_blue'>t = _t$2 <span class='color_orange'>update:53</span>:node*</span>; <span class='color_blue'>#GB<src.c>$head = _t$1 <span class='color_orange'>update:38</span>:node*</span>; <span class='color_blue'>i = (@f$0 + 1) <span class='color_orange'>update:43</span>:int</span>; <span class='color_blue'>return = _t$0 <span class='color_orange'>initial</span>:int</span> ;
    <span class='color_red'>x|->{next:null <span class='color_orange'>update:46</span>, v:(@f$0 + 1) <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16</span>; <span class='color_blue'>_t$4|->{next:null <span class='color_orange'>update:46</span>, v:@f$0 <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16</span>; <span class='color_blue'>_t$1|->{next:t <span class='color_orange'>update:56</span>, v:_t$3 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16</span>; <span class='color_blue'>lsegne(t,_t$4,[],P0)</span>
    [footprint
       <span class='color_blue'>(@f$0  &lt;=  8)</span> *
       <span class='color_blue'>#GB<src.c>$head = @f$1 <span class='color_orange'>rearrange:38</span>:node*</span>  ]
    where
    P0 = exists [_t$2]. <span class='color_blue'>_t$0|->{next:_t$1 <span class='color_orange'>update:56</span>, v:_t$2 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16</span></span>
    
    Instruction <span class='color_green'>APPLY_ABSTRACTION; [line 54, column 7]</span>
    in vpath_find exp:_t$4
    vpath_find: found x : node*
    in vpath_find exp:_t$2
    vpath_find: found t : node*
    in vpath_find exp:_t$1
    vpath_find: found head : node*
    <span class='color_blue'>(@f$0  &lt;=  8); t != 0; MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(x); MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(t); MEMma &lt; malloc:38 &gt;  <span class='color_orange'>{vpath: }</span>(_t$1) ;
    x = _t$4 <span class='color_orange'>update:45</span>:node*; n = null <span class='color_orange'>update:40</span>:node*; t = _t$2 <span class='color_orange'>update:53</span>:node*; #GB<src.c>$head = _t$1 <span class='color_orange'>update:38</span>:node*; i = (@f$0 + 1) <span class='color_orange'>update:43</span>:int; return = _t$0 <span class='color_orange'>initial</span>:int ;
    x|->{next:null <span class='color_orange'>update:46</span>, v:(@f$0 + 1) <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16; t|->{next:null <span class='color_orange'>update:46</span>, v:@f$0 <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16; _t$1|->{next:t <span class='color_orange'>update:56</span>, v:_t$3 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16
    [footprint
       (@f$0  &lt;=  8) *
       #GB<src.c>$head = @f$1 <span class='color_orange'>rearrange:38</span>:node*  ]</span>
    Instruction Returns
    PROP 1 of 1:
    <span class='color_blue'><span class='color_blue'>(@f$0  &lt;=  8)</span>; <span class='color_blue'>t != 0</span>; <span class='color_blue'>MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(x)</span>; <span class='color_blue'>MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(t)</span>; <span class='color_blue'>MEMma &lt; malloc:38 &gt;  <span class='color_orange'>{vpath: }</span>(_t$1)</span> ;
    <span class='color_blue'>x = _t$4 <span class='color_orange'>update:45</span>:node*</span>; <span class='color_blue'>n = null <span class='color_orange'>update:40</span>:node*</span>; <span class='color_blue'>t = _t$2 <span class='color_orange'>update:53</span>:node*</span>; <span class='color_blue'>#GB<src.c>$head = _t$1 <span class='color_orange'>update:38</span>:node*</span>; <span class='color_blue'>i = (@f$0 + 1) <span class='color_orange'>update:43</span>:int</span>; <span class='color_blue'>return = _t$0 <span class='color_orange'>initial</span>:int</span> ;
    <span class='color_blue'>x|->{next:null <span class='color_orange'>update:46</span>, v:(@f$0 + 1) <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16</span>; <span class='color_blue'>t|->{next:null <span class='color_orange'>update:46</span>, v:@f$0 <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16</span>; <span class='color_blue'>_t$1|->{next:t <span class='color_orange'>update:56</span>, v:_t$3 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16</span>
    [footprint
       <span class='color_blue'>(@f$0  &lt;=  8)</span> *
       <span class='color_blue'>#GB<src.c>$head = @f$1 <span class='color_orange'>rearrange:38</span>:node*</span>  ]</span>
    
    .... After Symbolic Execution ....
    PROP 1 of 2:
    <span class='color_blue'><span class='color_blue'>(@f$0  &lt;=  8)</span>; <span class='color_blue'>t != 0</span>; <span class='color_blue'>MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(x)</span>; <span class='color_blue'>MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(_t$4)</span>; <span class='color_blue'>MEMma &lt; malloc:38 &gt;  <span class='color_orange'>{vpath: }</span>(_t$1)</span> ;
    <span class='color_blue'>x = _t$5 <span class='color_orange'>update:45</span>:node*</span>; <span class='color_blue'>n = null <span class='color_orange'>update:40</span>:node*</span>; <span class='color_blue'>t = _t$2 <span class='color_orange'>update:53</span>:node*</span>; <span class='color_blue'>#GB<src.c>$head = _t$1 <span class='color_orange'>update:38</span>:node*</span>; <span class='color_blue'>i = (@f$0 + 1) <span class='color_orange'>update:43</span>:int</span>; <span class='color_blue'>return = _t$0 <span class='color_orange'>initial</span>:int</span> ;
    <span class='color_blue'>x|->{next:null <span class='color_orange'>update:46</span>, v:(@f$0 + 1) <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16</span>; <span class='color_blue'>_t$4|->{next:null <span class='color_orange'>update:46</span>, v:@f$0 <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16</span>; <span class='color_blue'>_t$1|->{next:t <span class='color_orange'>update:56</span>, v:_t$3 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16</span>; <span class='color_blue'>lsegne(t,_t$4,[],P0)</span>
    [footprint
       <span class='color_blue'>(@f$0  &lt;=  8)</span> *
       <span class='color_blue'>#GB<src.c>$head = @f$1 <span class='color_orange'>rearrange:38</span>:node*</span>  ]
    where
    P0 = exists [_t$2]. <span class='color_blue'>_t$0|->{next:_t$1 <span class='color_orange'>update:56</span>, v:_t$2 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16</span></span>
    PROP 2 of 2:
    <span class='color_blue'><span class='color_blue'>(@f$0  &lt;=  8)</span>; <span class='color_blue'>t != 0</span>; <span class='color_blue'>MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(x)</span>; <span class='color_blue'>MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(t)</span>; <span class='color_blue'>MEMma &lt; malloc:38 &gt;  <span class='color_orange'>{vpath: }</span>(_t$1)</span> ;
    <span class='color_blue'>x = <span class='color_red'>_t$4 <span class='color_orange'>update:45</span></span>:node*</span>; <span class='color_blue'>n = null <span class='color_orange'>update:40</span>:node*</span>; <span class='color_blue'>t = _t$2 <span class='color_orange'>update:53</span>:node*</span>; <span class='color_blue'>#GB<src.c>$head = _t$1 <span class='color_orange'>update:38</span>:node*</span>; <span class='color_blue'>i = (@f$0 + 1) <span class='color_orange'>update:43</span>:int</span>; <span class='color_blue'>return = _t$0 <span class='color_orange'>initial</span>:int</span> ;
    <span class='color_blue'>x|->{next:null <span class='color_orange'>update:46</span>, v:<span class='color_red'>(@f$0 + 1) <span class='color_orange'>update:47</span></span>} <span class='color_orange'>alloc</span>:node16</span>; <span class='color_blue'>t|->{next:null <span class='color_orange'>update:46</span>, v:@f$0 <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16</span>; <span class='color_blue'>_t$1|->{next:t <span class='color_orange'>update:56</span>, v:_t$3 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16</span>
    [footprint
       <span class='color_blue'>(@f$0  &lt;=  8)</span> *
       <span class='color_blue'>#GB<src.c>$head = @f$1 <span class='color_orange'>rearrange:38</span>:node*</span>  ]</span>
    
    
    
  Processing prop 2/3
    Instruction <span class='color_green'>n$17=*&amp;t:node* [line 54, column 21]</span>
    in vpath_find exp:n$1183
    vpath_find: found head : node*
    in vpath_find exp:n$1182
    vpath_find: found n : node*
    in vpath_find exp:n$1181
    vpath_find: found x : node*
    .... Rearrangement Start ....
    Exp: &amp;t
    Prop: 
    <span class='color_blue'>t != 0; MEMma &lt; malloc:38 &gt;  <span class='color_orange'>{vpath: }</span>(n$1183); MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(n); MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(x) ;
    x = n$1181 <span class='color_orange'>update:45</span>:node*; n = n$1182 <span class='color_orange'>update:58</span>:node*; t = n$1184 <span class='color_orange'>update:53</span>:node*; #GB<src.c>$head = n$1183 <span class='color_orange'>update:38</span>:node*; i = 4 <span class='color_orange'>update:43</span>:int; return = n$1186 <span class='color_orange'>initial</span>:int ;
    n$1183|->{next:t <span class='color_orange'>update:56</span>, v:n$1185 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16; n|->{next:null <span class='color_orange'>update:46</span>, v:3 <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16; x|->{next:null <span class='color_orange'>update:46</span>, v:4 <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16; lseg(t,n,[],P0)
    [footprint
       @f$1 != 0 *
       #GB<src.c>$head = @f$0 <span class='color_orange'>rearrange:38</span>:node*  ]
    where
    P0 = exists [_t$2]. _t$0|->{next:_t$1 <span class='color_orange'>update:56</span>, v:_t$2 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16</span>
    
    in prop_iter_extend_ptsto lexp: &amp;t
    prop before:
    <span class='color_blue'>t != 0; MEMma &lt; malloc:38 &gt;  <span class='color_orange'>{vpath: }</span>(n$1183); MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(n); MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(x) ;
    x = n$1181 <span class='color_orange'>update:45</span>:node*; n = n$1182 <span class='color_orange'>update:58</span>:node*; t = n$1184 <span class='color_orange'>update:53</span>:node*; #GB<src.c>$head = n$1183 <span class='color_orange'>update:38</span>:node*; i = 4 <span class='color_orange'>update:43</span>:int; return = n$1186 <span class='color_orange'>initial</span>:int ;
    n$1183|->{next:t <span class='color_orange'>update:56</span>, v:n$1185 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16; n|->{next:null <span class='color_orange'>update:46</span>, v:3 <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16; x|->{next:null <span class='color_orange'>update:46</span>, v:4 <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16; lseg(t,n,[],P0)
    [footprint
       @f$1 != 0 *
       #GB<src.c>$head = @f$0 <span class='color_orange'>rearrange:38</span>:node*  ]
    where
    P0 = exists [_t$2]. _t$0|->{next:_t$1 <span class='color_orange'>update:56</span>, v:_t$2 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16</span>
    
    
    prop list after:
    PROP 1 of 1:
    <span class='color_blue'><span class='color_blue'>t != 0</span>; <span class='color_blue'>MEMma &lt; malloc:38 &gt;  <span class='color_orange'>{vpath: }</span>(n$1183)</span>; <span class='color_blue'>MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(n)</span>; <span class='color_blue'>MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(x)</span> ;
    <span class='color_blue'>x = n$1181 <span class='color_orange'>update:45</span>:node*</span>; <span class='color_blue'>n = n$1182 <span class='color_orange'>update:58</span>:node*</span>; <span class='color_blue'>t = n$1184 <span class='color_orange'>update:53</span>:node*</span>; <span class='color_blue'>#GB<src.c>$head = n$1183 <span class='color_orange'>update:38</span>:node*</span>; <span class='color_blue'>i = 4 <span class='color_orange'>update:43</span>:int</span>; <span class='color_blue'>return = n$1186 <span class='color_orange'>initial</span>:int</span> ;
    <span class='color_blue'>n$1183|->{next:t <span class='color_orange'>update:56</span>, v:n$1185 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16</span>; <span class='color_blue'>n|->{next:null <span class='color_orange'>update:46</span>, v:3 <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16</span>; <span class='color_blue'>x|->{next:null <span class='color_orange'>update:46</span>, v:4 <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16</span>; <span class='color_blue'>lseg(t,n,[],P0)</span>
    [footprint
       <span class='color_blue'>@f$1 != 0</span> *
       <span class='color_blue'>#GB<src.c>$head = @f$0 <span class='color_orange'>rearrange:38</span>:node*</span>  ]
    where
    P0 = exists [_t$2]. <span class='color_blue'>_t$0|->{next:_t$1 <span class='color_orange'>update:56</span>, v:_t$2 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16</span></span>
    
    
    
    Instruction Returns
    PROP 1 of 1:
    <span class='color_blue'><span class='color_red'>t != 0</span>; <span class='color_blue'>MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(x)</span>; <span class='color_red'>MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(n)</span>; <span class='color_blue'>MEMma &lt; malloc:38 &gt;  <span class='color_orange'>{vpath: }</span>(_t$1)</span> ;
    <span class='color_blue'>x = <span class='color_red'>_t$4 <span class='color_orange'>update:45</span></span>:node*</span>; <span class='color_blue'>n = <span class='color_red'>_t$3 <span class='color_orange'>update:58</span></span>:node*</span>; <span class='color_blue'>t = <span class='color_red'>n$17 <span class='color_orange'>update:53</span></span>:node*</span>; <span class='color_blue'>#GB<src.c>$head = _t$1 <span class='color_orange'>update:38</span>:node*</span>; <span class='color_blue'>i = 4 <span class='color_orange'>update:43</span>:int</span>; <span class='color_blue'>return = _t$0 <span class='color_orange'>initial</span>:int</span> ;
    <span class='color_blue'>x|->{next:null <span class='color_orange'>update:46</span>, v:<span class='color_red'>4 <span class='color_orange'>update:47</span></span>} <span class='color_orange'>alloc</span>:node16</span>; <span class='color_red'>n|->{next:null <span class='color_orange'>update:46</span>, v:3 <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16</span>; <span class='color_blue'>_t$1|->{next:<span class='color_red'>t <span class='color_orange'>update:56</span></span>, v:<span class='color_red'>_t$2 <span class='color_orange'>alloc</span></span>} <span class='color_orange'>alloc</span>:node16</span>; <span class='color_red'>lseg(t,n,[],P0)</span>
    [footprint
       <span class='color_blue'>@f$1 != 0</span> *
       <span class='color_blue'>#GB<src.c>$head = @f$0 <span class='color_orange'>rearrange:38</span>:node*</span>  ]
    where
    P0 = exists [_t$2]. <span class='color_blue'>_t$0|->{next:_t$1 <span class='color_orange'>update:56</span>, v:_t$2 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16</span></span>
    
    Instruction <span class='color_green'>n$18=*n$17.v:int [line 54, column 21]</span>
    in vpath_find exp:n$1189
    vpath_find: found head : node*
    in vpath_find exp:n$1188
    vpath_find: found n : node*
    in vpath_find exp:n$1187
    vpath_find: found x : node*
    .... Rearrangement Start ....
    Exp: n$17.v
    Prop: 
    <span class='color_blue'>t != 0; MEMma &lt; malloc:38 &gt;  <span class='color_orange'>{vpath: }</span>(n$1189); MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(n); MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(x) ;
    x = n$1187 <span class='color_orange'>update:45</span>:node*; n = n$1188 <span class='color_orange'>update:58</span>:node*; t = n$17 <span class='color_orange'>update:53</span>:node*; #GB<src.c>$head = n$1189 <span class='color_orange'>update:38</span>:node*; i = 4 <span class='color_orange'>update:43</span>:int; return = n$1191 <span class='color_orange'>initial</span>:int ;
    n$1189|->{next:t <span class='color_orange'>update:56</span>, v:n$1190 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16; n|->{next:null <span class='color_orange'>update:46</span>, v:3 <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16; x|->{next:null <span class='color_orange'>update:46</span>, v:4 <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16; lseg(t,n,[],P0)
    [footprint
       @f$1 != 0 *
       #GB<src.c>$head = @f$0 <span class='color_orange'>rearrange:38</span>:node*  ]
    where
    P0 = exists [_t$2]. _t$0|->{next:_t$1 <span class='color_orange'>update:56</span>, v:_t$2 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16</span>
    
    in prop_iter_extend_ptsto lexp: n$17.v
    prop before:
    <span class='color_blue'>t != 0; MEMma &lt; malloc:38 &gt;  <span class='color_orange'>{vpath: }</span>(n$1189); MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(n); MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(x) ;
    x = n$1187 <span class='color_orange'>update:45</span>:node*; n = n$1188 <span class='color_orange'>update:58</span>:node*; t = n$17 <span class='color_orange'>update:53</span>:node*; #GB<src.c>$head = n$1189 <span class='color_orange'>update:38</span>:node*; i = 4 <span class='color_orange'>update:43</span>:int; return = n$1191 <span class='color_orange'>initial</span>:int ;
    n$1189|->{next:t <span class='color_orange'>update:56</span>, v:n$1190 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16; n|->{next:null <span class='color_orange'>update:46</span>, v:3 <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16; x|->{next:null <span class='color_orange'>update:46</span>, v:4 <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16; t|->{next:_t$2025 <span class='color_orange'>update:56</span>, v:_t$2026 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16; lseg(_t$2025,n,[],P0)
    [footprint
       @f$1 != 0 *
       #GB<src.c>$head = @f$0 <span class='color_orange'>rearrange:38</span>:node*  ]
    where
    P0 = exists [_t$2]. _t$0|->{next:_t$1 <span class='color_orange'>update:56</span>, v:_t$2 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16</span>
    
    
    prop list after:
    PROP 1 of 1:
    <span class='color_blue'><span class='color_blue'>t != 0</span>; <span class='color_blue'>MEMma &lt; malloc:38 &gt;  <span class='color_orange'>{vpath: }</span>(n$1189)</span>; <span class='color_blue'>MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(n)</span>; <span class='color_blue'>MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(x)</span> ;
    <span class='color_blue'>x = n$1187 <span class='color_orange'>update:45</span>:node*</span>; <span class='color_blue'>n = n$1188 <span class='color_orange'>update:58</span>:node*</span>; <span class='color_blue'>t = n$17 <span class='color_orange'>update:53</span>:node*</span>; <span class='color_blue'>#GB<src.c>$head = n$1189 <span class='color_orange'>update:38</span>:node*</span>; <span class='color_blue'>i = 4 <span class='color_orange'>update:43</span>:int</span>; <span class='color_blue'>return = n$1191 <span class='color_orange'>initial</span>:int</span> ;
    <span class='color_blue'>n$1189|->{next:t <span class='color_orange'>update:56</span>, v:n$1190 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16</span>; <span class='color_blue'>n|->{next:null <span class='color_orange'>update:46</span>, v:3 <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16</span>; <span class='color_blue'>x|->{next:null <span class='color_orange'>update:46</span>, v:4 <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16</span>; <span class='color_blue'>t|->{next:_t$2025 <span class='color_orange'>update:56</span>, v:_t$2026 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16</span>; <span class='color_blue'>lseg(_t$2025,n,[],P0)</span>
    [footprint
       <span class='color_blue'>@f$1 != 0</span> *
       <span class='color_blue'>#GB<src.c>$head = @f$0 <span class='color_orange'>rearrange:38</span>:node*</span>  ]
    where
    P0 = exists [_t$2]. <span class='color_blue'>_t$0|->{next:_t$1 <span class='color_orange'>update:56</span>, v:_t$2 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16</span></span>
    
    
    
    in prop_iter_extend_ptsto lexp: n$17.v
    prop before:
    <span class='color_blue'>n$1188 = t ;
    t != 0; MEMma &lt; malloc:38 &gt;  <span class='color_orange'>{vpath: }</span>(n$1189); MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(x); MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(t) ;
    x = n$1187 <span class='color_orange'>update:45</span>:node*; n = n$17 <span class='color_orange'>update:58</span>:node*; t = n$17 <span class='color_orange'>update:53</span>:node*; #GB<src.c>$head = n$1189 <span class='color_orange'>update:38</span>:node*; i = 4 <span class='color_orange'>update:43</span>:int; return = n$1191 <span class='color_orange'>initial</span>:int ;
    n$1189|->{next:t <span class='color_orange'>update:56</span>, v:n$1190 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16; x|->{next:null <span class='color_orange'>update:46</span>, v:4 <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16; t|->{next:null <span class='color_orange'>update:46</span>, v:3 <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16
    [footprint
       n$1188 = t; @f$1 != 0 *
       #GB<src.c>$head = @f$0 <span class='color_orange'>rearrange:38</span>:node*  ]</span>
    
    
    prop list after:
    PROP 1 of 1:
    <span class='color_blue'><span class='color_blue'>n$1188 = t</span> ;
    <span class='color_blue'>t != 0</span>; <span class='color_blue'>MEMma &lt; malloc:38 &gt;  <span class='color_orange'>{vpath: }</span>(n$1189)</span>; <span class='color_blue'>MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(x)</span>; <span class='color_blue'>MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(t)</span> ;
    <span class='color_blue'>x = n$1187 <span class='color_orange'>update:45</span>:node*</span>; <span class='color_blue'>n = n$17 <span class='color_orange'>update:58</span>:node*</span>; <span class='color_blue'>t = n$17 <span class='color_orange'>update:53</span>:node*</span>; <span class='color_blue'>#GB<src.c>$head = n$1189 <span class='color_orange'>update:38</span>:node*</span>; <span class='color_blue'>i = 4 <span class='color_orange'>update:43</span>:int</span>; <span class='color_blue'>return = n$1191 <span class='color_orange'>initial</span>:int</span> ;
    <span class='color_blue'>n$1189|->{next:t <span class='color_orange'>update:56</span>, v:n$1190 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16</span>; <span class='color_blue'>x|->{next:null <span class='color_orange'>update:46</span>, v:4 <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16</span>; <span class='color_blue'>t|->{next:null <span class='color_orange'>update:46</span>, v:3 <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16</span>
    [footprint
       <span class='color_blue'>n$1188 = t</span>; <span class='color_blue'>@f$1 != 0</span> *
       <span class='color_blue'>#GB<src.c>$head = @f$0 <span class='color_orange'>rearrange:38</span>:node*</span>  ]</span>
    
    
    
    Instruction Returns
    PROP 1 of 2:
    <span class='color_blue'><span class='color_blue'>t != 0</span>; <span class='color_red'>MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(x)</span>; <span class='color_blue'>MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(n)</span>; <span class='color_blue'>MEMma &lt; malloc:38 &gt;  <span class='color_orange'>{vpath: }</span>(_t$1)</span>; <span class='color_red'>DANGL &lt; UNINIT &gt; (n$18)</span> ;
    <span class='color_blue'>x = <span class='color_red'>_t$5 <span class='color_orange'>update:45</span></span>:node*</span>; <span class='color_blue'>n = <span class='color_red'>_t$4 <span class='color_orange'>update:58</span></span>:node*</span>; <span class='color_blue'>t = n$17 <span class='color_orange'>update:53</span>:node*</span>; <span class='color_blue'>#GB<src.c>$head = _t$1 <span class='color_orange'>update:38</span>:node*</span>; <span class='color_blue'>i = 4 <span class='color_orange'>update:43</span>:int</span>; <span class='color_blue'>return = _t$0 <span class='color_orange'>initial</span>:int</span> ;
    <span class='color_red'>x|->{next:null <span class='color_orange'>update:46</span>, v:4 <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16</span>; <span class='color_blue'>n|->{next:null <span class='color_orange'>update:46</span>, v:<span class='color_red'>3 <span class='color_orange'>update:47</span></span>} <span class='color_orange'>alloc</span>:node16</span>; <span class='color_blue'>_t$1|->{next:t <span class='color_orange'>update:56</span>, v:_t$2 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16</span>; <span class='color_blue'>t|->{next:_t$3 <span class='color_orange'>update:56</span>, v:n$18 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16</span>; <span class='color_blue'>lseg(_t$3,n,[],P0)</span>
    [footprint
       <span class='color_blue'>@f$1 != 0</span> *
       <span class='color_blue'>#GB<src.c>$head = @f$0 <span class='color_orange'>rearrange:38</span>:node*</span>  ]
    where
    P0 = exists [_t$2]. <span class='color_blue'>_t$0|->{next:_t$1 <span class='color_orange'>update:56</span>, v:_t$2 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16</span></span>
    PROP 2 of 2:
    <span class='color_blue'><span class='color_red'>n$18 = 3</span> ;
    <span class='color_blue'>t != 0</span>; <span class='color_blue'>MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(x)</span>; <span class='color_blue'>MEMma &lt; malloc:38 &gt;  <span class='color_orange'>{vpath: }</span>(_t$1)</span>; <span class='color_blue'>MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(t)</span> ;
    <span class='color_blue'>x = <span class='color_red'>_t$3 <span class='color_orange'>update:45</span></span>:node*</span>; <span class='color_blue'>n = <span class='color_red'>n$17 <span class='color_orange'>update:58</span></span>:node*</span>; <span class='color_blue'>t = n$17 <span class='color_orange'>update:53</span>:node*</span>; <span class='color_blue'>#GB<src.c>$head = _t$1 <span class='color_orange'>update:38</span>:node*</span>; <span class='color_blue'>i = 4 <span class='color_orange'>update:43</span>:int</span>; <span class='color_blue'>return = _t$0 <span class='color_orange'>initial</span>:int</span> ;
    <span class='color_blue'>x|->{next:null <span class='color_orange'>update:46</span>, v:<span class='color_red'>4 <span class='color_orange'>update:47</span></span>} <span class='color_orange'>alloc</span>:node16</span>; <span class='color_blue'>_t$1|->{next:t <span class='color_orange'>update:56</span>, v:_t$2 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16</span>; <span class='color_blue'>t|->{next:null <span class='color_orange'>update:46</span>, v:3 <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16</span>
    [footprint
       <span class='color_red'>t = @f$1</span>; <span class='color_red'>@f$2 != 0</span> *
       <span class='color_blue'>#GB<src.c>$head = @f$0 <span class='color_orange'>rearrange:38</span>:node*</span>  ]</span>
    
    Instruction <span class='color_green'>n$19=_fun_printf("%d\n":char const *,n$18:int) [line 54, column 7]</span>
    in vpath_find exp:n$1194
    vpath_find: found head : node*
    in vpath_find exp:n$1193
    vpath_find: found n : node*
    in vpath_find exp:n$1192
    vpath_find: found x : node*
    <span class='color_orange'>WARNING: likely use of variable-arguments function, or function prototype missing</span>
    actual parameters: n$18
    formal parameters: 
    Found 1 specs for function printf
    START EXECUTING SPECS FOR printf from state
    <span class='color_blue'>t != 0; MEMma &lt; malloc:38 &gt;  <span class='color_orange'>{vpath: }</span>(n$1194); MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(n); MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(x); DANGL &lt; UNINIT &gt; (n$18) ;
    x = n$1192 <span class='color_orange'>update:45</span>:node*; n = n$1193 <span class='color_orange'>update:58</span>:node*; t = n$17 <span class='color_orange'>update:53</span>:node*; #GB<src.c>$head = n$1194 <span class='color_orange'>update:38</span>:node*; i = 4 <span class='color_orange'>update:43</span>:int; return = n$1197 <span class='color_orange'>initial</span>:int ;
    n$1194|->{next:t <span class='color_orange'>update:56</span>, v:n$1195 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16; n|->{next:null <span class='color_orange'>update:46</span>, v:3 <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16; x|->{next:null <span class='color_orange'>update:46</span>, v:4 <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16; t|->{next:n$1196 <span class='color_orange'>update:56</span>, v:n$18 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16; lseg(n$1196,n,[],P0)
    [footprint
       @f$1 != 0 *
       #GB<src.c>$head = @f$0 <span class='color_orange'>rearrange:38</span>:node*  ]
    where
    P0 = exists [_t$2]. _t$0|->{next:_t$1 <span class='color_orange'>update:56</span>, v:_t$2 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16</span>
    <span class='color_orange'>WARNING: more actual pars than formal pars in fun call (2 vs 1)</span>
    EXECUTING SPEC 1/1
    ACTUAL PRECONDITION =
      <span class='color_blue'>t != 0; MEMma &lt; malloc:38 &gt;  <span class='color_orange'>{vpath: }</span>(n$1194); MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(n); MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(x); DANGL &lt; UNINIT &gt; (n$18) ;
      x = n$1192 <span class='color_orange'>update:45</span>:node*; n = n$1193 <span class='color_orange'>update:58</span>:node*; t = n$17 <span class='color_orange'>update:53</span>:node*; #GB<src.c>$head = n$1194 <span class='color_orange'>update:38</span>:node*; i = 4 <span class='color_orange'>update:43</span>:int; format|callee = "%d\n" <span class='color_orange'>actual_precondition</span>:char const *; return = n$1197 <span class='color_orange'>initial</span>:int ;
      n$1194|->{next:t <span class='color_orange'>update:56</span>, v:n$1195 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16; n|->{next:null <span class='color_orange'>update:46</span>, v:3 <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16; x|->{next:null <span class='color_orange'>update:46</span>, v:4 <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16; t|->{next:n$1196 <span class='color_orange'>update:56</span>, v:n$18 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16; lseg(n$1196,n,[],P0)
      [footprint
         @f$1 != 0 *
         #GB<src.c>$head = @f$0 <span class='color_orange'>rearrange:38</span>:node*  ]
      where
      P0 = exists [_t$2]. _t$0|->{next:_t$1 <span class='color_orange'>update:56</span>, v:_t$2 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16</span>
    SPEC =
      --------------------------- ---------- ---------------------------
      PRE:
      <span class='color_blue'><span class='color_blue'>format|callee = _t$2039 <span class='color_orange'>formal</span>:char const *</span></span>
      POST 1 of 1:
      <span class='color_blue'><span class='color_red'>(-1  &lt;  _t$2040)</span>; <span class='color_red'>DANGL &lt; UNINIT &gt; (return|callee)</span> ;
      <span class='color_red'>return|callee = _t$2040 <span class='color_orange'>update:1114</span>:int</span></span>
      ----------------------------------------------------------------
    pre_check_pure_implication
    pi1:
      n$17 != 0; MEMma &lt; malloc:38 &gt;  <span class='color_orange'>{vpath: }</span>(n$1194); MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(n$1193); MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(n$1192); DANGL &lt; UNINIT &gt; (n$18)
    pi2:
      
    returns
    sub1: 
      
    sub2: 
      
    Current Implication
    SUB:
      
    <span class='color_blue'>t != 0; MEMma &lt; malloc:38 &gt;  <span class='color_orange'>{vpath: }</span>(n$1194); MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(n); MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(x); DANGL &lt; UNINIT &gt; (n$18) ;
    x = n$1192 <span class='color_orange'>update:45</span>:node*; n = n$1193 <span class='color_orange'>update:58</span>:node*; t = n$17 <span class='color_orange'>update:53</span>:node*; #GB<src.c>$head = n$1194 <span class='color_orange'>update:38</span>:node*; i = 4 <span class='color_orange'>update:43</span>:int; format|callee = "%d\n" <span class='color_orange'>actual_precondition</span>:char const *; return = n$1197 <span class='color_orange'>initial</span>:int ;
    n$1194|->{next:t <span class='color_orange'>update:56</span>, v:n$1195 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16; n|->{next:null <span class='color_orange'>update:46</span>, v:3 <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16; x|->{next:null <span class='color_orange'>update:46</span>, v:4 <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16; t|->{next:n$1196 <span class='color_orange'>update:56</span>, v:n$18 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16; lseg(n$1196,n,[],P0)
    [footprint
       @f$1 != 0 *
       #GB<src.c>$head = @f$0 <span class='color_orange'>rearrange:38</span>:node*  ]
    where
    P0 = exists [_t$2]. _t$0|->{next:_t$1 <span class='color_orange'>update:56</span>, v:_t$2 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16</span>
    |-
    <span class='color_blue'>format|callee = _t$2039 <span class='color_orange'>formal</span>:char const *</span>
    
      do_imply "%d\n" _t$2039
        Final Implication
        SUB:
          
        <span class='color_blue'>t != 0; MEMma &lt; malloc:38 &gt;  <span class='color_orange'>{vpath: }</span>(n$1194); MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(n); MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(x); DANGL &lt; UNINIT &gt; (n$18) ;
        x = n$1192 <span class='color_orange'>update:45</span>:node*; n = n$1193 <span class='color_orange'>update:58</span>:node*; t = n$17 <span class='color_orange'>update:53</span>:node*; #GB<src.c>$head = n$1194 <span class='color_orange'>update:38</span>:node*; i = 4 <span class='color_orange'>update:43</span>:int; return = n$1197 <span class='color_orange'>initial</span>:int ;
        n$1194|->{next:t <span class='color_orange'>update:56</span>, v:n$1195 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16; n|->{next:null <span class='color_orange'>update:46</span>, v:3 <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16; x|->{next:null <span class='color_orange'>update:46</span>, v:4 <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16; t|->{next:n$1196 <span class='color_orange'>update:56</span>, v:n$18 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16; lseg(n$1196,n,[],P0)
        [footprint
           @f$1 != 0 *
           #GB<src.c>$head = @f$0 <span class='color_orange'>rearrange:38</span>:node*  ]
        where
        P0 = exists [_t$2]. _t$0|->{next:_t$1 <span class='color_orange'>update:56</span>, v:_t$2 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16</span>
        [SUB: 
          _t$2039 = "%d\n"]
        |-
        <span class='color_blue'></span>
    Result of Abduction
      SUB:
        
      <span class='color_blue'>t != 0; MEMma &lt; malloc:38 &gt;  <span class='color_orange'>{vpath: }</span>(n$1194); MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(n); MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(x); DANGL &lt; UNINIT &gt; (n$18) ;
      x = n$1192 <span class='color_orange'>update:45</span>:node*; n = n$1193 <span class='color_orange'>update:58</span>:node*; t = n$17 <span class='color_orange'>update:53</span>:node*; #GB<src.c>$head = n$1194 <span class='color_orange'>update:38</span>:node*; i = 4 <span class='color_orange'>update:43</span>:int; format|callee = "%d\n" <span class='color_orange'>actual_precondition</span>:char const *; return = n$1197 <span class='color_orange'>initial</span>:int ;
      n$1194|->{next:t <span class='color_orange'>update:56</span>, v:n$1195 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16; n|->{next:null <span class='color_orange'>update:46</span>, v:3 <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16; x|->{next:null <span class='color_orange'>update:46</span>, v:4 <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16; t|->{next:n$1196 <span class='color_orange'>update:56</span>, v:n$18 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16; lseg(n$1196,n,[],P0)
      [footprint
         @f$1 != 0 *
         #GB<src.c>$head = @f$0 <span class='color_orange'>rearrange:38</span>:node*  ]
      where
      P0 = exists [_t$2]. _t$0|->{next:_t$1 <span class='color_orange'>update:56</span>, v:_t$2 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16</span>
      [SUB: 
        _t$2039 = "%d\n"]
      |-
      <span class='color_blue'>format|callee = "%d\n" <span class='color_orange'>formal</span>:char const *</span>
    returning TRUE
      New footprint:
      
      Frame fld:
      
      Missing fld:
      
      Instantiated frame:
      n$1194|->{next:n$17 <span class='color_orange'>update:56</span>, v:n$1195 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16; n$1193|->{next:null <span class='color_orange'>update:46</span>, v:3 <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16; n$1192|->{next:null <span class='color_orange'>update:46</span>, v:4 <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16; n$17|->{next:n$1196 <span class='color_orange'>update:56</span>, v:n$18 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16; &amp;x|->n$1192 <span class='color_orange'>update:45</span>:node*; &amp;n|->n$1193 <span class='color_orange'>update:58</span>:node*; &amp;t|->n$17 <span class='color_orange'>update:53</span>:node*; &amp;#GB<src.c>$head|->n$1194 <span class='color_orange'>update:38</span>:node*; &amp;i|->4 <span class='color_orange'>update:43</span>:int; &amp;return|->n$1197 <span class='color_orange'>initial</span>:int; lseg(n$1196,n$1193,[],lam [_t$0,_t$1,]. exists [_t$2]. _t$0|->{next:_t$1 <span class='color_orange'>update:56</span>, v:_t$2 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16)
      Instantiated post:
      PROP 1 of 1:
      <span class='color_blue'><span class='color_red'>(-1  &lt;  _t$2040)</span>; <span class='color_red'>DANGL &lt; UNINIT &gt; (return|callee)</span> ;
      <span class='color_red'>return|callee = _t$2040 <span class='color_orange'>update:54</span>:int</span></span>
      
    ***** RESULTS FUNCTION CALL *******
    PROP 1 of 1:
    <span class='color_blue'><span class='color_red'>(-1  &lt;  n$19)</span>; <span class='color_blue'>t != 0</span>; <span class='color_blue'>MEMma &lt; malloc:38 &gt;  <span class='color_orange'>{vpath: }</span>(n$1194)</span>; <span class='color_blue'>MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(n)</span>; <span class='color_blue'>MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(x)</span>; <span class='color_red'>DANGL &lt; UNINIT &gt; (n$19)</span>; <span class='color_blue'>DANGL &lt; UNINIT &gt; (n$18)</span> ;
    <span class='color_blue'>x = n$1192 <span class='color_orange'>update:45</span>:node*</span>; <span class='color_blue'>n = n$1193 <span class='color_orange'>update:58</span>:node*</span>; <span class='color_blue'>t = n$17 <span class='color_orange'>update:53</span>:node*</span>; <span class='color_blue'>#GB<src.c>$head = n$1194 <span class='color_orange'>update:38</span>:node*</span>; <span class='color_blue'>i = 4 <span class='color_orange'>update:43</span>:int</span>; <span class='color_blue'>return = n$1197 <span class='color_orange'>initial</span>:int</span> ;
    <span class='color_blue'>n$1194|->{next:t <span class='color_orange'>update:56</span>, v:n$1195 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16</span>; <span class='color_blue'>n|->{next:null <span class='color_orange'>update:46</span>, v:3 <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16</span>; <span class='color_blue'>x|->{next:null <span class='color_orange'>update:46</span>, v:4 <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16</span>; <span class='color_blue'>t|->{next:n$1196 <span class='color_orange'>update:56</span>, v:n$18 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16</span>; <span class='color_blue'>lseg(n$1196,n,[],P0)</span>
    [footprint
       <span class='color_blue'>@f$1 != 0</span> *
       <span class='color_blue'>#GB<src.c>$head = @f$0 <span class='color_orange'>rearrange:38</span>:node*</span>  ]
    where
    P0 = exists [_t$2]. <span class='color_blue'>_t$0|->{next:_t$1 <span class='color_orange'>update:56</span>, v:_t$2 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16</span></span>
    ***** END RESULTS FUNCTION CALL *******
    Instruction Returns
    PROP 1 of 1:
    <span class='color_blue'><span class='color_red'>(-1  &lt;  n$19)</span>; <span class='color_blue'>t != 0</span>; <span class='color_blue'>MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(x)</span>; <span class='color_blue'>MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(n)</span>; <span class='color_blue'>MEMma &lt; malloc:38 &gt;  <span class='color_orange'>{vpath: }</span>(_t$1)</span>; <span class='color_red'>DANGL &lt; UNINIT &gt; (n$19)</span>; <span class='color_blue'>DANGL &lt; UNINIT &gt; (n$18)</span> ;
    <span class='color_blue'>x = _t$5 <span class='color_orange'>update:45</span>:node*</span>; <span class='color_blue'>n = _t$4 <span class='color_orange'>update:58</span>:node*</span>; <span class='color_blue'>t = n$17 <span class='color_orange'>update:53</span>:node*</span>; <span class='color_blue'>#GB<src.c>$head = _t$1 <span class='color_orange'>update:38</span>:node*</span>; <span class='color_blue'>i = 4 <span class='color_orange'>update:43</span>:int</span>; <span class='color_blue'>return = _t$0 <span class='color_orange'>initial</span>:int</span> ;
    <span class='color_blue'>x|->{next:null <span class='color_orange'>update:46</span>, v:4 <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16</span>; <span class='color_blue'>n|->{next:null <span class='color_orange'>update:46</span>, v:3 <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16</span>; <span class='color_blue'>_t$1|->{next:t <span class='color_orange'>update:56</span>, v:_t$2 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16</span>; <span class='color_blue'>t|->{next:_t$3 <span class='color_orange'>update:56</span>, v:n$18 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16</span>; <span class='color_blue'>lseg(_t$3,n,[],P0)</span>
    [footprint
       <span class='color_blue'>@f$1 != 0</span> *
       <span class='color_blue'>#GB<src.c>$head = @f$0 <span class='color_orange'>rearrange:38</span>:node*</span>  ]
    where
    P0 = exists [_t$2]. <span class='color_blue'>_t$0|->{next:_t$1 <span class='color_orange'>update:56</span>, v:_t$2 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16</span></span>
    
    Instruction <span class='color_green'>n$19=_fun_printf("%d\n":char const *,n$18:int) [line 54, column 7]</span>
    in vpath_find exp:n$1199
    vpath_find: found head : node*
    in vpath_find exp:n$1198
    vpath_find: found x : node*
    in vpath_find exp:n$17
    vpath_find: found head->next : node*
    <span class='color_orange'>WARNING: likely use of variable-arguments function, or function prototype missing</span>
    actual parameters: 3
    formal parameters: 
    Found 1 specs for function printf
    START EXECUTING SPECS FOR printf from state
    <span class='color_blue'>n$18 = 3 ;
    t != 0; MEMma &lt; malloc:38 &gt;  <span class='color_orange'>{vpath: }</span>(n$1199); MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(x); MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(t) ;
    x = n$1198 <span class='color_orange'>update:45</span>:node*; n = n$17 <span class='color_orange'>update:58</span>:node*; t = n$17 <span class='color_orange'>update:53</span>:node*; #GB<src.c>$head = n$1199 <span class='color_orange'>update:38</span>:node*; i = 4 <span class='color_orange'>update:43</span>:int; return = n$1201 <span class='color_orange'>initial</span>:int ;
    n$1199|->{next:t <span class='color_orange'>update:56</span>, v:n$1200 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16; x|->{next:null <span class='color_orange'>update:46</span>, v:4 <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16; t|->{next:null <span class='color_orange'>update:46</span>, v:3 <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16
    [footprint
       t = @f$1; @f$2 != 0 *
       #GB<src.c>$head = @f$0 <span class='color_orange'>rearrange:38</span>:node*  ]</span>
    <span class='color_orange'>WARNING: more actual pars than formal pars in fun call (2 vs 1)</span>
    EXECUTING SPEC 1/1
    ACTUAL PRECONDITION =
      <span class='color_blue'>n$18 = 3 ;
      t != 0; MEMma &lt; malloc:38 &gt;  <span class='color_orange'>{vpath: }</span>(n$1199); MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(x); MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(t) ;
      x = n$1198 <span class='color_orange'>update:45</span>:node*; n = n$17 <span class='color_orange'>update:58</span>:node*; t = n$17 <span class='color_orange'>update:53</span>:node*; #GB<src.c>$head = n$1199 <span class='color_orange'>update:38</span>:node*; i = 4 <span class='color_orange'>update:43</span>:int; format|callee = "%d\n" <span class='color_orange'>actual_precondition</span>:char const *; return = n$1201 <span class='color_orange'>initial</span>:int ;
      n$1199|->{next:t <span class='color_orange'>update:56</span>, v:n$1200 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16; x|->{next:null <span class='color_orange'>update:46</span>, v:4 <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16; t|->{next:null <span class='color_orange'>update:46</span>, v:3 <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16
      [footprint
         t = @f$1; @f$2 != 0 *
         #GB<src.c>$head = @f$0 <span class='color_orange'>rearrange:38</span>:node*  ]</span>
    SPEC =
      --------------------------- ---------- ---------------------------
      PRE:
      <span class='color_blue'><span class='color_blue'>format|callee = _t$2047 <span class='color_orange'>formal</span>:char const *</span></span>
      POST 1 of 1:
      <span class='color_blue'><span class='color_red'>(-1  &lt;  _t$2048)</span>; <span class='color_red'>DANGL &lt; UNINIT &gt; (return|callee)</span> ;
      <span class='color_red'>return|callee = _t$2048 <span class='color_orange'>update:1114</span>:int</span></span>
      ----------------------------------------------------------------
    pre_check_pure_implication
    pi1:
      n$18 = 3; n$17 != 0; MEMma &lt; malloc:38 &gt;  <span class='color_orange'>{vpath: }</span>(n$1199); MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(n$1198); MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(n$17)
    pi2:
      
    returns
    sub1: 
      n$18 = 3
    sub2: 
      n$18 = 3
    Current Implication
    SUB:
      n$18 = 3
    <span class='color_blue'>t != 0; MEMma &lt; malloc:38 &gt;  <span class='color_orange'>{vpath: }</span>(n$1199); MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(x); MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(t); 3 = 3 ;
    x = n$1198 <span class='color_orange'>update:45</span>:node*; n = n$17 <span class='color_orange'>update:58</span>:node*; t = n$17 <span class='color_orange'>update:53</span>:node*; #GB<src.c>$head = n$1199 <span class='color_orange'>update:38</span>:node*; i = 4 <span class='color_orange'>update:43</span>:int; format|callee = "%d\n" <span class='color_orange'>actual_precondition</span>:char const *; return = n$1201 <span class='color_orange'>initial</span>:int ;
    n$1199|->{next:t <span class='color_orange'>update:56</span>, v:n$1200 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16; x|->{next:null <span class='color_orange'>update:46</span>, v:4 <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16; t|->{next:null <span class='color_orange'>update:46</span>, v:3 <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16
    [footprint
       t = @f$1; @f$2 != 0 *
       #GB<src.c>$head = @f$0 <span class='color_orange'>rearrange:38</span>:node*  ]</span>
    [SUB: 
      n$18 = 3]
    |-
    <span class='color_blue'>format|callee = _t$2047 <span class='color_orange'>formal</span>:char const *</span>
    
      do_imply "%d\n" _t$2047
        Final Implication
        SUB:
          n$18 = 3
        <span class='color_blue'>t != 0; MEMma &lt; malloc:38 &gt;  <span class='color_orange'>{vpath: }</span>(n$1199); MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(x); MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(t); 3 = 3 ;
        x = n$1198 <span class='color_orange'>update:45</span>:node*; n = n$17 <span class='color_orange'>update:58</span>:node*; t = n$17 <span class='color_orange'>update:53</span>:node*; #GB<src.c>$head = n$1199 <span class='color_orange'>update:38</span>:node*; i = 4 <span class='color_orange'>update:43</span>:int; return = n$1201 <span class='color_orange'>initial</span>:int ;
        n$1199|->{next:t <span class='color_orange'>update:56</span>, v:n$1200 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16; x|->{next:null <span class='color_orange'>update:46</span>, v:4 <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16; t|->{next:null <span class='color_orange'>update:46</span>, v:3 <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16
        [footprint
           t = @f$1; @f$2 != 0 *
           #GB<src.c>$head = @f$0 <span class='color_orange'>rearrange:38</span>:node*  ]</span>
        [SUB: 
          n$18 = 3; _t$2047 = "%d\n"]
        |-
        <span class='color_blue'></span>
    Result of Abduction
      SUB:
        n$18 = 3
      <span class='color_blue'>t != 0; MEMma &lt; malloc:38 &gt;  <span class='color_orange'>{vpath: }</span>(n$1199); MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(x); MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(t); 3 = 3 ;
      x = n$1198 <span class='color_orange'>update:45</span>:node*; n = n$17 <span class='color_orange'>update:58</span>:node*; t = n$17 <span class='color_orange'>update:53</span>:node*; #GB<src.c>$head = n$1199 <span class='color_orange'>update:38</span>:node*; i = 4 <span class='color_orange'>update:43</span>:int; format|callee = "%d\n" <span class='color_orange'>actual_precondition</span>:char const *; return = n$1201 <span class='color_orange'>initial</span>:int ;
      n$1199|->{next:t <span class='color_orange'>update:56</span>, v:n$1200 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16; x|->{next:null <span class='color_orange'>update:46</span>, v:4 <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16; t|->{next:null <span class='color_orange'>update:46</span>, v:3 <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16
      [footprint
         t = @f$1; @f$2 != 0 *
         #GB<src.c>$head = @f$0 <span class='color_orange'>rearrange:38</span>:node*  ]</span>
      [SUB: 
        n$18 = 3; _t$2047 = "%d\n"]
      |-
      <span class='color_blue'>format|callee = "%d\n" <span class='color_orange'>formal</span>:char const *</span>
    returning TRUE
      New footprint:
      
      Frame fld:
      
      Missing fld:
      
      Instantiated frame:
      n$1199|->{next:n$17 <span class='color_orange'>update:56</span>, v:n$1200 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16; n$1198|->{next:null <span class='color_orange'>update:46</span>, v:4 <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16; n$17|->{next:null <span class='color_orange'>update:46</span>, v:3 <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16; &amp;x|->n$1198 <span class='color_orange'>update:45</span>:node*; &amp;n|->n$17 <span class='color_orange'>update:58</span>:node*; &amp;t|->n$17 <span class='color_orange'>update:53</span>:node*; &amp;#GB<src.c>$head|->n$1199 <span class='color_orange'>update:38</span>:node*; &amp;i|->4 <span class='color_orange'>update:43</span>:int; &amp;return|->n$1201 <span class='color_orange'>initial</span>:int
      Instantiated post:
      PROP 1 of 1:
      <span class='color_blue'><span class='color_red'>(-1  &lt;  _t$2048)</span>; <span class='color_red'>DANGL &lt; UNINIT &gt; (return|callee)</span> ;
      <span class='color_red'>return|callee = _t$2048 <span class='color_orange'>update:54</span>:int</span></span>
      
    ***** RESULTS FUNCTION CALL *******
    PROP 1 of 1:
    <span class='color_blue'><span class='color_blue'>n$18 = 3</span> ;
    <span class='color_red'>(-1  &lt;  n$19)</span>; <span class='color_blue'>t != 0</span>; <span class='color_blue'>MEMma &lt; malloc:38 &gt;  <span class='color_orange'>{vpath: }</span>(n$1199)</span>; <span class='color_blue'>MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(x)</span>; <span class='color_blue'>MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(t)</span>; <span class='color_red'>DANGL &lt; UNINIT &gt; (n$19)</span> ;
    <span class='color_blue'>x = n$1198 <span class='color_orange'>update:45</span>:node*</span>; <span class='color_blue'>n = n$17 <span class='color_orange'>update:58</span>:node*</span>; <span class='color_blue'>t = n$17 <span class='color_orange'>update:53</span>:node*</span>; <span class='color_blue'>#GB<src.c>$head = n$1199 <span class='color_orange'>update:38</span>:node*</span>; <span class='color_blue'>i = 4 <span class='color_orange'>update:43</span>:int</span>; <span class='color_blue'>return = n$1201 <span class='color_orange'>initial</span>:int</span> ;
    <span class='color_blue'>n$1199|->{next:t <span class='color_orange'>update:56</span>, v:n$1200 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16</span>; <span class='color_blue'>x|->{next:null <span class='color_orange'>update:46</span>, v:4 <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16</span>; <span class='color_blue'>t|->{next:null <span class='color_orange'>update:46</span>, v:3 <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16</span>
    [footprint
       <span class='color_blue'>t = @f$1</span>; <span class='color_blue'>@f$2 != 0</span> *
       <span class='color_blue'>#GB<src.c>$head = @f$0 <span class='color_orange'>rearrange:38</span>:node*</span>  ]</span>
    ***** END RESULTS FUNCTION CALL *******
    Instruction Returns
    PROP 1 of 1:
    <span class='color_blue'><span class='color_blue'>n$18 = 3</span> ;
    <span class='color_red'>(-1  &lt;  n$19)</span>; <span class='color_blue'>t != 0</span>; <span class='color_blue'>MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(x)</span>; <span class='color_blue'>MEMma &lt; malloc:38 &gt;  <span class='color_orange'>{vpath: }</span>(_t$1)</span>; <span class='color_blue'>MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(t)</span>; <span class='color_red'>DANGL &lt; UNINIT &gt; (n$19)</span> ;
    <span class='color_blue'>x = _t$3 <span class='color_orange'>update:45</span>:node*</span>; <span class='color_blue'>n = n$17 <span class='color_orange'>update:58</span>:node*</span>; <span class='color_blue'>t = n$17 <span class='color_orange'>update:53</span>:node*</span>; <span class='color_blue'>#GB<src.c>$head = _t$1 <span class='color_orange'>update:38</span>:node*</span>; <span class='color_blue'>i = 4 <span class='color_orange'>update:43</span>:int</span>; <span class='color_blue'>return = _t$0 <span class='color_orange'>initial</span>:int</span> ;
    <span class='color_blue'>x|->{next:null <span class='color_orange'>update:46</span>, v:4 <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16</span>; <span class='color_blue'>_t$1|->{next:t <span class='color_orange'>update:56</span>, v:_t$2 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16</span>; <span class='color_blue'>t|->{next:null <span class='color_orange'>update:46</span>, v:3 <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16</span>
    [footprint
       <span class='color_blue'>t = @f$1</span>; <span class='color_blue'>@f$2 != 0</span> *
       <span class='color_blue'>#GB<src.c>$head = @f$0 <span class='color_orange'>rearrange:38</span>:node*</span>  ]</span>
    
    Instruction <span class='color_green'>REMOVE_TEMPS(n$17,n$18,n$19); [line 54, column 7]</span>
    in vpath_find exp:_t$5
    vpath_find: found x : node*
    in vpath_find exp:_t$4
    vpath_find: found n : node*
    in vpath_find exp:_t$1
    vpath_find: found head : node*
    Instruction Returns
    PROP 1 of 1:
    <span class='color_blue'><span class='color_red'>(-1  &lt;  _t$8)</span>; <span class='color_red'>t != 0</span>; <span class='color_red'>MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(x)</span>; <span class='color_red'>MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(n)</span>; <span class='color_blue'>MEMma &lt; malloc:38 &gt;  <span class='color_orange'>{vpath: }</span>(_t$1)</span>; <span class='color_red'>DANGL &lt; UNINIT &gt; (_t$8)</span>; <span class='color_blue'>DANGL &lt; UNINIT &gt; (_t$5)</span> ;
    <span class='color_blue'>x = <span class='color_red'>_t$7 <span class='color_orange'>update:45</span></span>:node*</span>; <span class='color_blue'>n = <span class='color_red'>_t$6 <span class='color_orange'>update:58</span></span>:node*</span>; <span class='color_blue'>t = <span class='color_red'>_t$2 <span class='color_orange'>update:53</span></span>:node*</span>; <span class='color_blue'>#GB<src.c>$head = _t$1 <span class='color_orange'>update:38</span>:node*</span>; <span class='color_blue'>i = 4 <span class='color_orange'>update:43</span>:int</span>; <span class='color_blue'>return = _t$0 <span class='color_orange'>initial</span>:int</span> ;
    <span class='color_red'>x|->{next:null <span class='color_orange'>update:46</span>, v:4 <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16</span>; <span class='color_red'>n|->{next:null <span class='color_orange'>update:46</span>, v:3 <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16</span>; <span class='color_red'>t|->{next:_t$4 <span class='color_orange'>update:56</span>, v:_t$5 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16</span>; <span class='color_blue'>_t$1|->{next:<span class='color_red'>t <span class='color_orange'>update:56</span></span>, v:<span class='color_red'>_t$3 <span class='color_orange'>alloc</span></span>} <span class='color_orange'>alloc</span>:node16</span>; <span class='color_blue'>lseg(_t$4,n,[],P0)</span>
    [footprint
       <span class='color_blue'>@f$1 != 0</span> *
       <span class='color_blue'>#GB<src.c>$head = @f$0 <span class='color_orange'>rearrange:38</span>:node*</span>  ]
    where
    P0 = exists [_t$2]. <span class='color_blue'>_t$0|->{next:_t$1 <span class='color_orange'>update:56</span>, v:_t$2 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16</span></span>
    
    Instruction <span class='color_green'>REMOVE_TEMPS(n$17,n$18,n$19); [line 54, column 7]</span>
    in vpath_find exp:_t$3
    vpath_find: found x : node*
    in vpath_find exp:_t$1
    vpath_find: found head : node*
    in vpath_find exp:n$17
    vpath_find: found n : node*
    Instruction Returns
    PROP 1 of 1:
    <span class='color_blue'><span class='color_red'>(-1  &lt;  _t$5)</span>; <span class='color_red'>t != 0</span>; <span class='color_red'>MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(x)</span>; <span class='color_red'>MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(t)</span>; <span class='color_blue'>MEMma &lt; malloc:38 &gt;  <span class='color_orange'>{vpath: }</span>(_t$1)</span>; <span class='color_red'>DANGL &lt; UNINIT &gt; (_t$5)</span> ;
    <span class='color_blue'>x = <span class='color_red'>_t$4 <span class='color_orange'>update:45</span></span>:node*</span>; <span class='color_blue'>n = <span class='color_red'>_t$2 <span class='color_orange'>update:58</span></span>:node*</span>; <span class='color_blue'>t = <span class='color_red'>_t$2 <span class='color_orange'>update:53</span></span>:node*</span>; <span class='color_blue'>#GB<src.c>$head = _t$1 <span class='color_orange'>update:38</span>:node*</span>; <span class='color_blue'>i = 4 <span class='color_orange'>update:43</span>:int</span>; <span class='color_blue'>return = _t$0 <span class='color_orange'>initial</span>:int</span> ;
    <span class='color_red'>x|->{next:null <span class='color_orange'>update:46</span>, v:4 <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16</span>; <span class='color_red'>t|->{next:null <span class='color_orange'>update:46</span>, v:3 <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16</span>; <span class='color_blue'>_t$1|->{next:<span class='color_red'>t <span class='color_orange'>update:56</span></span>, v:<span class='color_red'>_t$3 <span class='color_orange'>alloc</span></span>} <span class='color_orange'>alloc</span>:node16</span>
    [footprint
       <span class='color_blue'>@f$2 = @f$1</span>; <span class='color_red'>@f$3 != 0</span> *
       <span class='color_blue'>#GB<src.c>$head = @f$0 <span class='color_orange'>rearrange:38</span>:node*</span>  ]</span>
    
    Instruction <span class='color_green'>APPLY_ABSTRACTION; [line 54, column 7]</span>
    in vpath_find exp:_t$7
    vpath_find: found x : node*
    in vpath_find exp:_t$6
    vpath_find: found n : node*
    in vpath_find exp:_t$1
    vpath_find: found head : node*
    <span class='color_blue'>t != 0; MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(x); MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(n); MEMma &lt; malloc:38 &gt;  <span class='color_orange'>{vpath: }</span>(_t$1) ;
    x = _t$5 <span class='color_orange'>update:45</span>:node*; n = _t$4 <span class='color_orange'>update:58</span>:node*; t = _t$2 <span class='color_orange'>update:53</span>:node*; #GB<src.c>$head = _t$1 <span class='color_orange'>update:38</span>:node*; i = 4 <span class='color_orange'>update:43</span>:int; return = _t$0 <span class='color_orange'>initial</span>:int ;
    x|->{next:null <span class='color_orange'>update:46</span>, v:4 <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16; n|->{next:null <span class='color_orange'>update:46</span>, v:3 <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16; _t$1|->{next:t <span class='color_orange'>update:56</span>, v:_t$3 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16; lsegne(t,n,[],P0)
    [footprint
       #GB<src.c>$head = @f$0 <span class='color_orange'>rearrange:38</span>:node*  ]
    where
    P0 = exists [_t$2]. _t$0|->{next:_t$1 <span class='color_orange'>update:56</span>, v:_t$2 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16</span>
    Instruction Returns
    PROP 1 of 1:
    <span class='color_blue'><span class='color_blue'>t != 0</span>; <span class='color_blue'>MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(x)</span>; <span class='color_red'>MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(n)</span>; <span class='color_blue'>MEMma &lt; malloc:38 &gt;  <span class='color_orange'>{vpath: }</span>(_t$1)</span> ;
    <span class='color_blue'>x = <span class='color_red'>_t$5 <span class='color_orange'>update:45</span></span>:node*</span>; <span class='color_blue'>n = <span class='color_red'>_t$4 <span class='color_orange'>update:58</span></span>:node*</span>; <span class='color_blue'>t = _t$2 <span class='color_orange'>update:53</span>:node*</span>; <span class='color_blue'>#GB<src.c>$head = _t$1 <span class='color_orange'>update:38</span>:node*</span>; <span class='color_blue'>i = 4 <span class='color_orange'>update:43</span>:int</span>; <span class='color_blue'>return = _t$0 <span class='color_orange'>initial</span>:int</span> ;
    <span class='color_red'>x|->{next:null <span class='color_orange'>update:46</span>, v:4 <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16</span>; <span class='color_blue'>n|->{next:null <span class='color_orange'>update:46</span>, v:3 <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16</span>; <span class='color_blue'>_t$1|->{next:t <span class='color_orange'>update:56</span>, v:_t$3 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16</span>; <span class='color_blue'>lsegne(t,n,[],P0)</span>
    [footprint
       <span class='color_blue'>#GB<src.c>$head = @f$0 <span class='color_orange'>rearrange:38</span>:node*</span>  ]
    where
    P0 = exists [_t$2]. <span class='color_blue'>_t$0|->{next:_t$1 <span class='color_orange'>update:56</span>, v:_t$2 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16</span></span>
    
    Instruction <span class='color_green'>APPLY_ABSTRACTION; [line 54, column 7]</span>
    in vpath_find exp:_t$4
    vpath_find: found x : node*
    in vpath_find exp:_t$2
    vpath_find: found n : node*
    in vpath_find exp:_t$1
    vpath_find: found head : node*
    <span class='color_blue'>t != 0; MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(x); MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(t); MEMma &lt; malloc:38 &gt;  <span class='color_orange'>{vpath: }</span>(_t$1) ;
    x = _t$4 <span class='color_orange'>update:45</span>:node*; n = _t$2 <span class='color_orange'>update:58</span>:node*; t = _t$2 <span class='color_orange'>update:53</span>:node*; #GB<src.c>$head = _t$1 <span class='color_orange'>update:38</span>:node*; i = 4 <span class='color_orange'>update:43</span>:int; return = _t$0 <span class='color_orange'>initial</span>:int ;
    x|->{next:null <span class='color_orange'>update:46</span>, v:4 <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16; t|->{next:null <span class='color_orange'>update:46</span>, v:3 <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16; _t$1|->{next:t <span class='color_orange'>update:56</span>, v:_t$3 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16
    [footprint
       #GB<src.c>$head = @f$0 <span class='color_orange'>rearrange:38</span>:node*  ]</span>
    Instruction Returns
    PROP 1 of 1:
    <span class='color_blue'><span class='color_blue'>t != 0</span>; <span class='color_blue'>MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(x)</span>; <span class='color_blue'>MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(t)</span>; <span class='color_blue'>MEMma &lt; malloc:38 &gt;  <span class='color_orange'>{vpath: }</span>(_t$1)</span> ;
    <span class='color_blue'>x = _t$4 <span class='color_orange'>update:45</span>:node*</span>; <span class='color_blue'>n = _t$2 <span class='color_orange'>update:58</span>:node*</span>; <span class='color_blue'>t = _t$2 <span class='color_orange'>update:53</span>:node*</span>; <span class='color_blue'>#GB<src.c>$head = _t$1 <span class='color_orange'>update:38</span>:node*</span>; <span class='color_blue'>i = 4 <span class='color_orange'>update:43</span>:int</span>; <span class='color_blue'>return = _t$0 <span class='color_orange'>initial</span>:int</span> ;
    <span class='color_blue'>x|->{next:null <span class='color_orange'>update:46</span>, v:4 <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16</span>; <span class='color_blue'>t|->{next:null <span class='color_orange'>update:46</span>, v:3 <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16</span>; <span class='color_blue'>_t$1|->{next:t <span class='color_orange'>update:56</span>, v:_t$3 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16</span>
    [footprint
       <span class='color_blue'>#GB<src.c>$head = @f$0 <span class='color_orange'>rearrange:38</span>:node*</span>  ]</span>
    
    .... After Symbolic Execution ....
    PROP 1 of 2:
    <span class='color_blue'><span class='color_blue'>t != 0</span>; <span class='color_blue'>MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(x)</span>; <span class='color_blue'>MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(n)</span>; <span class='color_blue'>MEMma &lt; malloc:38 &gt;  <span class='color_orange'>{vpath: }</span>(_t$1)</span> ;
    <span class='color_blue'>x = _t$5 <span class='color_orange'>update:45</span>:node*</span>; <span class='color_blue'>n = _t$4 <span class='color_orange'>update:58</span>:node*</span>; <span class='color_blue'>t = _t$2 <span class='color_orange'>update:53</span>:node*</span>; <span class='color_blue'>#GB<src.c>$head = _t$1 <span class='color_orange'>update:38</span>:node*</span>; <span class='color_blue'>i = 4 <span class='color_orange'>update:43</span>:int</span>; <span class='color_blue'>return = _t$0 <span class='color_orange'>initial</span>:int</span> ;
    <span class='color_blue'>x|->{next:null <span class='color_orange'>update:46</span>, v:4 <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16</span>; <span class='color_blue'>n|->{next:null <span class='color_orange'>update:46</span>, v:3 <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16</span>; <span class='color_blue'>_t$1|->{next:t <span class='color_orange'>update:56</span>, v:_t$3 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16</span>; <span class='color_blue'>lsegne(t,n,[],P0)</span>
    [footprint
       <span class='color_blue'>#GB<src.c>$head = @f$0 <span class='color_orange'>rearrange:38</span>:node*</span>  ]
    where
    P0 = exists [_t$2]. <span class='color_blue'>_t$0|->{next:_t$1 <span class='color_orange'>update:56</span>, v:_t$2 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16</span></span>
    PROP 2 of 2:
    <span class='color_blue'><span class='color_blue'>t != 0</span>; <span class='color_blue'>MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(x)</span>; <span class='color_blue'>MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(t)</span>; <span class='color_blue'>MEMma &lt; malloc:38 &gt;  <span class='color_orange'>{vpath: }</span>(_t$1)</span> ;
    <span class='color_blue'>x = <span class='color_red'>_t$4 <span class='color_orange'>update:45</span></span>:node*</span>; <span class='color_blue'>n = <span class='color_red'>_t$2 <span class='color_orange'>update:58</span></span>:node*</span>; <span class='color_blue'>t = _t$2 <span class='color_orange'>update:53</span>:node*</span>; <span class='color_blue'>#GB<src.c>$head = _t$1 <span class='color_orange'>update:38</span>:node*</span>; <span class='color_blue'>i = 4 <span class='color_orange'>update:43</span>:int</span>; <span class='color_blue'>return = _t$0 <span class='color_orange'>initial</span>:int</span> ;
    <span class='color_blue'>x|->{next:null <span class='color_orange'>update:46</span>, v:<span class='color_red'>4 <span class='color_orange'>update:47</span></span>} <span class='color_orange'>alloc</span>:node16</span>; <span class='color_blue'>t|->{next:null <span class='color_orange'>update:46</span>, v:3 <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16</span>; <span class='color_blue'>_t$1|->{next:t <span class='color_orange'>update:56</span>, v:_t$3 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16</span>
    [footprint
       <span class='color_blue'>#GB<src.c>$head = @f$0 <span class='color_orange'>rearrange:38</span>:node*</span>  ]</span>
    
    
    
  Processing prop 3/3
    Instruction <span class='color_green'>n$17=*&amp;t:node* [line 54, column 21]</span>
    in vpath_find exp:n$1204
    vpath_find: found head : node*
    in vpath_find exp:n$1203
    vpath_find: found head->next : node*
    in vpath_find exp:n$1202
    vpath_find: found x : node*
    .... Rearrangement Start ....
    Exp: &amp;t
    Prop: 
    <span class='color_blue'>(@f$0  &lt;=  8); t != 0; MEMma &lt; malloc:38 &gt;  <span class='color_orange'>{vpath: }</span>(n$1204); MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(t); MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(x) ;
    x = n$1202 <span class='color_orange'>update:45</span>:node*; n = null <span class='color_orange'>update:40</span>:node*; t = n$1203 <span class='color_orange'>update:53</span>:node*; #GB<src.c>$head = n$1204 <span class='color_orange'>update:38</span>:node*; i = (@f$0 + 1) <span class='color_orange'>update:43</span>:int; return = n$1206 <span class='color_orange'>initial</span>:int ;
    n$1204|->{next:t <span class='color_orange'>update:56</span>, v:n$1205 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16; t|->{next:null <span class='color_orange'>update:46</span>, v:@f$0 <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16; x|->{next:null <span class='color_orange'>update:46</span>, v:(@f$0 + 1) <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16
    [footprint
       (@f$0  &lt;=  8); @f$2 != 0 *
       #GB<src.c>$head = @f$1 <span class='color_orange'>rearrange:38</span>:node*  ]</span>
    
    in prop_iter_extend_ptsto lexp: &amp;t
    prop before:
    <span class='color_blue'>(@f$0  &lt;=  8); t != 0; MEMma &lt; malloc:38 &gt;  <span class='color_orange'>{vpath: }</span>(n$1204); MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(t); MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(x) ;
    x = n$1202 <span class='color_orange'>update:45</span>:node*; n = null <span class='color_orange'>update:40</span>:node*; t = n$1203 <span class='color_orange'>update:53</span>:node*; #GB<src.c>$head = n$1204 <span class='color_orange'>update:38</span>:node*; i = (@f$0 + 1) <span class='color_orange'>update:43</span>:int; return = n$1206 <span class='color_orange'>initial</span>:int ;
    n$1204|->{next:t <span class='color_orange'>update:56</span>, v:n$1205 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16; t|->{next:null <span class='color_orange'>update:46</span>, v:@f$0 <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16; x|->{next:null <span class='color_orange'>update:46</span>, v:(@f$0 + 1) <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16
    [footprint
       (@f$0  &lt;=  8); @f$2 != 0 *
       #GB<src.c>$head = @f$1 <span class='color_orange'>rearrange:38</span>:node*  ]</span>
    
    
    prop list after:
    PROP 1 of 1:
    <span class='color_blue'><span class='color_blue'>(@f$0  &lt;=  8)</span>; <span class='color_blue'>t != 0</span>; <span class='color_blue'>MEMma &lt; malloc:38 &gt;  <span class='color_orange'>{vpath: }</span>(n$1204)</span>; <span class='color_blue'>MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(t)</span>; <span class='color_blue'>MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(x)</span> ;
    <span class='color_blue'>x = n$1202 <span class='color_orange'>update:45</span>:node*</span>; <span class='color_blue'>n = null <span class='color_orange'>update:40</span>:node*</span>; <span class='color_blue'>t = n$1203 <span class='color_orange'>update:53</span>:node*</span>; <span class='color_blue'>#GB<src.c>$head = n$1204 <span class='color_orange'>update:38</span>:node*</span>; <span class='color_blue'>i = (@f$0 + 1) <span class='color_orange'>update:43</span>:int</span>; <span class='color_blue'>return = n$1206 <span class='color_orange'>initial</span>:int</span> ;
    <span class='color_blue'>n$1204|->{next:t <span class='color_orange'>update:56</span>, v:n$1205 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16</span>; <span class='color_blue'>t|->{next:null <span class='color_orange'>update:46</span>, v:@f$0 <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16</span>; <span class='color_blue'>x|->{next:null <span class='color_orange'>update:46</span>, v:(@f$0 + 1) <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16</span>
    [footprint
       <span class='color_blue'>(@f$0  &lt;=  8)</span>; <span class='color_blue'>@f$2 != 0</span> *
       <span class='color_blue'>#GB<src.c>$head = @f$1 <span class='color_orange'>rearrange:38</span>:node*</span>  ]</span>
    
    
    
    Instruction Returns
    PROP 1 of 1:
    <span class='color_blue'><span class='color_blue'>(@f$0  &lt;=  8)</span>; <span class='color_red'>t != 0</span>; <span class='color_red'>MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(x)</span>; <span class='color_blue'>MEMma &lt; malloc:38 &gt;  <span class='color_orange'>{vpath: }</span>(_t$1)</span>; <span class='color_red'>MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(t)</span> ;
    <span class='color_blue'>x = <span class='color_red'>_t$3 <span class='color_orange'>update:45</span></span>:node*</span>; <span class='color_blue'>n = null <span class='color_orange'>update:40</span>:node*</span>; <span class='color_blue'>t = <span class='color_red'>n$17 <span class='color_orange'>update:53</span></span>:node*</span>; <span class='color_blue'>#GB<src.c>$head = _t$1 <span class='color_orange'>update:38</span>:node*</span>; <span class='color_blue'>i = (@f$0 + 1) <span class='color_orange'>update:43</span>:int</span>; <span class='color_blue'>return = _t$0 <span class='color_orange'>initial</span>:int</span> ;
    <span class='color_red'>x|->{next:null <span class='color_orange'>update:46</span>, v:(@f$0 + 1) <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16</span>; <span class='color_blue'>_t$1|->{next:<span class='color_red'>t <span class='color_orange'>update:56</span></span>, v:<span class='color_red'>_t$2 <span class='color_orange'>alloc</span></span>} <span class='color_orange'>alloc</span>:node16</span>; <span class='color_red'>t|->{next:null <span class='color_orange'>update:46</span>, v:@f$0 <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16</span>
    [footprint
       <span class='color_blue'>(@f$0  &lt;=  8)</span>; <span class='color_blue'>@f$2 != 0</span> *
       <span class='color_blue'>#GB<src.c>$head = @f$1 <span class='color_orange'>rearrange:38</span>:node*</span>  ]</span>
    
    Instruction <span class='color_green'>n$18=*n$17.v:int [line 54, column 21]</span>
    in vpath_find exp:n$1208
    vpath_find: found head : node*
    in vpath_find exp:n$1207
    vpath_find: found x : node*
    in vpath_find exp:n$17
    vpath_find: found head->next : node*
    .... Rearrangement Start ....
    Exp: n$17.v
    Prop: 
    <span class='color_blue'>(@f$0  &lt;=  8); t != 0; MEMma &lt; malloc:38 &gt;  <span class='color_orange'>{vpath: }</span>(n$1208); MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(x); MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(t) ;
    x = n$1207 <span class='color_orange'>update:45</span>:node*; n = null <span class='color_orange'>update:40</span>:node*; t = n$17 <span class='color_orange'>update:53</span>:node*; #GB<src.c>$head = n$1208 <span class='color_orange'>update:38</span>:node*; i = (@f$0 + 1) <span class='color_orange'>update:43</span>:int; return = n$1210 <span class='color_orange'>initial</span>:int ;
    n$1208|->{next:t <span class='color_orange'>update:56</span>, v:n$1209 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16; x|->{next:null <span class='color_orange'>update:46</span>, v:(@f$0 + 1) <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16; t|->{next:null <span class='color_orange'>update:46</span>, v:@f$0 <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16
    [footprint
       (@f$0  &lt;=  8); @f$2 != 0 *
       #GB<src.c>$head = @f$1 <span class='color_orange'>rearrange:38</span>:node*  ]</span>
    
    in prop_iter_extend_ptsto lexp: n$17.v
    prop before:
    <span class='color_blue'>(@f$0  &lt;=  8); t != 0; MEMma &lt; malloc:38 &gt;  <span class='color_orange'>{vpath: }</span>(n$1208); MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(x); MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(t) ;
    x = n$1207 <span class='color_orange'>update:45</span>:node*; n = null <span class='color_orange'>update:40</span>:node*; t = n$17 <span class='color_orange'>update:53</span>:node*; #GB<src.c>$head = n$1208 <span class='color_orange'>update:38</span>:node*; i = (@f$0 + 1) <span class='color_orange'>update:43</span>:int; return = n$1210 <span class='color_orange'>initial</span>:int ;
    n$1208|->{next:t <span class='color_orange'>update:56</span>, v:n$1209 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16; x|->{next:null <span class='color_orange'>update:46</span>, v:(@f$0 + 1) <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16; t|->{next:null <span class='color_orange'>update:46</span>, v:@f$0 <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16
    [footprint
       (@f$0  &lt;=  8); @f$2 != 0 *
       #GB<src.c>$head = @f$1 <span class='color_orange'>rearrange:38</span>:node*  ]</span>
    
    
    prop list after:
    PROP 1 of 1:
    <span class='color_blue'><span class='color_blue'>(@f$0  &lt;=  8)</span>; <span class='color_blue'>t != 0</span>; <span class='color_blue'>MEMma &lt; malloc:38 &gt;  <span class='color_orange'>{vpath: }</span>(n$1208)</span>; <span class='color_blue'>MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(x)</span>; <span class='color_blue'>MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(t)</span> ;
    <span class='color_blue'>x = n$1207 <span class='color_orange'>update:45</span>:node*</span>; <span class='color_blue'>n = null <span class='color_orange'>update:40</span>:node*</span>; <span class='color_blue'>t = n$17 <span class='color_orange'>update:53</span>:node*</span>; <span class='color_blue'>#GB<src.c>$head = n$1208 <span class='color_orange'>update:38</span>:node*</span>; <span class='color_blue'>i = (@f$0 + 1) <span class='color_orange'>update:43</span>:int</span>; <span class='color_blue'>return = n$1210 <span class='color_orange'>initial</span>:int</span> ;
    <span class='color_blue'>n$1208|->{next:t <span class='color_orange'>update:56</span>, v:n$1209 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16</span>; <span class='color_blue'>x|->{next:null <span class='color_orange'>update:46</span>, v:(@f$0 + 1) <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16</span>; <span class='color_blue'>t|->{next:null <span class='color_orange'>update:46</span>, v:@f$0 <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16</span>
    [footprint
       <span class='color_blue'>(@f$0  &lt;=  8)</span>; <span class='color_blue'>@f$2 != 0</span> *
       <span class='color_blue'>#GB<src.c>$head = @f$1 <span class='color_orange'>rearrange:38</span>:node*</span>  ]</span>
    
    
    
    Instruction Returns
    PROP 1 of 1:
    <span class='color_blue'><span class='color_red'>n$18 = @f$0</span> ;
    <span class='color_blue'>(@f$0  &lt;=  8)</span>; <span class='color_blue'>t != 0</span>; <span class='color_blue'>MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(x)</span>; <span class='color_blue'>MEMma &lt; malloc:38 &gt;  <span class='color_orange'>{vpath: }</span>(_t$1)</span>; <span class='color_blue'>MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(t)</span> ;
    <span class='color_blue'>x = _t$3 <span class='color_orange'>update:45</span>:node*</span>; <span class='color_blue'>n = null <span class='color_orange'>update:40</span>:node*</span>; <span class='color_blue'>t = n$17 <span class='color_orange'>update:53</span>:node*</span>; <span class='color_blue'>#GB<src.c>$head = _t$1 <span class='color_orange'>update:38</span>:node*</span>; <span class='color_blue'>i = (@f$0 + 1) <span class='color_orange'>update:43</span>:int</span>; <span class='color_blue'>return = _t$0 <span class='color_orange'>initial</span>:int</span> ;
    <span class='color_blue'>x|->{next:null <span class='color_orange'>update:46</span>, v:(@f$0 + 1) <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16</span>; <span class='color_blue'>_t$1|->{next:t <span class='color_orange'>update:56</span>, v:_t$2 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16</span>; <span class='color_blue'>t|->{next:null <span class='color_orange'>update:46</span>, v:@f$0 <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16</span>
    [footprint
       <span class='color_blue'>(@f$0  &lt;=  8)</span>; <span class='color_blue'>@f$2 != 0</span> *
       <span class='color_blue'>#GB<src.c>$head = @f$1 <span class='color_orange'>rearrange:38</span>:node*</span>  ]</span>
    
    Instruction <span class='color_green'>n$19=_fun_printf("%d\n":char const *,n$18:int) [line 54, column 7]</span>
    in vpath_find exp:n$1212
    vpath_find: found head : node*
    in vpath_find exp:n$1211
    vpath_find: found x : node*
    in vpath_find exp:n$17
    vpath_find: found head->next : node*
    <span class='color_orange'>WARNING: likely use of variable-arguments function, or function prototype missing</span>
    actual parameters: @f$0
    formal parameters: 
    Found 1 specs for function printf
    START EXECUTING SPECS FOR printf from state
    <span class='color_blue'>n$18 = @f$0 ;
    (@f$0  &lt;=  8); t != 0; MEMma &lt; malloc:38 &gt;  <span class='color_orange'>{vpath: }</span>(n$1212); MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(x); MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(t) ;
    x = n$1211 <span class='color_orange'>update:45</span>:node*; n = null <span class='color_orange'>update:40</span>:node*; t = n$17 <span class='color_orange'>update:53</span>:node*; #GB<src.c>$head = n$1212 <span class='color_orange'>update:38</span>:node*; i = (@f$0 + 1) <span class='color_orange'>update:43</span>:int; return = n$1214 <span class='color_orange'>initial</span>:int ;
    n$1212|->{next:t <span class='color_orange'>update:56</span>, v:n$1213 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16; x|->{next:null <span class='color_orange'>update:46</span>, v:(@f$0 + 1) <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16; t|->{next:null <span class='color_orange'>update:46</span>, v:@f$0 <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16
    [footprint
       (@f$0  &lt;=  8); @f$2 != 0 *
       #GB<src.c>$head = @f$1 <span class='color_orange'>rearrange:38</span>:node*  ]</span>
    <span class='color_orange'>WARNING: more actual pars than formal pars in fun call (2 vs 1)</span>
    EXECUTING SPEC 1/1
    ACTUAL PRECONDITION =
      <span class='color_blue'>n$18 = @f$0 ;
      (@f$0  &lt;=  8); t != 0; MEMma &lt; malloc:38 &gt;  <span class='color_orange'>{vpath: }</span>(n$1212); MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(x); MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(t) ;
      x = n$1211 <span class='color_orange'>update:45</span>:node*; n = null <span class='color_orange'>update:40</span>:node*; t = n$17 <span class='color_orange'>update:53</span>:node*; #GB<src.c>$head = n$1212 <span class='color_orange'>update:38</span>:node*; i = (@f$0 + 1) <span class='color_orange'>update:43</span>:int; format|callee = "%d\n" <span class='color_orange'>actual_precondition</span>:char const *; return = n$1214 <span class='color_orange'>initial</span>:int ;
      n$1212|->{next:t <span class='color_orange'>update:56</span>, v:n$1213 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16; x|->{next:null <span class='color_orange'>update:46</span>, v:(@f$0 + 1) <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16; t|->{next:null <span class='color_orange'>update:46</span>, v:@f$0 <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16
      [footprint
         (@f$0  &lt;=  8); @f$2 != 0 *
         #GB<src.c>$head = @f$1 <span class='color_orange'>rearrange:38</span>:node*  ]</span>
    SPEC =
      --------------------------- ---------- ---------------------------
      PRE:
      <span class='color_blue'><span class='color_blue'>format|callee = _t$2089 <span class='color_orange'>formal</span>:char const *</span></span>
      POST 1 of 1:
      <span class='color_blue'><span class='color_red'>(-1  &lt;  _t$2090)</span>; <span class='color_red'>DANGL &lt; UNINIT &gt; (return|callee)</span> ;
      <span class='color_red'>return|callee = _t$2090 <span class='color_orange'>update:1114</span>:int</span></span>
      ----------------------------------------------------------------
    pre_check_pure_implication
    pi1:
      n$18 = @f$0; (@f$0  &lt;=  8); n$17 != 0; MEMma &lt; malloc:38 &gt;  <span class='color_orange'>{vpath: }</span>(n$1212); MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(n$1211); MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(n$17)
    pi2:
      
    returns
    sub1: 
      n$18 = @f$0
    sub2: 
      
    Current Implication
    SUB:
      n$18 = @f$0
    <span class='color_blue'>(@f$0  &lt;=  8); t != 0; MEMma &lt; malloc:38 &gt;  <span class='color_orange'>{vpath: }</span>(n$1212); MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(x); MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(t); @f$0 = @f$0 ;
    x = n$1211 <span class='color_orange'>update:45</span>:node*; n = null <span class='color_orange'>update:40</span>:node*; t = n$17 <span class='color_orange'>update:53</span>:node*; #GB<src.c>$head = n$1212 <span class='color_orange'>update:38</span>:node*; i = (@f$0 + 1) <span class='color_orange'>update:43</span>:int; format|callee = "%d\n" <span class='color_orange'>actual_precondition</span>:char const *; return = n$1214 <span class='color_orange'>initial</span>:int ;
    n$1212|->{next:t <span class='color_orange'>update:56</span>, v:n$1213 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16; x|->{next:null <span class='color_orange'>update:46</span>, v:(@f$0 + 1) <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16; t|->{next:null <span class='color_orange'>update:46</span>, v:@f$0 <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16
    [footprint
       (@f$0  &lt;=  8); @f$2 != 0 *
       #GB<src.c>$head = @f$1 <span class='color_orange'>rearrange:38</span>:node*  ]</span>
    |-
    <span class='color_blue'>format|callee = _t$2089 <span class='color_orange'>formal</span>:char const *</span>
    
      do_imply "%d\n" _t$2089
        Final Implication
        SUB:
          n$18 = @f$0
        <span class='color_blue'>(@f$0  &lt;=  8); t != 0; MEMma &lt; malloc:38 &gt;  <span class='color_orange'>{vpath: }</span>(n$1212); MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(x); MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(t); @f$0 = @f$0 ;
        x = n$1211 <span class='color_orange'>update:45</span>:node*; n = null <span class='color_orange'>update:40</span>:node*; t = n$17 <span class='color_orange'>update:53</span>:node*; #GB<src.c>$head = n$1212 <span class='color_orange'>update:38</span>:node*; i = (@f$0 + 1) <span class='color_orange'>update:43</span>:int; return = n$1214 <span class='color_orange'>initial</span>:int ;
        n$1212|->{next:t <span class='color_orange'>update:56</span>, v:n$1213 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16; x|->{next:null <span class='color_orange'>update:46</span>, v:(@f$0 + 1) <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16; t|->{next:null <span class='color_orange'>update:46</span>, v:@f$0 <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16
        [footprint
           (@f$0  &lt;=  8); @f$2 != 0 *
           #GB<src.c>$head = @f$1 <span class='color_orange'>rearrange:38</span>:node*  ]</span>
        [SUB: 
          _t$2089 = "%d\n"]
        |-
        <span class='color_blue'></span>
    Result of Abduction
      SUB:
        n$18 = @f$0
      <span class='color_blue'>(@f$0  &lt;=  8); t != 0; MEMma &lt; malloc:38 &gt;  <span class='color_orange'>{vpath: }</span>(n$1212); MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(x); MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(t); @f$0 = @f$0 ;
      x = n$1211 <span class='color_orange'>update:45</span>:node*; n = null <span class='color_orange'>update:40</span>:node*; t = n$17 <span class='color_orange'>update:53</span>:node*; #GB<src.c>$head = n$1212 <span class='color_orange'>update:38</span>:node*; i = (@f$0 + 1) <span class='color_orange'>update:43</span>:int; format|callee = "%d\n" <span class='color_orange'>actual_precondition</span>:char const *; return = n$1214 <span class='color_orange'>initial</span>:int ;
      n$1212|->{next:t <span class='color_orange'>update:56</span>, v:n$1213 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16; x|->{next:null <span class='color_orange'>update:46</span>, v:(@f$0 + 1) <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16; t|->{next:null <span class='color_orange'>update:46</span>, v:@f$0 <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16
      [footprint
         (@f$0  &lt;=  8); @f$2 != 0 *
         #GB<src.c>$head = @f$1 <span class='color_orange'>rearrange:38</span>:node*  ]</span>
      [SUB: 
        _t$2089 = "%d\n"]
      |-
      <span class='color_blue'>format|callee = "%d\n" <span class='color_orange'>formal</span>:char const *</span>
    returning TRUE
      New footprint:
      
      Frame fld:
      
      Missing fld:
      
      Instantiated frame:
      n$1212|->{next:n$17 <span class='color_orange'>update:56</span>, v:n$1213 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16; n$1211|->{next:null <span class='color_orange'>update:46</span>, v:(@f$0 + 1) <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16; n$17|->{next:null <span class='color_orange'>update:46</span>, v:@f$0 <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16; &amp;x|->n$1211 <span class='color_orange'>update:45</span>:node*; &amp;n|->null <span class='color_orange'>update:40</span>:node*; &amp;t|->n$17 <span class='color_orange'>update:53</span>:node*; &amp;#GB<src.c>$head|->n$1212 <span class='color_orange'>update:38</span>:node*; &amp;i|->(@f$0 + 1) <span class='color_orange'>update:43</span>:int; &amp;return|->n$1214 <span class='color_orange'>initial</span>:int
      Instantiated post:
      PROP 1 of 1:
      <span class='color_blue'><span class='color_red'>(-1  &lt;  _t$2090)</span>; <span class='color_red'>DANGL &lt; UNINIT &gt; (return|callee)</span> ;
      <span class='color_red'>return|callee = _t$2090 <span class='color_orange'>update:54</span>:int</span></span>
      
    ***** RESULTS FUNCTION CALL *******
    PROP 1 of 1:
    <span class='color_blue'><span class='color_blue'>n$18 = @f$0</span> ;
    <span class='color_red'>(-1  &lt;  n$19)</span>; <span class='color_blue'>(@f$0  &lt;=  8)</span>; <span class='color_blue'>t != 0</span>; <span class='color_blue'>MEMma &lt; malloc:38 &gt;  <span class='color_orange'>{vpath: }</span>(n$1212)</span>; <span class='color_blue'>MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(x)</span>; <span class='color_blue'>MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(t)</span>; <span class='color_red'>DANGL &lt; UNINIT &gt; (n$19)</span> ;
    <span class='color_blue'>x = n$1211 <span class='color_orange'>update:45</span>:node*</span>; <span class='color_blue'>n = null <span class='color_orange'>update:40</span>:node*</span>; <span class='color_blue'>t = n$17 <span class='color_orange'>update:53</span>:node*</span>; <span class='color_blue'>#GB<src.c>$head = n$1212 <span class='color_orange'>update:38</span>:node*</span>; <span class='color_blue'>i = (@f$0 + 1) <span class='color_orange'>update:43</span>:int</span>; <span class='color_blue'>return = n$1214 <span class='color_orange'>initial</span>:int</span> ;
    <span class='color_blue'>n$1212|->{next:t <span class='color_orange'>update:56</span>, v:n$1213 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16</span>; <span class='color_blue'>x|->{next:null <span class='color_orange'>update:46</span>, v:(@f$0 + 1) <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16</span>; <span class='color_blue'>t|->{next:null <span class='color_orange'>update:46</span>, v:@f$0 <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16</span>
    [footprint
       <span class='color_blue'>(@f$0  &lt;=  8)</span>; <span class='color_blue'>@f$2 != 0</span> *
       <span class='color_blue'>#GB<src.c>$head = @f$1 <span class='color_orange'>rearrange:38</span>:node*</span>  ]</span>
    ***** END RESULTS FUNCTION CALL *******
    Instruction Returns
    PROP 1 of 1:
    <span class='color_blue'><span class='color_blue'>n$18 = @f$0</span> ;
    <span class='color_red'>(-1  &lt;  n$19)</span>; <span class='color_blue'>(@f$0  &lt;=  8)</span>; <span class='color_blue'>t != 0</span>; <span class='color_blue'>MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(x)</span>; <span class='color_blue'>MEMma &lt; malloc:38 &gt;  <span class='color_orange'>{vpath: }</span>(_t$1)</span>; <span class='color_blue'>MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(t)</span>; <span class='color_red'>DANGL &lt; UNINIT &gt; (n$19)</span> ;
    <span class='color_blue'>x = _t$3 <span class='color_orange'>update:45</span>:node*</span>; <span class='color_blue'>n = null <span class='color_orange'>update:40</span>:node*</span>; <span class='color_blue'>t = n$17 <span class='color_orange'>update:53</span>:node*</span>; <span class='color_blue'>#GB<src.c>$head = _t$1 <span class='color_orange'>update:38</span>:node*</span>; <span class='color_blue'>i = (@f$0 + 1) <span class='color_orange'>update:43</span>:int</span>; <span class='color_blue'>return = _t$0 <span class='color_orange'>initial</span>:int</span> ;
    <span class='color_blue'>x|->{next:null <span class='color_orange'>update:46</span>, v:(@f$0 + 1) <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16</span>; <span class='color_blue'>_t$1|->{next:t <span class='color_orange'>update:56</span>, v:_t$2 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16</span>; <span class='color_blue'>t|->{next:null <span class='color_orange'>update:46</span>, v:@f$0 <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16</span>
    [footprint
       <span class='color_blue'>(@f$0  &lt;=  8)</span>; <span class='color_blue'>@f$2 != 0</span> *
       <span class='color_blue'>#GB<src.c>$head = @f$1 <span class='color_orange'>rearrange:38</span>:node*</span>  ]</span>
    
    Instruction <span class='color_green'>REMOVE_TEMPS(n$17,n$18,n$19); [line 54, column 7]</span>
    in vpath_find exp:_t$3
    vpath_find: found x : node*
    in vpath_find exp:_t$1
    vpath_find: found head : node*
    in vpath_find exp:n$17
    vpath_find: found t : node*
    Instruction Returns
    PROP 1 of 1:
    <span class='color_blue'><span class='color_red'>(-1  &lt;  _t$5)</span>; <span class='color_blue'>(@f$0  &lt;=  8)</span>; <span class='color_red'>t != 0</span>; <span class='color_red'>MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(x)</span>; <span class='color_red'>MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(t)</span>; <span class='color_blue'>MEMma &lt; malloc:38 &gt;  <span class='color_orange'>{vpath: }</span>(_t$1)</span>; <span class='color_red'>DANGL &lt; UNINIT &gt; (_t$5)</span> ;
    <span class='color_blue'>x = <span class='color_red'>_t$4 <span class='color_orange'>update:45</span></span>:node*</span>; <span class='color_blue'>n = null <span class='color_orange'>update:40</span>:node*</span>; <span class='color_blue'>t = <span class='color_red'>_t$2 <span class='color_orange'>update:53</span></span>:node*</span>; <span class='color_blue'>#GB<src.c>$head = _t$1 <span class='color_orange'>update:38</span>:node*</span>; <span class='color_blue'>i = (@f$0 + 1) <span class='color_orange'>update:43</span>:int</span>; <span class='color_blue'>return = _t$0 <span class='color_orange'>initial</span>:int</span> ;
    <span class='color_red'>x|->{next:null <span class='color_orange'>update:46</span>, v:(@f$0 + 1) <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16</span>; <span class='color_red'>t|->{next:null <span class='color_orange'>update:46</span>, v:@f$0 <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16</span>; <span class='color_blue'>_t$1|->{next:<span class='color_red'>t <span class='color_orange'>update:56</span></span>, v:<span class='color_red'>_t$3 <span class='color_orange'>alloc</span></span>} <span class='color_orange'>alloc</span>:node16</span>
    [footprint
       <span class='color_blue'>(@f$0  &lt;=  8)</span>; <span class='color_blue'>@f$2 != 0</span> *
       <span class='color_blue'>#GB<src.c>$head = @f$1 <span class='color_orange'>rearrange:38</span>:node*</span>  ]</span>
    
    Instruction <span class='color_green'>APPLY_ABSTRACTION; [line 54, column 7]</span>
    in vpath_find exp:_t$4
    vpath_find: found x : node*
    in vpath_find exp:_t$2
    vpath_find: found t : node*
    in vpath_find exp:_t$1
    vpath_find: found head : node*
    <span class='color_blue'>(@f$0  &lt;=  8); t != 0; MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(x); MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(t); MEMma &lt; malloc:38 &gt;  <span class='color_orange'>{vpath: }</span>(_t$1) ;
    x = _t$4 <span class='color_orange'>update:45</span>:node*; n = null <span class='color_orange'>update:40</span>:node*; t = _t$2 <span class='color_orange'>update:53</span>:node*; #GB<src.c>$head = _t$1 <span class='color_orange'>update:38</span>:node*; i = (@f$0 + 1) <span class='color_orange'>update:43</span>:int; return = _t$0 <span class='color_orange'>initial</span>:int ;
    x|->{next:null <span class='color_orange'>update:46</span>, v:(@f$0 + 1) <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16; t|->{next:null <span class='color_orange'>update:46</span>, v:@f$0 <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16; _t$1|->{next:t <span class='color_orange'>update:56</span>, v:_t$3 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16
    [footprint
       (@f$0  &lt;=  8) *
       #GB<src.c>$head = @f$1 <span class='color_orange'>rearrange:38</span>:node*  ]</span>
    Instruction Returns
    PROP 1 of 1:
    <span class='color_blue'><span class='color_blue'>(@f$0  &lt;=  8)</span>; <span class='color_blue'>t != 0</span>; <span class='color_blue'>MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(x)</span>; <span class='color_blue'>MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(t)</span>; <span class='color_blue'>MEMma &lt; malloc:38 &gt;  <span class='color_orange'>{vpath: }</span>(_t$1)</span> ;
    <span class='color_blue'>x = _t$4 <span class='color_orange'>update:45</span>:node*</span>; <span class='color_blue'>n = null <span class='color_orange'>update:40</span>:node*</span>; <span class='color_blue'>t = _t$2 <span class='color_orange'>update:53</span>:node*</span>; <span class='color_blue'>#GB<src.c>$head = _t$1 <span class='color_orange'>update:38</span>:node*</span>; <span class='color_blue'>i = (@f$0 + 1) <span class='color_orange'>update:43</span>:int</span>; <span class='color_blue'>return = _t$0 <span class='color_orange'>initial</span>:int</span> ;
    <span class='color_blue'>x|->{next:null <span class='color_orange'>update:46</span>, v:(@f$0 + 1) <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16</span>; <span class='color_blue'>t|->{next:null <span class='color_orange'>update:46</span>, v:@f$0 <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16</span>; <span class='color_blue'>_t$1|->{next:t <span class='color_orange'>update:56</span>, v:_t$3 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16</span>
    [footprint
       <span class='color_blue'>(@f$0  &lt;=  8)</span> *
       <span class='color_blue'>#GB<src.c>$head = @f$1 <span class='color_orange'>rearrange:38</span>:node*</span>  ]</span>
    
    .... After Symbolic Execution ....
    PROP 1 of 1:
    <span class='color_blue'><span class='color_blue'>(@f$0  &lt;=  8)</span>; <span class='color_blue'>t != 0</span>; <span class='color_blue'>MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(x)</span>; <span class='color_blue'>MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(t)</span>; <span class='color_blue'>MEMma &lt; malloc:38 &gt;  <span class='color_orange'>{vpath: }</span>(_t$1)</span> ;
    <span class='color_blue'>x = _t$4 <span class='color_orange'>update:45</span>:node*</span>; <span class='color_blue'>n = null <span class='color_orange'>update:40</span>:node*</span>; <span class='color_blue'>t = _t$2 <span class='color_orange'>update:53</span>:node*</span>; <span class='color_blue'>#GB<src.c>$head = _t$1 <span class='color_orange'>update:38</span>:node*</span>; <span class='color_blue'>i = (@f$0 + 1) <span class='color_orange'>update:43</span>:int</span>; <span class='color_blue'>return = _t$0 <span class='color_orange'>initial</span>:int</span> ;
    <span class='color_blue'>x|->{next:null <span class='color_orange'>update:46</span>, v:(@f$0 + 1) <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16</span>; <span class='color_blue'>t|->{next:null <span class='color_orange'>update:46</span>, v:@f$0 <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16</span>; <span class='color_blue'>_t$1|->{next:t <span class='color_orange'>update:56</span>, v:_t$3 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16</span>
    [footprint
       <span class='color_blue'>(@f$0  &lt;=  8)</span> *
       <span class='color_blue'>#GB<src.c>$head = @f$1 <span class='color_orange'>rearrange:38</span>:node*</span>  ]</span>
    
    
    
  </LISTING></span><hr width="100%">
<a name="session348" href="./../nodes/main.fad58de7366495db4650cfefac2fcd61_node25.html#session348">node25#session348</a>(<a href="./../../src.c.b9996786c0d0c7ca7785f2f6d38e80de.html#LINE54">54</a>) interproc<LISTING><span class='color_black'>**** [FP:Pending] main Node: 25, Procedure: main, Session: 348, Todo: 2 ****
  PROP 1 of 2:
  <span class='color_blue'><span class='color_red'>(@f$0  &lt;=  8)</span>; <span class='color_red'>t != 0</span>; <span class='color_red'>_t$2 != 0</span>; <span class='color_red'>MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(x)</span>; <span class='color_red'>MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(_t$6)</span>; <span class='color_red'>MEMma &lt; malloc:38 &gt;  <span class='color_orange'>{vpath: }</span>(_t$1)</span> ;
  <span class='color_red'>x = _t$7 <span class='color_orange'>update:45</span>:node*</span>; <span class='color_red'>n = null <span class='color_orange'>update:40</span>:node*</span>; <span class='color_red'>t = _t$4 <span class='color_orange'>update:53</span>:node*</span>; <span class='color_red'>#GB<src.c>$head = _t$1 <span class='color_orange'>update:38</span>:node*</span>; <span class='color_red'>i = (@f$0 + 1) <span class='color_orange'>update:43</span>:int</span>; <span class='color_red'>return = _t$0 <span class='color_orange'>initial</span>:int</span> ;
  <span class='color_red'>x|->{next:null <span class='color_orange'>update:46</span>, v:(@f$0 + 1) <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16</span>; <span class='color_red'>_t$6|->{next:null <span class='color_orange'>update:46</span>, v:@f$0 <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16</span>; <span class='color_red'>_t$2|->{next:t <span class='color_orange'>update:56</span>, v:_t$5 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16</span>; <span class='color_red'>_t$1|->{next:_t$2 <span class='color_orange'>update:56</span>, v:_t$3 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16</span>; <span class='color_red'>lseg(t,_t$6,[],P0)</span>
  [footprint
     <span class='color_red'>(@f$0  &lt;=  8)</span>; <span class='color_red'>@f$2 != 0</span> *
     <span class='color_red'>#GB<src.c>$head = @f$1 <span class='color_orange'>rearrange:38</span>:node*</span>  ]
  where
  P0 = exists [_t$2]. <span class='color_blue'>_t$0|->{next:_t$1 <span class='color_orange'>update:56</span>, v:_t$2 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16</span></span>
  PROP 2 of 2:
  <span class='color_blue'><span class='color_red'>t != 0</span>; <span class='color_red'>MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(x)</span>; <span class='color_red'>MEMma &lt; malloc:38 &gt;  <span class='color_orange'>{vpath: }</span>(_t$1)</span> ;
  <span class='color_red'>x = _t$7 <span class='color_orange'>update:45</span>:node*</span>; <span class='color_red'>n = _t$6 <span class='color_orange'>update:58</span>:node*</span>; <span class='color_red'>t = _t$4 <span class='color_orange'>update:53</span>:node*</span>; <span class='color_red'>#GB<src.c>$head = _t$1 <span class='color_orange'>update:38</span>:node*</span>; <span class='color_red'>i = 4 <span class='color_orange'>update:43</span>:int</span>; <span class='color_red'>return = _t$0 <span class='color_orange'>initial</span>:int</span> ;
  <span class='color_red'>x|->{next:null <span class='color_orange'>update:46</span>, v:4 <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16</span>; <span class='color_red'>n|->{next:null <span class='color_orange'>update:46</span>, v:3 <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16</span>; <span class='color_red'>_t$2|->{next:t <span class='color_orange'>update:56</span>, v:_t$5 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16</span>; <span class='color_red'>_t$1|->{next:_t$2 <span class='color_orange'>update:56</span>, v:_t$3 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16</span>; <span class='color_red'>lseg(t,n,[],P0)</span>
  [footprint
     <span class='color_red'>@f$1 != 0</span> *
     <span class='color_red'>#GB<src.c>$head = @f$0 <span class='color_orange'>rearrange:38</span>:node*</span>  ]
  where
  P0 = exists [_t$2]. <span class='color_blue'>_t$0|->{next:_t$1 <span class='color_orange'>update:56</span>, v:_t$2 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16</span></span>
  .... Instructions: .... 
  <span class='color_green'>n$17=*&amp;t:node* [line 54, column 21];
  n$18=*n$17.v:int [line 54, column 21];
  n$19=_fun_printf("%d\n":char const *,n$18:int) [line 54, column 7];
  REMOVE_TEMPS(n$17,n$18,n$19); [line 54, column 7];
  APPLY_ABSTRACTION; [line 54, column 7];
  </span>
  
  Processing prop 1/2
    Instruction <span class='color_green'>n$17=*&amp;t:node* [line 54, column 21]</span>
    in vpath_find exp:n$1364
    vpath_find: found head : node*
    in vpath_find exp:n$1360
    vpath_find: cannot find n$1360
    in vpath_find exp:n$1359
    vpath_find: found x : node*
    .... Rearrangement Start ....
    Exp: &amp;t
    Prop: 
    <span class='color_blue'>(@f$0  &lt;=  8); t != 0; n$1361 != 0; MEMma &lt; malloc:38 &gt;  <span class='color_orange'>{vpath: }</span>(n$1364); MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(n$1360); MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(x) ;
    x = n$1359 <span class='color_orange'>update:45</span>:node*; n = null <span class='color_orange'>update:40</span>:node*; t = n$1362 <span class='color_orange'>update:53</span>:node*; #GB<src.c>$head = n$1364 <span class='color_orange'>update:38</span>:node*; i = (@f$0 + 1) <span class='color_orange'>update:43</span>:int; return = n$1366 <span class='color_orange'>initial</span>:int ;
    n$1364|->{next:n$1361 <span class='color_orange'>update:56</span>, v:n$1365 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16; n$1361|->{next:t <span class='color_orange'>update:56</span>, v:n$1363 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16; n$1360|->{next:null <span class='color_orange'>update:46</span>, v:@f$0 <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16; x|->{next:null <span class='color_orange'>update:46</span>, v:(@f$0 + 1) <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16; lseg(t,n$1360,[],P0)
    [footprint
       (@f$0  &lt;=  8); @f$2 != 0 *
       #GB<src.c>$head = @f$1 <span class='color_orange'>rearrange:38</span>:node*  ]
    where
    P0 = exists [_t$2]. _t$0|->{next:_t$1 <span class='color_orange'>update:56</span>, v:_t$2 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16</span>
    
    in prop_iter_extend_ptsto lexp: &amp;t
    prop before:
    <span class='color_blue'>(@f$0  &lt;=  8); t != 0; n$1361 != 0; MEMma &lt; malloc:38 &gt;  <span class='color_orange'>{vpath: }</span>(n$1364); MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(n$1360); MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(x) ;
    x = n$1359 <span class='color_orange'>update:45</span>:node*; n = null <span class='color_orange'>update:40</span>:node*; t = n$1362 <span class='color_orange'>update:53</span>:node*; #GB<src.c>$head = n$1364 <span class='color_orange'>update:38</span>:node*; i = (@f$0 + 1) <span class='color_orange'>update:43</span>:int; return = n$1366 <span class='color_orange'>initial</span>:int ;
    n$1364|->{next:n$1361 <span class='color_orange'>update:56</span>, v:n$1365 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16; n$1361|->{next:t <span class='color_orange'>update:56</span>, v:n$1363 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16; n$1360|->{next:null <span class='color_orange'>update:46</span>, v:@f$0 <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16; x|->{next:null <span class='color_orange'>update:46</span>, v:(@f$0 + 1) <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16; lseg(t,n$1360,[],P0)
    [footprint
       (@f$0  &lt;=  8); @f$2 != 0 *
       #GB<src.c>$head = @f$1 <span class='color_orange'>rearrange:38</span>:node*  ]
    where
    P0 = exists [_t$2]. _t$0|->{next:_t$1 <span class='color_orange'>update:56</span>, v:_t$2 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16</span>
    
    
    prop list after:
    PROP 1 of 1:
    <span class='color_blue'><span class='color_blue'>(@f$0  &lt;=  8)</span>; <span class='color_blue'>t != 0</span>; <span class='color_blue'>n$1361 != 0</span>; <span class='color_blue'>MEMma &lt; malloc:38 &gt;  <span class='color_orange'>{vpath: }</span>(n$1364)</span>; <span class='color_blue'>MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(n$1360)</span>; <span class='color_blue'>MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(x)</span> ;
    <span class='color_blue'>x = n$1359 <span class='color_orange'>update:45</span>:node*</span>; <span class='color_blue'>n = null <span class='color_orange'>update:40</span>:node*</span>; <span class='color_blue'>t = n$1362 <span class='color_orange'>update:53</span>:node*</span>; <span class='color_blue'>#GB<src.c>$head = n$1364 <span class='color_orange'>update:38</span>:node*</span>; <span class='color_blue'>i = (@f$0 + 1) <span class='color_orange'>update:43</span>:int</span>; <span class='color_blue'>return = n$1366 <span class='color_orange'>initial</span>:int</span> ;
    <span class='color_blue'>n$1364|->{next:n$1361 <span class='color_orange'>update:56</span>, v:n$1365 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16</span>; <span class='color_blue'>n$1361|->{next:t <span class='color_orange'>update:56</span>, v:n$1363 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16</span>; <span class='color_blue'>n$1360|->{next:null <span class='color_orange'>update:46</span>, v:@f$0 <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16</span>; <span class='color_blue'>x|->{next:null <span class='color_orange'>update:46</span>, v:(@f$0 + 1) <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16</span>; <span class='color_blue'>lseg(t,n$1360,[],P0)</span>
    [footprint
       <span class='color_blue'>(@f$0  &lt;=  8)</span>; <span class='color_blue'>@f$2 != 0</span> *
       <span class='color_blue'>#GB<src.c>$head = @f$1 <span class='color_orange'>rearrange:38</span>:node*</span>  ]
    where
    P0 = exists [_t$2]. <span class='color_blue'>_t$0|->{next:_t$1 <span class='color_orange'>update:56</span>, v:_t$2 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16</span></span>
    
    
    
    Instruction Returns
    PROP 1 of 1:
    <span class='color_blue'><span class='color_blue'>(@f$0  &lt;=  8)</span>; <span class='color_blue'>_t$2 != 0</span>; <span class='color_red'>t != 0</span>; <span class='color_blue'>MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(x)</span>; <span class='color_red'>MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(_t$5)</span>; <span class='color_blue'>MEMma &lt; malloc:38 &gt;  <span class='color_orange'>{vpath: }</span>(_t$1)</span> ;
    <span class='color_blue'>x = <span class='color_red'>_t$6 <span class='color_orange'>update:45</span></span>:node*</span>; <span class='color_blue'>n = null <span class='color_orange'>update:40</span>:node*</span>; <span class='color_blue'>t = <span class='color_red'>n$17 <span class='color_orange'>update:53</span></span>:node*</span>; <span class='color_blue'>#GB<src.c>$head = _t$1 <span class='color_orange'>update:38</span>:node*</span>; <span class='color_blue'>i = (@f$0 + 1) <span class='color_orange'>update:43</span>:int</span>; <span class='color_blue'>return = _t$0 <span class='color_orange'>initial</span>:int</span> ;
    <span class='color_blue'>x|->{next:null <span class='color_orange'>update:46</span>, v:<span class='color_red'>(@f$0 + 1) <span class='color_orange'>update:47</span></span>} <span class='color_orange'>alloc</span>:node16</span>; <span class='color_red'>_t$5|->{next:null <span class='color_orange'>update:46</span>, v:@f$0 <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16</span>; <span class='color_blue'>_t$2|->{next:<span class='color_red'>t <span class='color_orange'>update:56</span></span>, v:<span class='color_red'>_t$4 <span class='color_orange'>alloc</span></span>} <span class='color_orange'>alloc</span>:node16</span>; <span class='color_blue'>_t$1|->{next:_t$2 <span class='color_orange'>update:56</span>, v:_t$3 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16</span>; <span class='color_red'>lseg(t,_t$5,[],P0)</span>
    [footprint
       <span class='color_blue'>(@f$0  &lt;=  8)</span>; <span class='color_blue'>@f$2 != 0</span> *
       <span class='color_blue'>#GB<src.c>$head = @f$1 <span class='color_orange'>rearrange:38</span>:node*</span>  ]
    where
    P0 = exists [_t$2]. <span class='color_blue'>_t$0|->{next:_t$1 <span class='color_orange'>update:56</span>, v:_t$2 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16</span></span>
    
    Instruction <span class='color_green'>n$18=*n$17.v:int [line 54, column 21]</span>
    in vpath_find exp:n$1371
    vpath_find: found head : node*
    in vpath_find exp:n$1368
    vpath_find: cannot find n$1368
    in vpath_find exp:n$1367
    vpath_find: found x : node*
    .... Rearrangement Start ....
    Exp: n$17.v
    Prop: 
    <span class='color_blue'>(@f$0  &lt;=  8); n$1369 != 0; t != 0; MEMma &lt; malloc:38 &gt;  <span class='color_orange'>{vpath: }</span>(n$1371); MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(n$1368); MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(x) ;
    x = n$1367 <span class='color_orange'>update:45</span>:node*; n = null <span class='color_orange'>update:40</span>:node*; t = n$17 <span class='color_orange'>update:53</span>:node*; #GB<src.c>$head = n$1371 <span class='color_orange'>update:38</span>:node*; i = (@f$0 + 1) <span class='color_orange'>update:43</span>:int; return = n$1373 <span class='color_orange'>initial</span>:int ;
    n$1371|->{next:n$1369 <span class='color_orange'>update:56</span>, v:n$1372 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16; n$1369|->{next:t <span class='color_orange'>update:56</span>, v:n$1370 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16; n$1368|->{next:null <span class='color_orange'>update:46</span>, v:@f$0 <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16; x|->{next:null <span class='color_orange'>update:46</span>, v:(@f$0 + 1) <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16; lseg(t,n$1368,[],P0)
    [footprint
       (@f$0  &lt;=  8); @f$2 != 0 *
       #GB<src.c>$head = @f$1 <span class='color_orange'>rearrange:38</span>:node*  ]
    where
    P0 = exists [_t$2]. _t$0|->{next:_t$1 <span class='color_orange'>update:56</span>, v:_t$2 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16</span>
    
    in prop_iter_extend_ptsto lexp: n$17.v
    prop before:
    <span class='color_blue'>(@f$0  &lt;=  8); n$1369 != 0; t != 0; MEMma &lt; malloc:38 &gt;  <span class='color_orange'>{vpath: }</span>(n$1371); MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(n$1368); MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(x) ;
    x = n$1367 <span class='color_orange'>update:45</span>:node*; n = null <span class='color_orange'>update:40</span>:node*; t = n$17 <span class='color_orange'>update:53</span>:node*; #GB<src.c>$head = n$1371 <span class='color_orange'>update:38</span>:node*; i = (@f$0 + 1) <span class='color_orange'>update:43</span>:int; return = n$1373 <span class='color_orange'>initial</span>:int ;
    n$1371|->{next:n$1369 <span class='color_orange'>update:56</span>, v:n$1372 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16; n$1369|->{next:t <span class='color_orange'>update:56</span>, v:n$1370 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16; n$1368|->{next:null <span class='color_orange'>update:46</span>, v:@f$0 <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16; x|->{next:null <span class='color_orange'>update:46</span>, v:(@f$0 + 1) <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16; t|->{next:_t$2334 <span class='color_orange'>update:56</span>, v:_t$2335 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16; lseg(_t$2334,n$1368,[],P0)
    [footprint
       (@f$0  &lt;=  8); @f$2 != 0 *
       #GB<src.c>$head = @f$1 <span class='color_orange'>rearrange:38</span>:node*  ]
    where
    P0 = exists [_t$2]. _t$0|->{next:_t$1 <span class='color_orange'>update:56</span>, v:_t$2 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16</span>
    
    
    prop list after:
    PROP 1 of 1:
    <span class='color_blue'><span class='color_blue'>(@f$0  &lt;=  8)</span>; <span class='color_blue'>n$1369 != 0</span>; <span class='color_blue'>t != 0</span>; <span class='color_blue'>MEMma &lt; malloc:38 &gt;  <span class='color_orange'>{vpath: }</span>(n$1371)</span>; <span class='color_blue'>MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(n$1368)</span>; <span class='color_blue'>MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(x)</span> ;
    <span class='color_blue'>x = n$1367 <span class='color_orange'>update:45</span>:node*</span>; <span class='color_blue'>n = null <span class='color_orange'>update:40</span>:node*</span>; <span class='color_blue'>t = n$17 <span class='color_orange'>update:53</span>:node*</span>; <span class='color_blue'>#GB<src.c>$head = n$1371 <span class='color_orange'>update:38</span>:node*</span>; <span class='color_blue'>i = (@f$0 + 1) <span class='color_orange'>update:43</span>:int</span>; <span class='color_blue'>return = n$1373 <span class='color_orange'>initial</span>:int</span> ;
    <span class='color_blue'>n$1371|->{next:n$1369 <span class='color_orange'>update:56</span>, v:n$1372 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16</span>; <span class='color_blue'>n$1369|->{next:t <span class='color_orange'>update:56</span>, v:n$1370 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16</span>; <span class='color_blue'>n$1368|->{next:null <span class='color_orange'>update:46</span>, v:@f$0 <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16</span>; <span class='color_blue'>x|->{next:null <span class='color_orange'>update:46</span>, v:(@f$0 + 1) <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16</span>; <span class='color_blue'>t|->{next:_t$2334 <span class='color_orange'>update:56</span>, v:_t$2335 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16</span>; <span class='color_blue'>lseg(_t$2334,n$1368,[],P0)</span>
    [footprint
       <span class='color_blue'>(@f$0  &lt;=  8)</span>; <span class='color_blue'>@f$2 != 0</span> *
       <span class='color_blue'>#GB<src.c>$head = @f$1 <span class='color_orange'>rearrange:38</span>:node*</span>  ]
    where
    P0 = exists [_t$2]. <span class='color_blue'>_t$0|->{next:_t$1 <span class='color_orange'>update:56</span>, v:_t$2 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16</span></span>
    
    
    
    in prop_iter_extend_ptsto lexp: n$17.v
    prop before:
    <span class='color_blue'>n$1368 = t ;
    (@f$0  &lt;=  8); n$1369 != 0; t != 0; MEMma &lt; malloc:38 &gt;  <span class='color_orange'>{vpath: }</span>(n$1371); MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(x); MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(t) ;
    x = n$1367 <span class='color_orange'>update:45</span>:node*; n = null <span class='color_orange'>update:40</span>:node*; t = n$17 <span class='color_orange'>update:53</span>:node*; #GB<src.c>$head = n$1371 <span class='color_orange'>update:38</span>:node*; i = (@f$0 + 1) <span class='color_orange'>update:43</span>:int; return = n$1373 <span class='color_orange'>initial</span>:int ;
    n$1371|->{next:n$1369 <span class='color_orange'>update:56</span>, v:n$1372 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16; n$1369|->{next:t <span class='color_orange'>update:56</span>, v:n$1370 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16; x|->{next:null <span class='color_orange'>update:46</span>, v:(@f$0 + 1) <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16; t|->{next:null <span class='color_orange'>update:46</span>, v:@f$0 <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16
    [footprint
       n$1368 = t; (@f$0  &lt;=  8); @f$2 != 0 *
       #GB<src.c>$head = @f$1 <span class='color_orange'>rearrange:38</span>:node*  ]</span>
    
    
    prop list after:
    PROP 1 of 1:
    <span class='color_blue'><span class='color_blue'>n$1368 = t</span> ;
    <span class='color_blue'>(@f$0  &lt;=  8)</span>; <span class='color_blue'>n$1369 != 0</span>; <span class='color_blue'>t != 0</span>; <span class='color_blue'>MEMma &lt; malloc:38 &gt;  <span class='color_orange'>{vpath: }</span>(n$1371)</span>; <span class='color_blue'>MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(x)</span>; <span class='color_blue'>MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(t)</span> ;
    <span class='color_blue'>x = n$1367 <span class='color_orange'>update:45</span>:node*</span>; <span class='color_blue'>n = null <span class='color_orange'>update:40</span>:node*</span>; <span class='color_blue'>t = n$17 <span class='color_orange'>update:53</span>:node*</span>; <span class='color_blue'>#GB<src.c>$head = n$1371 <span class='color_orange'>update:38</span>:node*</span>; <span class='color_blue'>i = (@f$0 + 1) <span class='color_orange'>update:43</span>:int</span>; <span class='color_blue'>return = n$1373 <span class='color_orange'>initial</span>:int</span> ;
    <span class='color_blue'>n$1371|->{next:n$1369 <span class='color_orange'>update:56</span>, v:n$1372 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16</span>; <span class='color_blue'>n$1369|->{next:t <span class='color_orange'>update:56</span>, v:n$1370 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16</span>; <span class='color_blue'>x|->{next:null <span class='color_orange'>update:46</span>, v:(@f$0 + 1) <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16</span>; <span class='color_blue'>t|->{next:null <span class='color_orange'>update:46</span>, v:@f$0 <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16</span>
    [footprint
       <span class='color_blue'>n$1368 = t</span>; <span class='color_blue'>(@f$0  &lt;=  8)</span>; <span class='color_blue'>@f$2 != 0</span> *
       <span class='color_blue'>#GB<src.c>$head = @f$1 <span class='color_orange'>rearrange:38</span>:node*</span>  ]</span>
    
    
    
    Instruction Returns
    PROP 1 of 2:
    <span class='color_blue'><span class='color_blue'>(@f$0  &lt;=  8)</span>; <span class='color_blue'>_t$2 != 0</span>; <span class='color_blue'>t != 0</span>; <span class='color_red'>MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(x)</span>; <span class='color_blue'>MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(_t$6)</span>; <span class='color_blue'>MEMma &lt; malloc:38 &gt;  <span class='color_orange'>{vpath: }</span>(_t$1)</span>; <span class='color_red'>DANGL &lt; UNINIT &gt; (n$18)</span> ;
    <span class='color_blue'>x = <span class='color_red'>_t$7 <span class='color_orange'>update:45</span></span>:node*</span>; <span class='color_blue'>n = null <span class='color_orange'>update:40</span>:node*</span>; <span class='color_blue'>t = n$17 <span class='color_orange'>update:53</span>:node*</span>; <span class='color_blue'>#GB<src.c>$head = _t$1 <span class='color_orange'>update:38</span>:node*</span>; <span class='color_blue'>i = (@f$0 + 1) <span class='color_orange'>update:43</span>:int</span>; <span class='color_blue'>return = _t$0 <span class='color_orange'>initial</span>:int</span> ;
    <span class='color_red'>x|->{next:null <span class='color_orange'>update:46</span>, v:(@f$0 + 1) <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16</span>; <span class='color_blue'>_t$6|->{next:null <span class='color_orange'>update:46</span>, v:<span class='color_red'>@f$0 <span class='color_orange'>update:47</span></span>} <span class='color_orange'>alloc</span>:node16</span>; <span class='color_blue'>_t$2|->{next:t <span class='color_orange'>update:56</span>, v:_t$4 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16</span>; <span class='color_blue'>_t$1|->{next:_t$2 <span class='color_orange'>update:56</span>, v:_t$3 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16</span>; <span class='color_blue'>t|->{next:_t$5 <span class='color_orange'>update:56</span>, v:n$18 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16</span>; <span class='color_blue'>lseg(_t$5,_t$6,[],P0)</span>
    [footprint
       <span class='color_blue'>(@f$0  &lt;=  8)</span>; <span class='color_blue'>@f$2 != 0</span> *
       <span class='color_blue'>#GB<src.c>$head = @f$1 <span class='color_orange'>rearrange:38</span>:node*</span>  ]
    where
    P0 = exists [_t$2]. <span class='color_blue'>_t$0|->{next:_t$1 <span class='color_orange'>update:56</span>, v:_t$2 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16</span></span>
    PROP 2 of 2:
    <span class='color_blue'><span class='color_red'>n$18 = @f$0</span> ;
    <span class='color_blue'>(@f$0  &lt;=  8)</span>; <span class='color_blue'>_t$2 != 0</span>; <span class='color_blue'>t != 0</span>; <span class='color_blue'>MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(x)</span>; <span class='color_blue'>MEMma &lt; malloc:38 &gt;  <span class='color_orange'>{vpath: }</span>(_t$1)</span>; <span class='color_blue'>MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(t)</span> ;
    <span class='color_blue'>x = <span class='color_red'>_t$5 <span class='color_orange'>update:45</span></span>:node*</span>; <span class='color_blue'>n = null <span class='color_orange'>update:40</span>:node*</span>; <span class='color_blue'>t = n$17 <span class='color_orange'>update:53</span>:node*</span>; <span class='color_blue'>#GB<src.c>$head = _t$1 <span class='color_orange'>update:38</span>:node*</span>; <span class='color_blue'>i = (@f$0 + 1) <span class='color_orange'>update:43</span>:int</span>; <span class='color_blue'>return = _t$0 <span class='color_orange'>initial</span>:int</span> ;
    <span class='color_blue'>x|->{next:null <span class='color_orange'>update:46</span>, v:<span class='color_red'>(@f$0 + 1) <span class='color_orange'>update:47</span></span>} <span class='color_orange'>alloc</span>:node16</span>; <span class='color_blue'>_t$2|->{next:t <span class='color_orange'>update:56</span>, v:_t$4 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16</span>; <span class='color_blue'>_t$1|->{next:_t$2 <span class='color_orange'>update:56</span>, v:_t$3 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16</span>; <span class='color_blue'>t|->{next:null <span class='color_orange'>update:46</span>, v:@f$0 <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16</span>
    [footprint
       <span class='color_red'>t = @f$2</span>; <span class='color_blue'>(@f$0  &lt;=  8)</span>; <span class='color_red'>@f$3 != 0</span> *
       <span class='color_blue'>#GB<src.c>$head = @f$1 <span class='color_orange'>rearrange:38</span>:node*</span>  ]</span>
    
    Instruction <span class='color_green'>n$19=_fun_printf("%d\n":char const *,n$18:int) [line 54, column 7]</span>
    in vpath_find exp:n$1378
    vpath_find: found head : node*
    in vpath_find exp:n$1375
    vpath_find: cannot find n$1375
    in vpath_find exp:n$1374
    vpath_find: found x : node*
    <span class='color_orange'>WARNING: likely use of variable-arguments function, or function prototype missing</span>
    actual parameters: n$18
    formal parameters: 
    Found 1 specs for function printf
    START EXECUTING SPECS FOR printf from state
    <span class='color_blue'>(@f$0  &lt;=  8); n$1376 != 0; t != 0; MEMma &lt; malloc:38 &gt;  <span class='color_orange'>{vpath: }</span>(n$1378); MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(n$1375); MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(x); DANGL &lt; UNINIT &gt; (n$18) ;
    x = n$1374 <span class='color_orange'>update:45</span>:node*; n = null <span class='color_orange'>update:40</span>:node*; t = n$17 <span class='color_orange'>update:53</span>:node*; #GB<src.c>$head = n$1378 <span class='color_orange'>update:38</span>:node*; i = (@f$0 + 1) <span class='color_orange'>update:43</span>:int; return = n$1381 <span class='color_orange'>initial</span>:int ;
    n$1378|->{next:n$1376 <span class='color_orange'>update:56</span>, v:n$1379 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16; n$1376|->{next:t <span class='color_orange'>update:56</span>, v:n$1377 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16; n$1375|->{next:null <span class='color_orange'>update:46</span>, v:@f$0 <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16; x|->{next:null <span class='color_orange'>update:46</span>, v:(@f$0 + 1) <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16; t|->{next:n$1380 <span class='color_orange'>update:56</span>, v:n$18 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16; lseg(n$1380,n$1375,[],P0)
    [footprint
       (@f$0  &lt;=  8); @f$2 != 0 *
       #GB<src.c>$head = @f$1 <span class='color_orange'>rearrange:38</span>:node*  ]
    where
    P0 = exists [_t$2]. _t$0|->{next:_t$1 <span class='color_orange'>update:56</span>, v:_t$2 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16</span>
    <span class='color_orange'>WARNING: more actual pars than formal pars in fun call (2 vs 1)</span>
    EXECUTING SPEC 1/1
    ACTUAL PRECONDITION =
      <span class='color_blue'>(@f$0  &lt;=  8); n$1376 != 0; t != 0; MEMma &lt; malloc:38 &gt;  <span class='color_orange'>{vpath: }</span>(n$1378); MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(n$1375); MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(x); DANGL &lt; UNINIT &gt; (n$18) ;
      x = n$1374 <span class='color_orange'>update:45</span>:node*; n = null <span class='color_orange'>update:40</span>:node*; t = n$17 <span class='color_orange'>update:53</span>:node*; #GB<src.c>$head = n$1378 <span class='color_orange'>update:38</span>:node*; i = (@f$0 + 1) <span class='color_orange'>update:43</span>:int; format|callee = "%d\n" <span class='color_orange'>actual_precondition</span>:char const *; return = n$1381 <span class='color_orange'>initial</span>:int ;
      n$1378|->{next:n$1376 <span class='color_orange'>update:56</span>, v:n$1379 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16; n$1376|->{next:t <span class='color_orange'>update:56</span>, v:n$1377 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16; n$1375|->{next:null <span class='color_orange'>update:46</span>, v:@f$0 <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16; x|->{next:null <span class='color_orange'>update:46</span>, v:(@f$0 + 1) <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16; t|->{next:n$1380 <span class='color_orange'>update:56</span>, v:n$18 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16; lseg(n$1380,n$1375,[],P0)
      [footprint
         (@f$0  &lt;=  8); @f$2 != 0 *
         #GB<src.c>$head = @f$1 <span class='color_orange'>rearrange:38</span>:node*  ]
      where
      P0 = exists [_t$2]. _t$0|->{next:_t$1 <span class='color_orange'>update:56</span>, v:_t$2 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16</span>
    SPEC =
      --------------------------- ---------- ---------------------------
      PRE:
      <span class='color_blue'><span class='color_blue'>format|callee = _t$2352 <span class='color_orange'>formal</span>:char const *</span></span>
      POST 1 of 1:
      <span class='color_blue'><span class='color_red'>(-1  &lt;  _t$2353)</span>; <span class='color_red'>DANGL &lt; UNINIT &gt; (return|callee)</span> ;
      <span class='color_red'>return|callee = _t$2353 <span class='color_orange'>update:1114</span>:int</span></span>
      ----------------------------------------------------------------
    pre_check_pure_implication
    pi1:
      (@f$0  &lt;=  8); n$1376 != 0; n$17 != 0; MEMma &lt; malloc:38 &gt;  <span class='color_orange'>{vpath: }</span>(n$1378); MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(n$1375); MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(n$1374); DANGL &lt; UNINIT &gt; (n$18)
    pi2:
      
    returns
    sub1: 
      
    sub2: 
      
    Current Implication
    SUB:
      
    <span class='color_blue'>(@f$0  &lt;=  8); n$1376 != 0; t != 0; MEMma &lt; malloc:38 &gt;  <span class='color_orange'>{vpath: }</span>(n$1378); MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(n$1375); MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(x); DANGL &lt; UNINIT &gt; (n$18) ;
    x = n$1374 <span class='color_orange'>update:45</span>:node*; n = null <span class='color_orange'>update:40</span>:node*; t = n$17 <span class='color_orange'>update:53</span>:node*; #GB<src.c>$head = n$1378 <span class='color_orange'>update:38</span>:node*; i = (@f$0 + 1) <span class='color_orange'>update:43</span>:int; format|callee = "%d\n" <span class='color_orange'>actual_precondition</span>:char const *; return = n$1381 <span class='color_orange'>initial</span>:int ;
    n$1378|->{next:n$1376 <span class='color_orange'>update:56</span>, v:n$1379 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16; n$1376|->{next:t <span class='color_orange'>update:56</span>, v:n$1377 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16; n$1375|->{next:null <span class='color_orange'>update:46</span>, v:@f$0 <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16; x|->{next:null <span class='color_orange'>update:46</span>, v:(@f$0 + 1) <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16; t|->{next:n$1380 <span class='color_orange'>update:56</span>, v:n$18 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16; lseg(n$1380,n$1375,[],P0)
    [footprint
       (@f$0  &lt;=  8); @f$2 != 0 *
       #GB<src.c>$head = @f$1 <span class='color_orange'>rearrange:38</span>:node*  ]
    where
    P0 = exists [_t$2]. _t$0|->{next:_t$1 <span class='color_orange'>update:56</span>, v:_t$2 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16</span>
    |-
    <span class='color_blue'>format|callee = _t$2352 <span class='color_orange'>formal</span>:char const *</span>
    
      do_imply "%d\n" _t$2352
        Final Implication
        SUB:
          
        <span class='color_blue'>(@f$0  &lt;=  8); n$1376 != 0; t != 0; MEMma &lt; malloc:38 &gt;  <span class='color_orange'>{vpath: }</span>(n$1378); MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(n$1375); MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(x); DANGL &lt; UNINIT &gt; (n$18) ;
        x = n$1374 <span class='color_orange'>update:45</span>:node*; n = null <span class='color_orange'>update:40</span>:node*; t = n$17 <span class='color_orange'>update:53</span>:node*; #GB<src.c>$head = n$1378 <span class='color_orange'>update:38</span>:node*; i = (@f$0 + 1) <span class='color_orange'>update:43</span>:int; return = n$1381 <span class='color_orange'>initial</span>:int ;
        n$1378|->{next:n$1376 <span class='color_orange'>update:56</span>, v:n$1379 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16; n$1376|->{next:t <span class='color_orange'>update:56</span>, v:n$1377 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16; n$1375|->{next:null <span class='color_orange'>update:46</span>, v:@f$0 <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16; x|->{next:null <span class='color_orange'>update:46</span>, v:(@f$0 + 1) <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16; t|->{next:n$1380 <span class='color_orange'>update:56</span>, v:n$18 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16; lseg(n$1380,n$1375,[],P0)
        [footprint
           (@f$0  &lt;=  8); @f$2 != 0 *
           #GB<src.c>$head = @f$1 <span class='color_orange'>rearrange:38</span>:node*  ]
        where
        P0 = exists [_t$2]. _t$0|->{next:_t$1 <span class='color_orange'>update:56</span>, v:_t$2 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16</span>
        [SUB: 
          _t$2352 = "%d\n"]
        |-
        <span class='color_blue'></span>
    Result of Abduction
      SUB:
        
      <span class='color_blue'>(@f$0  &lt;=  8); n$1376 != 0; t != 0; MEMma &lt; malloc:38 &gt;  <span class='color_orange'>{vpath: }</span>(n$1378); MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(n$1375); MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(x); DANGL &lt; UNINIT &gt; (n$18) ;
      x = n$1374 <span class='color_orange'>update:45</span>:node*; n = null <span class='color_orange'>update:40</span>:node*; t = n$17 <span class='color_orange'>update:53</span>:node*; #GB<src.c>$head = n$1378 <span class='color_orange'>update:38</span>:node*; i = (@f$0 + 1) <span class='color_orange'>update:43</span>:int; format|callee = "%d\n" <span class='color_orange'>actual_precondition</span>:char const *; return = n$1381 <span class='color_orange'>initial</span>:int ;
      n$1378|->{next:n$1376 <span class='color_orange'>update:56</span>, v:n$1379 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16; n$1376|->{next:t <span class='color_orange'>update:56</span>, v:n$1377 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16; n$1375|->{next:null <span class='color_orange'>update:46</span>, v:@f$0 <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16; x|->{next:null <span class='color_orange'>update:46</span>, v:(@f$0 + 1) <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16; t|->{next:n$1380 <span class='color_orange'>update:56</span>, v:n$18 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16; lseg(n$1380,n$1375,[],P0)
      [footprint
         (@f$0  &lt;=  8); @f$2 != 0 *
         #GB<src.c>$head = @f$1 <span class='color_orange'>rearrange:38</span>:node*  ]
      where
      P0 = exists [_t$2]. _t$0|->{next:_t$1 <span class='color_orange'>update:56</span>, v:_t$2 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16</span>
      [SUB: 
        _t$2352 = "%d\n"]
      |-
      <span class='color_blue'>format|callee = "%d\n" <span class='color_orange'>formal</span>:char const *</span>
    returning TRUE
      New footprint:
      
      Frame fld:
      
      Missing fld:
      
      Instantiated frame:
      n$1378|->{next:n$1376 <span class='color_orange'>update:56</span>, v:n$1379 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16; n$1376|->{next:n$17 <span class='color_orange'>update:56</span>, v:n$1377 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16; n$1375|->{next:null <span class='color_orange'>update:46</span>, v:@f$0 <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16; n$1374|->{next:null <span class='color_orange'>update:46</span>, v:(@f$0 + 1) <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16; n$17|->{next:n$1380 <span class='color_orange'>update:56</span>, v:n$18 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16; &amp;x|->n$1374 <span class='color_orange'>update:45</span>:node*; &amp;n|->null <span class='color_orange'>update:40</span>:node*; &amp;t|->n$17 <span class='color_orange'>update:53</span>:node*; &amp;#GB<src.c>$head|->n$1378 <span class='color_orange'>update:38</span>:node*; &amp;i|->(@f$0 + 1) <span class='color_orange'>update:43</span>:int; &amp;return|->n$1381 <span class='color_orange'>initial</span>:int; lseg(n$1380,n$1375,[],lam [_t$0,_t$1,]. exists [_t$2]. _t$0|->{next:_t$1 <span class='color_orange'>update:56</span>, v:_t$2 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16)
      Instantiated post:
      PROP 1 of 1:
      <span class='color_blue'><span class='color_red'>(-1  &lt;  _t$2353)</span>; <span class='color_red'>DANGL &lt; UNINIT &gt; (return|callee)</span> ;
      <span class='color_red'>return|callee = _t$2353 <span class='color_orange'>update:54</span>:int</span></span>
      
    ***** RESULTS FUNCTION CALL *******
    PROP 1 of 1:
    <span class='color_blue'><span class='color_red'>(-1  &lt;  n$19)</span>; <span class='color_blue'>(@f$0  &lt;=  8)</span>; <span class='color_blue'>n$1376 != 0</span>; <span class='color_blue'>t != 0</span>; <span class='color_blue'>MEMma &lt; malloc:38 &gt;  <span class='color_orange'>{vpath: }</span>(n$1378)</span>; <span class='color_blue'>MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(n$1375)</span>; <span class='color_blue'>MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(x)</span>; <span class='color_red'>DANGL &lt; UNINIT &gt; (n$19)</span>; <span class='color_blue'>DANGL &lt; UNINIT &gt; (n$18)</span> ;
    <span class='color_blue'>x = n$1374 <span class='color_orange'>update:45</span>:node*</span>; <span class='color_blue'>n = null <span class='color_orange'>update:40</span>:node*</span>; <span class='color_blue'>t = n$17 <span class='color_orange'>update:53</span>:node*</span>; <span class='color_blue'>#GB<src.c>$head = n$1378 <span class='color_orange'>update:38</span>:node*</span>; <span class='color_blue'>i = (@f$0 + 1) <span class='color_orange'>update:43</span>:int</span>; <span class='color_blue'>return = n$1381 <span class='color_orange'>initial</span>:int</span> ;
    <span class='color_blue'>n$1378|->{next:n$1376 <span class='color_orange'>update:56</span>, v:n$1379 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16</span>; <span class='color_blue'>n$1376|->{next:t <span class='color_orange'>update:56</span>, v:n$1377 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16</span>; <span class='color_blue'>n$1375|->{next:null <span class='color_orange'>update:46</span>, v:@f$0 <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16</span>; <span class='color_blue'>x|->{next:null <span class='color_orange'>update:46</span>, v:(@f$0 + 1) <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16</span>; <span class='color_blue'>t|->{next:n$1380 <span class='color_orange'>update:56</span>, v:n$18 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16</span>; <span class='color_blue'>lseg(n$1380,n$1375,[],P0)</span>
    [footprint
       <span class='color_blue'>(@f$0  &lt;=  8)</span>; <span class='color_blue'>@f$2 != 0</span> *
       <span class='color_blue'>#GB<src.c>$head = @f$1 <span class='color_orange'>rearrange:38</span>:node*</span>  ]
    where
    P0 = exists [_t$2]. <span class='color_blue'>_t$0|->{next:_t$1 <span class='color_orange'>update:56</span>, v:_t$2 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16</span></span>
    ***** END RESULTS FUNCTION CALL *******
    Instruction Returns
    PROP 1 of 1:
    <span class='color_blue'><span class='color_red'>(-1  &lt;  n$19)</span>; <span class='color_blue'>(@f$0  &lt;=  8)</span>; <span class='color_blue'>_t$2 != 0</span>; <span class='color_blue'>t != 0</span>; <span class='color_blue'>MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(x)</span>; <span class='color_blue'>MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(_t$6)</span>; <span class='color_blue'>MEMma &lt; malloc:38 &gt;  <span class='color_orange'>{vpath: }</span>(_t$1)</span>; <span class='color_red'>DANGL &lt; UNINIT &gt; (n$19)</span>; <span class='color_blue'>DANGL &lt; UNINIT &gt; (n$18)</span> ;
    <span class='color_blue'>x = _t$7 <span class='color_orange'>update:45</span>:node*</span>; <span class='color_blue'>n = null <span class='color_orange'>update:40</span>:node*</span>; <span class='color_blue'>t = n$17 <span class='color_orange'>update:53</span>:node*</span>; <span class='color_blue'>#GB<src.c>$head = _t$1 <span class='color_orange'>update:38</span>:node*</span>; <span class='color_blue'>i = (@f$0 + 1) <span class='color_orange'>update:43</span>:int</span>; <span class='color_blue'>return = _t$0 <span class='color_orange'>initial</span>:int</span> ;
    <span class='color_blue'>x|->{next:null <span class='color_orange'>update:46</span>, v:(@f$0 + 1) <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16</span>; <span class='color_blue'>_t$6|->{next:null <span class='color_orange'>update:46</span>, v:@f$0 <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16</span>; <span class='color_blue'>_t$2|->{next:t <span class='color_orange'>update:56</span>, v:_t$4 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16</span>; <span class='color_blue'>_t$1|->{next:_t$2 <span class='color_orange'>update:56</span>, v:_t$3 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16</span>; <span class='color_blue'>t|->{next:_t$5 <span class='color_orange'>update:56</span>, v:n$18 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16</span>; <span class='color_blue'>lseg(_t$5,_t$6,[],P0)</span>
    [footprint
       <span class='color_blue'>(@f$0  &lt;=  8)</span>; <span class='color_blue'>@f$2 != 0</span> *
       <span class='color_blue'>#GB<src.c>$head = @f$1 <span class='color_orange'>rearrange:38</span>:node*</span>  ]
    where
    P0 = exists [_t$2]. <span class='color_blue'>_t$0|->{next:_t$1 <span class='color_orange'>update:56</span>, v:_t$2 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16</span></span>
    
    Instruction <span class='color_green'>n$19=_fun_printf("%d\n":char const *,n$18:int) [line 54, column 7]</span>
    in vpath_find exp:n$1385
    vpath_find: found head : node*
    in vpath_find exp:n$1382
    vpath_find: found x : node*
    in vpath_find exp:n$17
    vpath_find: found head->next->next : node*
    <span class='color_orange'>WARNING: likely use of variable-arguments function, or function prototype missing</span>
    actual parameters: @f$0
    formal parameters: 
    Found 1 specs for function printf
    START EXECUTING SPECS FOR printf from state
    <span class='color_blue'>n$18 = @f$0 ;
    (@f$0  &lt;=  8); n$1383 != 0; t != 0; MEMma &lt; malloc:38 &gt;  <span class='color_orange'>{vpath: }</span>(n$1385); MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(x); MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(t) ;
    x = n$1382 <span class='color_orange'>update:45</span>:node*; n = null <span class='color_orange'>update:40</span>:node*; t = n$17 <span class='color_orange'>update:53</span>:node*; #GB<src.c>$head = n$1385 <span class='color_orange'>update:38</span>:node*; i = (@f$0 + 1) <span class='color_orange'>update:43</span>:int; return = n$1387 <span class='color_orange'>initial</span>:int ;
    n$1385|->{next:n$1383 <span class='color_orange'>update:56</span>, v:n$1386 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16; n$1383|->{next:t <span class='color_orange'>update:56</span>, v:n$1384 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16; x|->{next:null <span class='color_orange'>update:46</span>, v:(@f$0 + 1) <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16; t|->{next:null <span class='color_orange'>update:46</span>, v:@f$0 <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16
    [footprint
       t = @f$2; (@f$0  &lt;=  8); @f$3 != 0 *
       #GB<src.c>$head = @f$1 <span class='color_orange'>rearrange:38</span>:node*  ]</span>
    <span class='color_orange'>WARNING: more actual pars than formal pars in fun call (2 vs 1)</span>
    EXECUTING SPEC 1/1
    ACTUAL PRECONDITION =
      <span class='color_blue'>n$18 = @f$0 ;
      (@f$0  &lt;=  8); n$1383 != 0; t != 0; MEMma &lt; malloc:38 &gt;  <span class='color_orange'>{vpath: }</span>(n$1385); MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(x); MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(t) ;
      x = n$1382 <span class='color_orange'>update:45</span>:node*; n = null <span class='color_orange'>update:40</span>:node*; t = n$17 <span class='color_orange'>update:53</span>:node*; #GB<src.c>$head = n$1385 <span class='color_orange'>update:38</span>:node*; i = (@f$0 + 1) <span class='color_orange'>update:43</span>:int; format|callee = "%d\n" <span class='color_orange'>actual_precondition</span>:char const *; return = n$1387 <span class='color_orange'>initial</span>:int ;
      n$1385|->{next:n$1383 <span class='color_orange'>update:56</span>, v:n$1386 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16; n$1383|->{next:t <span class='color_orange'>update:56</span>, v:n$1384 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16; x|->{next:null <span class='color_orange'>update:46</span>, v:(@f$0 + 1) <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16; t|->{next:null <span class='color_orange'>update:46</span>, v:@f$0 <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16
      [footprint
         t = @f$2; (@f$0  &lt;=  8); @f$3 != 0 *
         #GB<src.c>$head = @f$1 <span class='color_orange'>rearrange:38</span>:node*  ]</span>
    SPEC =
      --------------------------- ---------- ---------------------------
      PRE:
      <span class='color_blue'><span class='color_blue'>format|callee = _t$2362 <span class='color_orange'>formal</span>:char const *</span></span>
      POST 1 of 1:
      <span class='color_blue'><span class='color_red'>(-1  &lt;  _t$2363)</span>; <span class='color_red'>DANGL &lt; UNINIT &gt; (return|callee)</span> ;
      <span class='color_red'>return|callee = _t$2363 <span class='color_orange'>update:1114</span>:int</span></span>
      ----------------------------------------------------------------
    pre_check_pure_implication
    pi1:
      n$18 = @f$0; (@f$0  &lt;=  8); n$1383 != 0; n$17 != 0; MEMma &lt; malloc:38 &gt;  <span class='color_orange'>{vpath: }</span>(n$1385); MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(n$1382); MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(n$17)
    pi2:
      
    returns
    sub1: 
      n$18 = @f$0
    sub2: 
      
    Current Implication
    SUB:
      n$18 = @f$0
    <span class='color_blue'>(@f$0  &lt;=  8); n$1383 != 0; t != 0; MEMma &lt; malloc:38 &gt;  <span class='color_orange'>{vpath: }</span>(n$1385); MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(x); MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(t); @f$0 = @f$0 ;
    x = n$1382 <span class='color_orange'>update:45</span>:node*; n = null <span class='color_orange'>update:40</span>:node*; t = n$17 <span class='color_orange'>update:53</span>:node*; #GB<src.c>$head = n$1385 <span class='color_orange'>update:38</span>:node*; i = (@f$0 + 1) <span class='color_orange'>update:43</span>:int; format|callee = "%d\n" <span class='color_orange'>actual_precondition</span>:char const *; return = n$1387 <span class='color_orange'>initial</span>:int ;
    n$1385|->{next:n$1383 <span class='color_orange'>update:56</span>, v:n$1386 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16; n$1383|->{next:t <span class='color_orange'>update:56</span>, v:n$1384 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16; x|->{next:null <span class='color_orange'>update:46</span>, v:(@f$0 + 1) <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16; t|->{next:null <span class='color_orange'>update:46</span>, v:@f$0 <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16
    [footprint
       t = @f$2; (@f$0  &lt;=  8); @f$3 != 0 *
       #GB<src.c>$head = @f$1 <span class='color_orange'>rearrange:38</span>:node*  ]</span>
    |-
    <span class='color_blue'>format|callee = _t$2362 <span class='color_orange'>formal</span>:char const *</span>
    
      do_imply "%d\n" _t$2362
        Final Implication
        SUB:
          n$18 = @f$0
        <span class='color_blue'>(@f$0  &lt;=  8); n$1383 != 0; t != 0; MEMma &lt; malloc:38 &gt;  <span class='color_orange'>{vpath: }</span>(n$1385); MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(x); MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(t); @f$0 = @f$0 ;
        x = n$1382 <span class='color_orange'>update:45</span>:node*; n = null <span class='color_orange'>update:40</span>:node*; t = n$17 <span class='color_orange'>update:53</span>:node*; #GB<src.c>$head = n$1385 <span class='color_orange'>update:38</span>:node*; i = (@f$0 + 1) <span class='color_orange'>update:43</span>:int; return = n$1387 <span class='color_orange'>initial</span>:int ;
        n$1385|->{next:n$1383 <span class='color_orange'>update:56</span>, v:n$1386 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16; n$1383|->{next:t <span class='color_orange'>update:56</span>, v:n$1384 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16; x|->{next:null <span class='color_orange'>update:46</span>, v:(@f$0 + 1) <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16; t|->{next:null <span class='color_orange'>update:46</span>, v:@f$0 <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16
        [footprint
           t = @f$2; (@f$0  &lt;=  8); @f$3 != 0 *
           #GB<src.c>$head = @f$1 <span class='color_orange'>rearrange:38</span>:node*  ]</span>
        [SUB: 
          _t$2362 = "%d\n"]
        |-
        <span class='color_blue'></span>
    Result of Abduction
      SUB:
        n$18 = @f$0
      <span class='color_blue'>(@f$0  &lt;=  8); n$1383 != 0; t != 0; MEMma &lt; malloc:38 &gt;  <span class='color_orange'>{vpath: }</span>(n$1385); MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(x); MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(t); @f$0 = @f$0 ;
      x = n$1382 <span class='color_orange'>update:45</span>:node*; n = null <span class='color_orange'>update:40</span>:node*; t = n$17 <span class='color_orange'>update:53</span>:node*; #GB<src.c>$head = n$1385 <span class='color_orange'>update:38</span>:node*; i = (@f$0 + 1) <span class='color_orange'>update:43</span>:int; format|callee = "%d\n" <span class='color_orange'>actual_precondition</span>:char const *; return = n$1387 <span class='color_orange'>initial</span>:int ;
      n$1385|->{next:n$1383 <span class='color_orange'>update:56</span>, v:n$1386 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16; n$1383|->{next:t <span class='color_orange'>update:56</span>, v:n$1384 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16; x|->{next:null <span class='color_orange'>update:46</span>, v:(@f$0 + 1) <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16; t|->{next:null <span class='color_orange'>update:46</span>, v:@f$0 <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16
      [footprint
         t = @f$2; (@f$0  &lt;=  8); @f$3 != 0 *
         #GB<src.c>$head = @f$1 <span class='color_orange'>rearrange:38</span>:node*  ]</span>
      [SUB: 
        _t$2362 = "%d\n"]
      |-
      <span class='color_blue'>format|callee = "%d\n" <span class='color_orange'>formal</span>:char const *</span>
    returning TRUE
      New footprint:
      
      Frame fld:
      
      Missing fld:
      
      Instantiated frame:
      n$1385|->{next:n$1383 <span class='color_orange'>update:56</span>, v:n$1386 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16; n$1383|->{next:n$17 <span class='color_orange'>update:56</span>, v:n$1384 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16; n$1382|->{next:null <span class='color_orange'>update:46</span>, v:(@f$0 + 1) <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16; n$17|->{next:null <span class='color_orange'>update:46</span>, v:@f$0 <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16; &amp;x|->n$1382 <span class='color_orange'>update:45</span>:node*; &amp;n|->null <span class='color_orange'>update:40</span>:node*; &amp;t|->n$17 <span class='color_orange'>update:53</span>:node*; &amp;#GB<src.c>$head|->n$1385 <span class='color_orange'>update:38</span>:node*; &amp;i|->(@f$0 + 1) <span class='color_orange'>update:43</span>:int; &amp;return|->n$1387 <span class='color_orange'>initial</span>:int
      Instantiated post:
      PROP 1 of 1:
      <span class='color_blue'><span class='color_red'>(-1  &lt;  _t$2363)</span>; <span class='color_red'>DANGL &lt; UNINIT &gt; (return|callee)</span> ;
      <span class='color_red'>return|callee = _t$2363 <span class='color_orange'>update:54</span>:int</span></span>
      
    ***** RESULTS FUNCTION CALL *******
    PROP 1 of 1:
    <span class='color_blue'><span class='color_blue'>n$18 = @f$0</span> ;
    <span class='color_red'>(-1  &lt;  n$19)</span>; <span class='color_blue'>(@f$0  &lt;=  8)</span>; <span class='color_blue'>n$1383 != 0</span>; <span class='color_blue'>t != 0</span>; <span class='color_blue'>MEMma &lt; malloc:38 &gt;  <span class='color_orange'>{vpath: }</span>(n$1385)</span>; <span class='color_blue'>MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(x)</span>; <span class='color_blue'>MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(t)</span>; <span class='color_red'>DANGL &lt; UNINIT &gt; (n$19)</span> ;
    <span class='color_blue'>x = n$1382 <span class='color_orange'>update:45</span>:node*</span>; <span class='color_blue'>n = null <span class='color_orange'>update:40</span>:node*</span>; <span class='color_blue'>t = n$17 <span class='color_orange'>update:53</span>:node*</span>; <span class='color_blue'>#GB<src.c>$head = n$1385 <span class='color_orange'>update:38</span>:node*</span>; <span class='color_blue'>i = (@f$0 + 1) <span class='color_orange'>update:43</span>:int</span>; <span class='color_blue'>return = n$1387 <span class='color_orange'>initial</span>:int</span> ;
    <span class='color_blue'>n$1385|->{next:n$1383 <span class='color_orange'>update:56</span>, v:n$1386 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16</span>; <span class='color_blue'>n$1383|->{next:t <span class='color_orange'>update:56</span>, v:n$1384 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16</span>; <span class='color_blue'>x|->{next:null <span class='color_orange'>update:46</span>, v:(@f$0 + 1) <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16</span>; <span class='color_blue'>t|->{next:null <span class='color_orange'>update:46</span>, v:@f$0 <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16</span>
    [footprint
       <span class='color_blue'>t = @f$2</span>; <span class='color_blue'>(@f$0  &lt;=  8)</span>; <span class='color_blue'>@f$3 != 0</span> *
       <span class='color_blue'>#GB<src.c>$head = @f$1 <span class='color_orange'>rearrange:38</span>:node*</span>  ]</span>
    ***** END RESULTS FUNCTION CALL *******
    Instruction Returns
    PROP 1 of 1:
    <span class='color_blue'><span class='color_blue'>n$18 = @f$0</span> ;
    <span class='color_red'>(-1  &lt;  n$19)</span>; <span class='color_blue'>(@f$0  &lt;=  8)</span>; <span class='color_blue'>_t$2 != 0</span>; <span class='color_blue'>t != 0</span>; <span class='color_blue'>MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(x)</span>; <span class='color_blue'>MEMma &lt; malloc:38 &gt;  <span class='color_orange'>{vpath: }</span>(_t$1)</span>; <span class='color_blue'>MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(t)</span>; <span class='color_red'>DANGL &lt; UNINIT &gt; (n$19)</span> ;
    <span class='color_blue'>x = _t$5 <span class='color_orange'>update:45</span>:node*</span>; <span class='color_blue'>n = null <span class='color_orange'>update:40</span>:node*</span>; <span class='color_blue'>t = n$17 <span class='color_orange'>update:53</span>:node*</span>; <span class='color_blue'>#GB<src.c>$head = _t$1 <span class='color_orange'>update:38</span>:node*</span>; <span class='color_blue'>i = (@f$0 + 1) <span class='color_orange'>update:43</span>:int</span>; <span class='color_blue'>return = _t$0 <span class='color_orange'>initial</span>:int</span> ;
    <span class='color_blue'>x|->{next:null <span class='color_orange'>update:46</span>, v:(@f$0 + 1) <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16</span>; <span class='color_blue'>_t$2|->{next:t <span class='color_orange'>update:56</span>, v:_t$4 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16</span>; <span class='color_blue'>_t$1|->{next:_t$2 <span class='color_orange'>update:56</span>, v:_t$3 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16</span>; <span class='color_blue'>t|->{next:null <span class='color_orange'>update:46</span>, v:@f$0 <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16</span>
    [footprint
       <span class='color_blue'>t = @f$2</span>; <span class='color_blue'>(@f$0  &lt;=  8)</span>; <span class='color_blue'>@f$3 != 0</span> *
       <span class='color_blue'>#GB<src.c>$head = @f$1 <span class='color_orange'>rearrange:38</span>:node*</span>  ]</span>
    
    Instruction <span class='color_green'>REMOVE_TEMPS(n$17,n$18,n$19); [line 54, column 7]</span>
    in vpath_find exp:_t$7
    vpath_find: found x : node*
    in vpath_find exp:_t$6
    vpath_find: cannot find _t$6
    in vpath_find exp:_t$1
    vpath_find: found head : node*
    Instruction Returns
    PROP 1 of 1:
    <span class='color_blue'><span class='color_red'>(-1  &lt;  _t$10)</span>; <span class='color_blue'>(@f$0  &lt;=  8)</span>; <span class='color_red'>t != 0</span>; <span class='color_blue'>_t$2 != 0</span>; <span class='color_red'>MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(x)</span>; <span class='color_red'>MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(_t$8)</span>; <span class='color_blue'>MEMma &lt; malloc:38 &gt;  <span class='color_orange'>{vpath: }</span>(_t$1)</span>; <span class='color_red'>DANGL &lt; UNINIT &gt; (_t$10)</span>; <span class='color_blue'>DANGL &lt; UNINIT &gt; (_t$7)</span> ;
    <span class='color_blue'>x = <span class='color_red'>_t$9 <span class='color_orange'>update:45</span></span>:node*</span>; <span class='color_blue'>n = null <span class='color_orange'>update:40</span>:node*</span>; <span class='color_blue'>t = <span class='color_red'>_t$4 <span class='color_orange'>update:53</span></span>:node*</span>; <span class='color_blue'>#GB<src.c>$head = _t$1 <span class='color_orange'>update:38</span>:node*</span>; <span class='color_blue'>i = (@f$0 + 1) <span class='color_orange'>update:43</span>:int</span>; <span class='color_blue'>return = _t$0 <span class='color_orange'>initial</span>:int</span> ;
    <span class='color_red'>x|->{next:null <span class='color_orange'>update:46</span>, v:(@f$0 + 1) <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16</span>; <span class='color_red'>_t$8|->{next:null <span class='color_orange'>update:46</span>, v:@f$0 <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16</span>; <span class='color_red'>t|->{next:_t$6 <span class='color_orange'>update:56</span>, v:_t$7 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16</span>; <span class='color_blue'>_t$2|->{next:<span class='color_red'>t <span class='color_orange'>update:56</span></span>, v:<span class='color_red'>_t$5 <span class='color_orange'>alloc</span></span>} <span class='color_orange'>alloc</span>:node16</span>; <span class='color_blue'>_t$1|->{next:_t$2 <span class='color_orange'>update:56</span>, v:_t$3 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16</span>; <span class='color_blue'>lseg(_t$6,_t$8,[],P0)</span>
    [footprint
       <span class='color_blue'>(@f$0  &lt;=  8)</span>; <span class='color_blue'>@f$2 != 0</span> *
       <span class='color_blue'>#GB<src.c>$head = @f$1 <span class='color_orange'>rearrange:38</span>:node*</span>  ]
    where
    P0 = exists [_t$2]. <span class='color_blue'>_t$0|->{next:_t$1 <span class='color_orange'>update:56</span>, v:_t$2 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16</span></span>
    
    Instruction <span class='color_green'>REMOVE_TEMPS(n$17,n$18,n$19); [line 54, column 7]</span>
    in vpath_find exp:_t$5
    vpath_find: found x : node*
    in vpath_find exp:_t$1
    vpath_find: found head : node*
    in vpath_find exp:n$17
    vpath_find: found t : node*
    Instruction Returns
    PROP 1 of 1:
    <span class='color_blue'><span class='color_red'>(-1  &lt;  _t$7)</span>; <span class='color_blue'>(@f$0  &lt;=  8)</span>; <span class='color_red'>t != 0</span>; <span class='color_blue'>_t$2 != 0</span>; <span class='color_red'>MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(x)</span>; <span class='color_red'>MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(t)</span>; <span class='color_blue'>MEMma &lt; malloc:38 &gt;  <span class='color_orange'>{vpath: }</span>(_t$1)</span>; <span class='color_red'>DANGL &lt; UNINIT &gt; (_t$7)</span> ;
    <span class='color_blue'>x = <span class='color_red'>_t$6 <span class='color_orange'>update:45</span></span>:node*</span>; <span class='color_blue'>n = null <span class='color_orange'>update:40</span>:node*</span>; <span class='color_blue'>t = <span class='color_red'>_t$4 <span class='color_orange'>update:53</span></span>:node*</span>; <span class='color_blue'>#GB<src.c>$head = _t$1 <span class='color_orange'>update:38</span>:node*</span>; <span class='color_blue'>i = (@f$0 + 1) <span class='color_orange'>update:43</span>:int</span>; <span class='color_blue'>return = _t$0 <span class='color_orange'>initial</span>:int</span> ;
    <span class='color_red'>x|->{next:null <span class='color_orange'>update:46</span>, v:(@f$0 + 1) <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16</span>; <span class='color_red'>t|->{next:null <span class='color_orange'>update:46</span>, v:@f$0 <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16</span>; <span class='color_blue'>_t$2|->{next:<span class='color_red'>t <span class='color_orange'>update:56</span></span>, v:<span class='color_red'>_t$5 <span class='color_orange'>alloc</span></span>} <span class='color_orange'>alloc</span>:node16</span>; <span class='color_blue'>_t$1|->{next:_t$2 <span class='color_orange'>update:56</span>, v:_t$3 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16</span>
    [footprint
       <span class='color_blue'>@f$3 = @f$2</span>; <span class='color_blue'>(@f$0  &lt;=  8)</span>; <span class='color_red'>@f$4 != 0</span> *
       <span class='color_blue'>#GB<src.c>$head = @f$1 <span class='color_orange'>rearrange:38</span>:node*</span>  ]</span>
    
    Instruction <span class='color_green'>APPLY_ABSTRACTION; [line 54, column 7]</span>
    in vpath_find exp:_t$9
    vpath_find: found x : node*
    in vpath_find exp:_t$8
    vpath_find: cannot find _t$8
    in vpath_find exp:_t$1
    vpath_find: found head : node*
    <span class='color_blue'>(@f$0  &lt;=  8); t != 0; MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(x); MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(_t$3); MEMma &lt; malloc:38 &gt;  <span class='color_orange'>{vpath: }</span>(_t$1) ;
    x = _t$4 <span class='color_orange'>update:45</span>:node*; n = null <span class='color_orange'>update:40</span>:node*; t = _t$2 <span class='color_orange'>update:53</span>:node*; #GB<src.c>$head = _t$1 <span class='color_orange'>update:38</span>:node*; i = (@f$0 + 1) <span class='color_orange'>update:43</span>:int; return = _t$0 <span class='color_orange'>initial</span>:int ;
    x|->{next:null <span class='color_orange'>update:46</span>, v:(@f$0 + 1) <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16; _t$3|->{next:null <span class='color_orange'>update:46</span>, v:@f$0 <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16; lsegne(t,_t$3,[],P0); lsegne(_t$1,t,[],P0)
    [footprint
       (@f$0  &lt;=  8) *
       #GB<src.c>$head = @f$1 <span class='color_orange'>rearrange:38</span>:node*  ]
    where
    P0 = exists [_t$2]. _t$0|->{next:_t$1 <span class='color_orange'>update:56</span>, v:_t$2 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16</span>
    Instruction Returns
    PROP 1 of 1:
    <span class='color_blue'><span class='color_blue'>(@f$0  &lt;=  8)</span>; <span class='color_blue'>t != 0</span>; <span class='color_blue'>MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(x)</span>; <span class='color_red'>MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(_t$3)</span>; <span class='color_blue'>MEMma &lt; malloc:38 &gt;  <span class='color_orange'>{vpath: }</span>(_t$1)</span> ;
    <span class='color_blue'>x = <span class='color_red'>_t$4 <span class='color_orange'>update:45</span></span>:node*</span>; <span class='color_blue'>n = null <span class='color_orange'>update:40</span>:node*</span>; <span class='color_blue'>t = <span class='color_red'>_t$2 <span class='color_orange'>update:53</span></span>:node*</span>; <span class='color_blue'>#GB<src.c>$head = _t$1 <span class='color_orange'>update:38</span>:node*</span>; <span class='color_blue'>i = (@f$0 + 1) <span class='color_orange'>update:43</span>:int</span>; <span class='color_blue'>return = _t$0 <span class='color_orange'>initial</span>:int</span> ;
    <span class='color_blue'>x|->{next:<span class='color_red'>null <span class='color_orange'>update:46</span></span>, v:<span class='color_red'>(@f$0 + 1) <span class='color_orange'>update:47</span></span>} <span class='color_orange'>alloc</span>:node16</span>; <span class='color_red'>_t$3|->{next:null <span class='color_orange'>update:46</span>, v:@f$0 <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16</span>; <span class='color_blue'>lsegne(t,_t$3,[],P0)</span>; <span class='color_blue'>lsegne(_t$1,t,[],P0)</span>
    [footprint
       <span class='color_blue'>(@f$0  &lt;=  8)</span> *
       <span class='color_blue'>#GB<src.c>$head = @f$1 <span class='color_orange'>rearrange:38</span>:node*</span>  ]
    where
    P0 = exists [_t$2]. <span class='color_blue'>_t$0|->{next:_t$1 <span class='color_orange'>update:56</span>, v:_t$2 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16</span></span>
    
    Instruction <span class='color_green'>APPLY_ABSTRACTION; [line 54, column 7]</span>
    in vpath_find exp:_t$6
    vpath_find: found x : node*
    in vpath_find exp:_t$4
    vpath_find: found t : node*
    in vpath_find exp:_t$1
    vpath_find: found head : node*
    <span class='color_blue'>(@f$0  &lt;=  8); t != 0; MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(x); MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(t); MEMma &lt; malloc:38 &gt;  <span class='color_orange'>{vpath: }</span>(_t$1) ;
    x = _t$3 <span class='color_orange'>update:45</span>:node*; n = null <span class='color_orange'>update:40</span>:node*; t = _t$2 <span class='color_orange'>update:53</span>:node*; #GB<src.c>$head = _t$1 <span class='color_orange'>update:38</span>:node*; i = (@f$0 + 1) <span class='color_orange'>update:43</span>:int; return = _t$0 <span class='color_orange'>initial</span>:int ;
    x|->{next:null <span class='color_orange'>update:46</span>, v:(@f$0 + 1) <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16; t|->{next:null <span class='color_orange'>update:46</span>, v:@f$0 <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16; lsegne(_t$1,t,[],P0)
    [footprint
       (@f$0  &lt;=  8) *
       #GB<src.c>$head = @f$1 <span class='color_orange'>rearrange:38</span>:node*  ]
    where
    P0 = exists [_t$2]. _t$0|->{next:_t$1 <span class='color_orange'>update:56</span>, v:_t$2 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16</span>
    Instruction Returns
    PROP 1 of 1:
    <span class='color_blue'><span class='color_blue'>(@f$0  &lt;=  8)</span>; <span class='color_blue'>t != 0</span>; <span class='color_red'>MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(x)</span>; <span class='color_blue'>MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(t)</span>; <span class='color_blue'>MEMma &lt; malloc:38 &gt;  <span class='color_orange'>{vpath: }</span>(_t$1)</span> ;
    <span class='color_blue'>x = <span class='color_red'>_t$3 <span class='color_orange'>update:45</span></span>:node*</span>; <span class='color_blue'>n = null <span class='color_orange'>update:40</span>:node*</span>; <span class='color_blue'>t = <span class='color_red'>_t$2 <span class='color_orange'>update:53</span></span>:node*</span>; <span class='color_blue'>#GB<src.c>$head = _t$1 <span class='color_orange'>update:38</span>:node*</span>; <span class='color_blue'>i = (@f$0 + 1) <span class='color_orange'>update:43</span>:int</span>; <span class='color_blue'>return = _t$0 <span class='color_orange'>initial</span>:int</span> ;
    <span class='color_red'>x|->{next:null <span class='color_orange'>update:46</span>, v:(@f$0 + 1) <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16</span>; <span class='color_blue'>t|->{next:<span class='color_red'>null <span class='color_orange'>update:46</span></span>, v:<span class='color_red'>@f$0 <span class='color_orange'>update:47</span></span>} <span class='color_orange'>alloc</span>:node16</span>; <span class='color_blue'>lsegne(_t$1,t,[],P0)</span>
    [footprint
       <span class='color_blue'>(@f$0  &lt;=  8)</span> *
       <span class='color_blue'>#GB<src.c>$head = @f$1 <span class='color_orange'>rearrange:38</span>:node*</span>  ]
    where
    P0 = exists [_t$2]. <span class='color_blue'>_t$0|->{next:_t$1 <span class='color_orange'>update:56</span>, v:_t$2 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16</span></span>
    
    .... After Symbolic Execution ....
    PROP 1 of 2:
    <span class='color_blue'><span class='color_blue'>(@f$0  &lt;=  8)</span>; <span class='color_blue'>t != 0</span>; <span class='color_blue'>MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(x)</span>; <span class='color_red'>MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(_t$3)</span>; <span class='color_blue'>MEMma &lt; malloc:38 &gt;  <span class='color_orange'>{vpath: }</span>(_t$1)</span> ;
    <span class='color_blue'>x = <span class='color_red'>_t$4 <span class='color_orange'>update:45</span></span>:node*</span>; <span class='color_blue'>n = null <span class='color_orange'>update:40</span>:node*</span>; <span class='color_blue'>t = <span class='color_red'>_t$2 <span class='color_orange'>update:53</span></span>:node*</span>; <span class='color_blue'>#GB<src.c>$head = _t$1 <span class='color_orange'>update:38</span>:node*</span>; <span class='color_blue'>i = (@f$0 + 1) <span class='color_orange'>update:43</span>:int</span>; <span class='color_blue'>return = _t$0 <span class='color_orange'>initial</span>:int</span> ;
    <span class='color_blue'>x|->{next:null <span class='color_orange'>update:46</span>, v:(@f$0 + 1) <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16</span>; <span class='color_red'>_t$3|->{next:null <span class='color_orange'>update:46</span>, v:@f$0 <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16</span>; <span class='color_blue'>lsegne(t,_t$3,[],P0)</span>; <span class='color_blue'>lsegne(_t$1,t,[],P0)</span>
    [footprint
       <span class='color_blue'>(@f$0  &lt;=  8)</span> *
       <span class='color_blue'>#GB<src.c>$head = @f$1 <span class='color_orange'>rearrange:38</span>:node*</span>  ]
    where
    P0 = exists [_t$2]. <span class='color_blue'>_t$0|->{next:_t$1 <span class='color_orange'>update:56</span>, v:_t$2 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16</span></span>
    PROP 2 of 2:
    <span class='color_blue'><span class='color_blue'>(@f$0  &lt;=  8)</span>; <span class='color_blue'>t != 0</span>; <span class='color_red'>MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(x)</span>; <span class='color_blue'>MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(t)</span>; <span class='color_blue'>MEMma &lt; malloc:38 &gt;  <span class='color_orange'>{vpath: }</span>(_t$1)</span> ;
    <span class='color_blue'>x = <span class='color_red'>_t$3 <span class='color_orange'>update:45</span></span>:node*</span>; <span class='color_blue'>n = null <span class='color_orange'>update:40</span>:node*</span>; <span class='color_blue'>t = <span class='color_red'>_t$2 <span class='color_orange'>update:53</span></span>:node*</span>; <span class='color_blue'>#GB<src.c>$head = _t$1 <span class='color_orange'>update:38</span>:node*</span>; <span class='color_blue'>i = (@f$0 + 1) <span class='color_orange'>update:43</span>:int</span>; <span class='color_blue'>return = _t$0 <span class='color_orange'>initial</span>:int</span> ;
    <span class='color_red'>x|->{next:null <span class='color_orange'>update:46</span>, v:(@f$0 + 1) <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16</span>; <span class='color_blue'>t|->{next:<span class='color_red'>null <span class='color_orange'>update:46</span></span>, v:<span class='color_red'>@f$0 <span class='color_orange'>update:47</span></span>} <span class='color_orange'>alloc</span>:node16</span>; <span class='color_blue'>lsegne(_t$1,t,[],P0)</span>
    [footprint
       <span class='color_blue'>(@f$0  &lt;=  8)</span> *
       <span class='color_blue'>#GB<src.c>$head = @f$1 <span class='color_orange'>rearrange:38</span>:node*</span>  ]
    where
    P0 = exists [_t$2]. <span class='color_blue'>_t$0|->{next:_t$1 <span class='color_orange'>update:56</span>, v:_t$2 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16</span></span>
    
    
    
  Processing prop 2/2
    Instruction <span class='color_green'>n$17=*&amp;t:node* [line 54, column 21]</span>
    in vpath_find exp:n$1393
    vpath_find: found head : node*
    in vpath_find exp:n$1388
    vpath_find: found x : node*
    .... Rearrangement Start ....
    Exp: &amp;t
    Prop: 
    <span class='color_blue'>t != 0; MEMma &lt; malloc:38 &gt;  <span class='color_orange'>{vpath: }</span>(n$1393); MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(x) ;
    x = n$1388 <span class='color_orange'>update:45</span>:node*; n = n$1389 <span class='color_orange'>update:58</span>:node*; t = n$1391 <span class='color_orange'>update:53</span>:node*; #GB<src.c>$head = n$1393 <span class='color_orange'>update:38</span>:node*; i = 4 <span class='color_orange'>update:43</span>:int; return = n$1395 <span class='color_orange'>initial</span>:int ;
    n$1393|->{next:n$1390 <span class='color_orange'>update:56</span>, v:n$1394 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16; n$1390|->{next:t <span class='color_orange'>update:56</span>, v:n$1392 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16; n|->{next:null <span class='color_orange'>update:46</span>, v:3 <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16; x|->{next:null <span class='color_orange'>update:46</span>, v:4 <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16; lseg(t,n,[],P0)
    [footprint
       @f$1 != 0 *
       #GB<src.c>$head = @f$0 <span class='color_orange'>rearrange:38</span>:node*  ]
    where
    P0 = exists [_t$2]. _t$0|->{next:_t$1 <span class='color_orange'>update:56</span>, v:_t$2 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16</span>
    
    in prop_iter_extend_ptsto lexp: &amp;t
    prop before:
    <span class='color_blue'>t != 0; MEMma &lt; malloc:38 &gt;  <span class='color_orange'>{vpath: }</span>(n$1393); MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(x) ;
    x = n$1388 <span class='color_orange'>update:45</span>:node*; n = n$1389 <span class='color_orange'>update:58</span>:node*; t = n$1391 <span class='color_orange'>update:53</span>:node*; #GB<src.c>$head = n$1393 <span class='color_orange'>update:38</span>:node*; i = 4 <span class='color_orange'>update:43</span>:int; return = n$1395 <span class='color_orange'>initial</span>:int ;
    n$1393|->{next:n$1390 <span class='color_orange'>update:56</span>, v:n$1394 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16; n$1390|->{next:t <span class='color_orange'>update:56</span>, v:n$1392 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16; n|->{next:null <span class='color_orange'>update:46</span>, v:3 <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16; x|->{next:null <span class='color_orange'>update:46</span>, v:4 <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16; lseg(t,n,[],P0)
    [footprint
       @f$1 != 0 *
       #GB<src.c>$head = @f$0 <span class='color_orange'>rearrange:38</span>:node*  ]
    where
    P0 = exists [_t$2]. _t$0|->{next:_t$1 <span class='color_orange'>update:56</span>, v:_t$2 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16</span>
    
    
    prop list after:
    PROP 1 of 1:
    <span class='color_blue'><span class='color_blue'>t != 0</span>; <span class='color_blue'>MEMma &lt; malloc:38 &gt;  <span class='color_orange'>{vpath: }</span>(n$1393)</span>; <span class='color_blue'>MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(x)</span> ;
    <span class='color_blue'>x = n$1388 <span class='color_orange'>update:45</span>:node*</span>; <span class='color_blue'>n = n$1389 <span class='color_orange'>update:58</span>:node*</span>; <span class='color_blue'>t = n$1391 <span class='color_orange'>update:53</span>:node*</span>; <span class='color_blue'>#GB<src.c>$head = n$1393 <span class='color_orange'>update:38</span>:node*</span>; <span class='color_blue'>i = 4 <span class='color_orange'>update:43</span>:int</span>; <span class='color_blue'>return = n$1395 <span class='color_orange'>initial</span>:int</span> ;
    <span class='color_blue'>n$1393|->{next:n$1390 <span class='color_orange'>update:56</span>, v:n$1394 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16</span>; <span class='color_blue'>n$1390|->{next:t <span class='color_orange'>update:56</span>, v:n$1392 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16</span>; <span class='color_blue'>n|->{next:null <span class='color_orange'>update:46</span>, v:3 <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16</span>; <span class='color_blue'>x|->{next:null <span class='color_orange'>update:46</span>, v:4 <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16</span>; <span class='color_blue'>lseg(t,n,[],P0)</span>
    [footprint
       <span class='color_blue'>@f$1 != 0</span> *
       <span class='color_blue'>#GB<src.c>$head = @f$0 <span class='color_orange'>rearrange:38</span>:node*</span>  ]
    where
    P0 = exists [_t$2]. <span class='color_blue'>_t$0|->{next:_t$1 <span class='color_orange'>update:56</span>, v:_t$2 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16</span></span>
    
    
    
    Instruction Returns
    PROP 1 of 1:
    <span class='color_blue'><span class='color_red'>t != 0</span>; <span class='color_red'>MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(x)</span>; <span class='color_blue'>MEMma &lt; malloc:38 &gt;  <span class='color_orange'>{vpath: }</span>(_t$1)</span> ;
    <span class='color_blue'>x = <span class='color_red'>_t$6 <span class='color_orange'>update:45</span></span>:node*</span>; <span class='color_blue'>n = <span class='color_red'>_t$5 <span class='color_orange'>update:58</span></span>:node*</span>; <span class='color_blue'>t = <span class='color_red'>n$17 <span class='color_orange'>update:53</span></span>:node*</span>; <span class='color_blue'>#GB<src.c>$head = _t$1 <span class='color_orange'>update:38</span>:node*</span>; <span class='color_blue'>i = 4 <span class='color_orange'>update:43</span>:int</span>; <span class='color_blue'>return = _t$0 <span class='color_orange'>initial</span>:int</span> ;
    <span class='color_blue'>x|->{next:null <span class='color_orange'>update:46</span>, v:<span class='color_red'>4 <span class='color_orange'>update:47</span></span>} <span class='color_orange'>alloc</span>:node16</span>; <span class='color_red'>n|->{next:null <span class='color_orange'>update:46</span>, v:3 <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16</span>; <span class='color_blue'>_t$2|->{next:<span class='color_red'>t <span class='color_orange'>update:56</span></span>, v:<span class='color_red'>_t$4 <span class='color_orange'>alloc</span></span>} <span class='color_orange'>alloc</span>:node16</span>; <span class='color_blue'>_t$1|->{next:_t$2 <span class='color_orange'>update:56</span>, v:_t$3 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16</span>; <span class='color_red'>lseg(t,n,[],P0)</span>
    [footprint
       <span class='color_blue'>@f$1 != 0</span> *
       <span class='color_blue'>#GB<src.c>$head = @f$0 <span class='color_orange'>rearrange:38</span>:node*</span>  ]
    where
    P0 = exists [_t$2]. <span class='color_blue'>_t$0|->{next:_t$1 <span class='color_orange'>update:56</span>, v:_t$2 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16</span></span>
    
    Instruction <span class='color_green'>n$18=*n$17.v:int [line 54, column 21]</span>
    in vpath_find exp:n$1400
    vpath_find: found head : node*
    in vpath_find exp:n$1396
    vpath_find: found x : node*
    .... Rearrangement Start ....
    Exp: n$17.v
    Prop: 
    <span class='color_blue'>t != 0; MEMma &lt; malloc:38 &gt;  <span class='color_orange'>{vpath: }</span>(n$1400); MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(x) ;
    x = n$1396 <span class='color_orange'>update:45</span>:node*; n = n$1397 <span class='color_orange'>update:58</span>:node*; t = n$17 <span class='color_orange'>update:53</span>:node*; #GB<src.c>$head = n$1400 <span class='color_orange'>update:38</span>:node*; i = 4 <span class='color_orange'>update:43</span>:int; return = n$1402 <span class='color_orange'>initial</span>:int ;
    n$1400|->{next:n$1398 <span class='color_orange'>update:56</span>, v:n$1401 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16; n$1398|->{next:t <span class='color_orange'>update:56</span>, v:n$1399 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16; n|->{next:null <span class='color_orange'>update:46</span>, v:3 <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16; x|->{next:null <span class='color_orange'>update:46</span>, v:4 <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16; lseg(t,n,[],P0)
    [footprint
       @f$1 != 0 *
       #GB<src.c>$head = @f$0 <span class='color_orange'>rearrange:38</span>:node*  ]
    where
    P0 = exists [_t$2]. _t$0|->{next:_t$1 <span class='color_orange'>update:56</span>, v:_t$2 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16</span>
    
    in prop_iter_extend_ptsto lexp: n$17.v
    prop before:
    <span class='color_blue'>t != 0; MEMma &lt; malloc:38 &gt;  <span class='color_orange'>{vpath: }</span>(n$1400); MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(x) ;
    x = n$1396 <span class='color_orange'>update:45</span>:node*; n = n$1397 <span class='color_orange'>update:58</span>:node*; t = n$17 <span class='color_orange'>update:53</span>:node*; #GB<src.c>$head = n$1400 <span class='color_orange'>update:38</span>:node*; i = 4 <span class='color_orange'>update:43</span>:int; return = n$1402 <span class='color_orange'>initial</span>:int ;
    n$1400|->{next:n$1398 <span class='color_orange'>update:56</span>, v:n$1401 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16; n$1398|->{next:t <span class='color_orange'>update:56</span>, v:n$1399 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16; n|->{next:null <span class='color_orange'>update:46</span>, v:3 <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16; x|->{next:null <span class='color_orange'>update:46</span>, v:4 <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16; t|->{next:_t$2435 <span class='color_orange'>update:56</span>, v:_t$2436 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16; lseg(_t$2435,n,[],P0)
    [footprint
       @f$1 != 0 *
       #GB<src.c>$head = @f$0 <span class='color_orange'>rearrange:38</span>:node*  ]
    where
    P0 = exists [_t$2]. _t$0|->{next:_t$1 <span class='color_orange'>update:56</span>, v:_t$2 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16</span>
    
    
    prop list after:
    PROP 1 of 1:
    <span class='color_blue'><span class='color_blue'>t != 0</span>; <span class='color_blue'>MEMma &lt; malloc:38 &gt;  <span class='color_orange'>{vpath: }</span>(n$1400)</span>; <span class='color_blue'>MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(x)</span> ;
    <span class='color_blue'>x = n$1396 <span class='color_orange'>update:45</span>:node*</span>; <span class='color_blue'>n = n$1397 <span class='color_orange'>update:58</span>:node*</span>; <span class='color_blue'>t = n$17 <span class='color_orange'>update:53</span>:node*</span>; <span class='color_blue'>#GB<src.c>$head = n$1400 <span class='color_orange'>update:38</span>:node*</span>; <span class='color_blue'>i = 4 <span class='color_orange'>update:43</span>:int</span>; <span class='color_blue'>return = n$1402 <span class='color_orange'>initial</span>:int</span> ;
    <span class='color_blue'>n$1400|->{next:n$1398 <span class='color_orange'>update:56</span>, v:n$1401 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16</span>; <span class='color_blue'>n$1398|->{next:t <span class='color_orange'>update:56</span>, v:n$1399 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16</span>; <span class='color_blue'>n|->{next:null <span class='color_orange'>update:46</span>, v:3 <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16</span>; <span class='color_blue'>x|->{next:null <span class='color_orange'>update:46</span>, v:4 <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16</span>; <span class='color_blue'>t|->{next:_t$2435 <span class='color_orange'>update:56</span>, v:_t$2436 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16</span>; <span class='color_blue'>lseg(_t$2435,n,[],P0)</span>
    [footprint
       <span class='color_blue'>@f$1 != 0</span> *
       <span class='color_blue'>#GB<src.c>$head = @f$0 <span class='color_orange'>rearrange:38</span>:node*</span>  ]
    where
    P0 = exists [_t$2]. <span class='color_blue'>_t$0|->{next:_t$1 <span class='color_orange'>update:56</span>, v:_t$2 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16</span></span>
    
    
    
    in prop_iter_extend_ptsto lexp: n$17.v
    prop before:
    <span class='color_blue'>n$1397 = t ;
    t != 0; MEMma &lt; malloc:38 &gt;  <span class='color_orange'>{vpath: }</span>(n$1400); MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(x) ;
    x = n$1396 <span class='color_orange'>update:45</span>:node*; n = n$17 <span class='color_orange'>update:58</span>:node*; t = n$17 <span class='color_orange'>update:53</span>:node*; #GB<src.c>$head = n$1400 <span class='color_orange'>update:38</span>:node*; i = 4 <span class='color_orange'>update:43</span>:int; return = n$1402 <span class='color_orange'>initial</span>:int ;
    n$1400|->{next:n$1398 <span class='color_orange'>update:56</span>, v:n$1401 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16; n$1398|->{next:t <span class='color_orange'>update:56</span>, v:n$1399 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16; x|->{next:null <span class='color_orange'>update:46</span>, v:4 <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16; t|->{next:null <span class='color_orange'>update:46</span>, v:3 <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16
    [footprint
       n$1397 = t; @f$1 != 0 *
       #GB<src.c>$head = @f$0 <span class='color_orange'>rearrange:38</span>:node*  ]</span>
    
    
    prop list after:
    PROP 1 of 1:
    <span class='color_blue'><span class='color_blue'>n$1397 = t</span> ;
    <span class='color_blue'>t != 0</span>; <span class='color_blue'>MEMma &lt; malloc:38 &gt;  <span class='color_orange'>{vpath: }</span>(n$1400)</span>; <span class='color_blue'>MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(x)</span> ;
    <span class='color_blue'>x = n$1396 <span class='color_orange'>update:45</span>:node*</span>; <span class='color_blue'>n = n$17 <span class='color_orange'>update:58</span>:node*</span>; <span class='color_blue'>t = n$17 <span class='color_orange'>update:53</span>:node*</span>; <span class='color_blue'>#GB<src.c>$head = n$1400 <span class='color_orange'>update:38</span>:node*</span>; <span class='color_blue'>i = 4 <span class='color_orange'>update:43</span>:int</span>; <span class='color_blue'>return = n$1402 <span class='color_orange'>initial</span>:int</span> ;
    <span class='color_blue'>n$1400|->{next:n$1398 <span class='color_orange'>update:56</span>, v:n$1401 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16</span>; <span class='color_blue'>n$1398|->{next:t <span class='color_orange'>update:56</span>, v:n$1399 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16</span>; <span class='color_blue'>x|->{next:null <span class='color_orange'>update:46</span>, v:4 <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16</span>; <span class='color_blue'>t|->{next:null <span class='color_orange'>update:46</span>, v:3 <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16</span>
    [footprint
       <span class='color_blue'>n$1397 = t</span>; <span class='color_blue'>@f$1 != 0</span> *
       <span class='color_blue'>#GB<src.c>$head = @f$0 <span class='color_orange'>rearrange:38</span>:node*</span>  ]</span>
    
    
    
    Instruction Returns
    PROP 1 of 2:
    <span class='color_blue'><span class='color_blue'>t != 0</span>; <span class='color_red'>MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(x)</span>; <span class='color_blue'>MEMma &lt; malloc:38 &gt;  <span class='color_orange'>{vpath: }</span>(_t$1)</span>; <span class='color_red'>DANGL &lt; UNINIT &gt; (n$18)</span> ;
    <span class='color_blue'>x = <span class='color_red'>_t$7 <span class='color_orange'>update:45</span></span>:node*</span>; <span class='color_blue'>n = <span class='color_red'>_t$6 <span class='color_orange'>update:58</span></span>:node*</span>; <span class='color_blue'>t = n$17 <span class='color_orange'>update:53</span>:node*</span>; <span class='color_blue'>#GB<src.c>$head = _t$1 <span class='color_orange'>update:38</span>:node*</span>; <span class='color_blue'>i = 4 <span class='color_orange'>update:43</span>:int</span>; <span class='color_blue'>return = _t$0 <span class='color_orange'>initial</span>:int</span> ;
    <span class='color_red'>x|->{next:null <span class='color_orange'>update:46</span>, v:4 <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16</span>; <span class='color_blue'>n|->{next:null <span class='color_orange'>update:46</span>, v:<span class='color_red'>3 <span class='color_orange'>update:47</span></span>} <span class='color_orange'>alloc</span>:node16</span>; <span class='color_blue'>_t$2|->{next:t <span class='color_orange'>update:56</span>, v:_t$4 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16</span>; <span class='color_blue'>_t$1|->{next:_t$2 <span class='color_orange'>update:56</span>, v:_t$3 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16</span>; <span class='color_blue'>t|->{next:_t$5 <span class='color_orange'>update:56</span>, v:n$18 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16</span>; <span class='color_blue'>lseg(_t$5,n,[],P0)</span>
    [footprint
       <span class='color_blue'>@f$1 != 0</span> *
       <span class='color_blue'>#GB<src.c>$head = @f$0 <span class='color_orange'>rearrange:38</span>:node*</span>  ]
    where
    P0 = exists [_t$2]. <span class='color_blue'>_t$0|->{next:_t$1 <span class='color_orange'>update:56</span>, v:_t$2 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16</span></span>
    PROP 2 of 2:
    <span class='color_blue'><span class='color_red'>n$18 = 3</span> ;
    <span class='color_blue'>t != 0</span>; <span class='color_red'>MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(x)</span>; <span class='color_blue'>MEMma &lt; malloc:38 &gt;  <span class='color_orange'>{vpath: }</span>(_t$1)</span> ;
    <span class='color_blue'>x = <span class='color_red'>_t$5 <span class='color_orange'>update:45</span></span>:node*</span>; <span class='color_blue'>n = <span class='color_red'>n$17 <span class='color_orange'>update:58</span></span>:node*</span>; <span class='color_blue'>t = n$17 <span class='color_orange'>update:53</span>:node*</span>; <span class='color_blue'>#GB<src.c>$head = _t$1 <span class='color_orange'>update:38</span>:node*</span>; <span class='color_blue'>i = 4 <span class='color_orange'>update:43</span>:int</span>; <span class='color_blue'>return = _t$0 <span class='color_orange'>initial</span>:int</span> ;
    <span class='color_blue'>x|->{next:null <span class='color_orange'>update:46</span>, v:<span class='color_red'>4 <span class='color_orange'>update:47</span></span>} <span class='color_orange'>alloc</span>:node16</span>; <span class='color_blue'>_t$2|->{next:t <span class='color_orange'>update:56</span>, v:_t$4 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16</span>; <span class='color_blue'>_t$1|->{next:_t$2 <span class='color_orange'>update:56</span>, v:_t$3 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16</span>; <span class='color_blue'>t|->{next:null <span class='color_orange'>update:46</span>, v:3 <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16</span>
    [footprint
       <span class='color_red'>t = @f$1</span>; <span class='color_red'>@f$2 != 0</span> *
       <span class='color_blue'>#GB<src.c>$head = @f$0 <span class='color_orange'>rearrange:38</span>:node*</span>  ]</span>
    
    Instruction <span class='color_green'>n$19=_fun_printf("%d\n":char const *,n$18:int) [line 54, column 7]</span>
    in vpath_find exp:n$1407
    vpath_find: found head : node*
    in vpath_find exp:n$1403
    vpath_find: found x : node*
    <span class='color_orange'>WARNING: likely use of variable-arguments function, or function prototype missing</span>
    actual parameters: n$18
    formal parameters: 
    Found 1 specs for function printf
    START EXECUTING SPECS FOR printf from state
    <span class='color_blue'>t != 0; MEMma &lt; malloc:38 &gt;  <span class='color_orange'>{vpath: }</span>(n$1407); MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(x); DANGL &lt; UNINIT &gt; (n$18) ;
    x = n$1403 <span class='color_orange'>update:45</span>:node*; n = n$1404 <span class='color_orange'>update:58</span>:node*; t = n$17 <span class='color_orange'>update:53</span>:node*; #GB<src.c>$head = n$1407 <span class='color_orange'>update:38</span>:node*; i = 4 <span class='color_orange'>update:43</span>:int; return = n$1410 <span class='color_orange'>initial</span>:int ;
    n$1407|->{next:n$1405 <span class='color_orange'>update:56</span>, v:n$1408 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16; n$1405|->{next:t <span class='color_orange'>update:56</span>, v:n$1406 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16; n|->{next:null <span class='color_orange'>update:46</span>, v:3 <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16; x|->{next:null <span class='color_orange'>update:46</span>, v:4 <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16; t|->{next:n$1409 <span class='color_orange'>update:56</span>, v:n$18 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16; lseg(n$1409,n,[],P0)
    [footprint
       @f$1 != 0 *
       #GB<src.c>$head = @f$0 <span class='color_orange'>rearrange:38</span>:node*  ]
    where
    P0 = exists [_t$2]. _t$0|->{next:_t$1 <span class='color_orange'>update:56</span>, v:_t$2 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16</span>
    <span class='color_orange'>WARNING: more actual pars than formal pars in fun call (2 vs 1)</span>
    EXECUTING SPEC 1/1
    ACTUAL PRECONDITION =
      <span class='color_blue'>t != 0; MEMma &lt; malloc:38 &gt;  <span class='color_orange'>{vpath: }</span>(n$1407); MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(x); DANGL &lt; UNINIT &gt; (n$18) ;
      x = n$1403 <span class='color_orange'>update:45</span>:node*; n = n$1404 <span class='color_orange'>update:58</span>:node*; t = n$17 <span class='color_orange'>update:53</span>:node*; #GB<src.c>$head = n$1407 <span class='color_orange'>update:38</span>:node*; i = 4 <span class='color_orange'>update:43</span>:int; format|callee = "%d\n" <span class='color_orange'>actual_precondition</span>:char const *; return = n$1410 <span class='color_orange'>initial</span>:int ;
      n$1407|->{next:n$1405 <span class='color_orange'>update:56</span>, v:n$1408 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16; n$1405|->{next:t <span class='color_orange'>update:56</span>, v:n$1406 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16; n|->{next:null <span class='color_orange'>update:46</span>, v:3 <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16; x|->{next:null <span class='color_orange'>update:46</span>, v:4 <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16; t|->{next:n$1409 <span class='color_orange'>update:56</span>, v:n$18 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16; lseg(n$1409,n,[],P0)
      [footprint
         @f$1 != 0 *
         #GB<src.c>$head = @f$0 <span class='color_orange'>rearrange:38</span>:node*  ]
      where
      P0 = exists [_t$2]. _t$0|->{next:_t$1 <span class='color_orange'>update:56</span>, v:_t$2 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16</span>
    SPEC =
      --------------------------- ---------- ---------------------------
      PRE:
      <span class='color_blue'><span class='color_blue'>format|callee = _t$2453 <span class='color_orange'>formal</span>:char const *</span></span>
      POST 1 of 1:
      <span class='color_blue'><span class='color_red'>(-1  &lt;  _t$2454)</span>; <span class='color_red'>DANGL &lt; UNINIT &gt; (return|callee)</span> ;
      <span class='color_red'>return|callee = _t$2454 <span class='color_orange'>update:1114</span>:int</span></span>
      ----------------------------------------------------------------
    pre_check_pure_implication
    pi1:
      n$17 != 0; MEMma &lt; malloc:38 &gt;  <span class='color_orange'>{vpath: }</span>(n$1407); MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(n$1403); DANGL &lt; UNINIT &gt; (n$18)
    pi2:
      
    returns
    sub1: 
      
    sub2: 
      
    Current Implication
    SUB:
      
    <span class='color_blue'>t != 0; MEMma &lt; malloc:38 &gt;  <span class='color_orange'>{vpath: }</span>(n$1407); MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(x); DANGL &lt; UNINIT &gt; (n$18) ;
    x = n$1403 <span class='color_orange'>update:45</span>:node*; n = n$1404 <span class='color_orange'>update:58</span>:node*; t = n$17 <span class='color_orange'>update:53</span>:node*; #GB<src.c>$head = n$1407 <span class='color_orange'>update:38</span>:node*; i = 4 <span class='color_orange'>update:43</span>:int; format|callee = "%d\n" <span class='color_orange'>actual_precondition</span>:char const *; return = n$1410 <span class='color_orange'>initial</span>:int ;
    n$1407|->{next:n$1405 <span class='color_orange'>update:56</span>, v:n$1408 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16; n$1405|->{next:t <span class='color_orange'>update:56</span>, v:n$1406 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16; n|->{next:null <span class='color_orange'>update:46</span>, v:3 <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16; x|->{next:null <span class='color_orange'>update:46</span>, v:4 <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16; t|->{next:n$1409 <span class='color_orange'>update:56</span>, v:n$18 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16; lseg(n$1409,n,[],P0)
    [footprint
       @f$1 != 0 *
       #GB<src.c>$head = @f$0 <span class='color_orange'>rearrange:38</span>:node*  ]
    where
    P0 = exists [_t$2]. _t$0|->{next:_t$1 <span class='color_orange'>update:56</span>, v:_t$2 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16</span>
    |-
    <span class='color_blue'>format|callee = _t$2453 <span class='color_orange'>formal</span>:char const *</span>
    
      do_imply "%d\n" _t$2453
        Final Implication
        SUB:
          
        <span class='color_blue'>t != 0; MEMma &lt; malloc:38 &gt;  <span class='color_orange'>{vpath: }</span>(n$1407); MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(x); DANGL &lt; UNINIT &gt; (n$18) ;
        x = n$1403 <span class='color_orange'>update:45</span>:node*; n = n$1404 <span class='color_orange'>update:58</span>:node*; t = n$17 <span class='color_orange'>update:53</span>:node*; #GB<src.c>$head = n$1407 <span class='color_orange'>update:38</span>:node*; i = 4 <span class='color_orange'>update:43</span>:int; return = n$1410 <span class='color_orange'>initial</span>:int ;
        n$1407|->{next:n$1405 <span class='color_orange'>update:56</span>, v:n$1408 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16; n$1405|->{next:t <span class='color_orange'>update:56</span>, v:n$1406 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16; n|->{next:null <span class='color_orange'>update:46</span>, v:3 <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16; x|->{next:null <span class='color_orange'>update:46</span>, v:4 <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16; t|->{next:n$1409 <span class='color_orange'>update:56</span>, v:n$18 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16; lseg(n$1409,n,[],P0)
        [footprint
           @f$1 != 0 *
           #GB<src.c>$head = @f$0 <span class='color_orange'>rearrange:38</span>:node*  ]
        where
        P0 = exists [_t$2]. _t$0|->{next:_t$1 <span class='color_orange'>update:56</span>, v:_t$2 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16</span>
        [SUB: 
          _t$2453 = "%d\n"]
        |-
        <span class='color_blue'></span>
    Result of Abduction
      SUB:
        
      <span class='color_blue'>t != 0; MEMma &lt; malloc:38 &gt;  <span class='color_orange'>{vpath: }</span>(n$1407); MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(x); DANGL &lt; UNINIT &gt; (n$18) ;
      x = n$1403 <span class='color_orange'>update:45</span>:node*; n = n$1404 <span class='color_orange'>update:58</span>:node*; t = n$17 <span class='color_orange'>update:53</span>:node*; #GB<src.c>$head = n$1407 <span class='color_orange'>update:38</span>:node*; i = 4 <span class='color_orange'>update:43</span>:int; format|callee = "%d\n" <span class='color_orange'>actual_precondition</span>:char const *; return = n$1410 <span class='color_orange'>initial</span>:int ;
      n$1407|->{next:n$1405 <span class='color_orange'>update:56</span>, v:n$1408 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16; n$1405|->{next:t <span class='color_orange'>update:56</span>, v:n$1406 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16; n|->{next:null <span class='color_orange'>update:46</span>, v:3 <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16; x|->{next:null <span class='color_orange'>update:46</span>, v:4 <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16; t|->{next:n$1409 <span class='color_orange'>update:56</span>, v:n$18 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16; lseg(n$1409,n,[],P0)
      [footprint
         @f$1 != 0 *
         #GB<src.c>$head = @f$0 <span class='color_orange'>rearrange:38</span>:node*  ]
      where
      P0 = exists [_t$2]. _t$0|->{next:_t$1 <span class='color_orange'>update:56</span>, v:_t$2 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16</span>
      [SUB: 
        _t$2453 = "%d\n"]
      |-
      <span class='color_blue'>format|callee = "%d\n" <span class='color_orange'>formal</span>:char const *</span>
    returning TRUE
      New footprint:
      
      Frame fld:
      
      Missing fld:
      
      Instantiated frame:
      n$1407|->{next:n$1405 <span class='color_orange'>update:56</span>, v:n$1408 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16; n$1405|->{next:n$17 <span class='color_orange'>update:56</span>, v:n$1406 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16; n$1404|->{next:null <span class='color_orange'>update:46</span>, v:3 <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16; n$1403|->{next:null <span class='color_orange'>update:46</span>, v:4 <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16; n$17|->{next:n$1409 <span class='color_orange'>update:56</span>, v:n$18 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16; &amp;x|->n$1403 <span class='color_orange'>update:45</span>:node*; &amp;n|->n$1404 <span class='color_orange'>update:58</span>:node*; &amp;t|->n$17 <span class='color_orange'>update:53</span>:node*; &amp;#GB<src.c>$head|->n$1407 <span class='color_orange'>update:38</span>:node*; &amp;i|->4 <span class='color_orange'>update:43</span>:int; &amp;return|->n$1410 <span class='color_orange'>initial</span>:int; lseg(n$1409,n$1404,[],lam [_t$0,_t$1,]. exists [_t$2]. _t$0|->{next:_t$1 <span class='color_orange'>update:56</span>, v:_t$2 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16)
      Instantiated post:
      PROP 1 of 1:
      <span class='color_blue'><span class='color_red'>(-1  &lt;  _t$2454)</span>; <span class='color_red'>DANGL &lt; UNINIT &gt; (return|callee)</span> ;
      <span class='color_red'>return|callee = _t$2454 <span class='color_orange'>update:54</span>:int</span></span>
      
    ***** RESULTS FUNCTION CALL *******
    PROP 1 of 1:
    <span class='color_blue'><span class='color_red'>(-1  &lt;  n$19)</span>; <span class='color_blue'>t != 0</span>; <span class='color_blue'>MEMma &lt; malloc:38 &gt;  <span class='color_orange'>{vpath: }</span>(n$1407)</span>; <span class='color_blue'>MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(x)</span>; <span class='color_red'>DANGL &lt; UNINIT &gt; (n$19)</span>; <span class='color_blue'>DANGL &lt; UNINIT &gt; (n$18)</span> ;
    <span class='color_blue'>x = n$1403 <span class='color_orange'>update:45</span>:node*</span>; <span class='color_blue'>n = n$1404 <span class='color_orange'>update:58</span>:node*</span>; <span class='color_blue'>t = n$17 <span class='color_orange'>update:53</span>:node*</span>; <span class='color_blue'>#GB<src.c>$head = n$1407 <span class='color_orange'>update:38</span>:node*</span>; <span class='color_blue'>i = 4 <span class='color_orange'>update:43</span>:int</span>; <span class='color_blue'>return = n$1410 <span class='color_orange'>initial</span>:int</span> ;
    <span class='color_blue'>n$1407|->{next:n$1405 <span class='color_orange'>update:56</span>, v:n$1408 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16</span>; <span class='color_blue'>n$1405|->{next:t <span class='color_orange'>update:56</span>, v:n$1406 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16</span>; <span class='color_blue'>n|->{next:null <span class='color_orange'>update:46</span>, v:3 <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16</span>; <span class='color_blue'>x|->{next:null <span class='color_orange'>update:46</span>, v:4 <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16</span>; <span class='color_blue'>t|->{next:n$1409 <span class='color_orange'>update:56</span>, v:n$18 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16</span>; <span class='color_blue'>lseg(n$1409,n,[],P0)</span>
    [footprint
       <span class='color_blue'>@f$1 != 0</span> *
       <span class='color_blue'>#GB<src.c>$head = @f$0 <span class='color_orange'>rearrange:38</span>:node*</span>  ]
    where
    P0 = exists [_t$2]. <span class='color_blue'>_t$0|->{next:_t$1 <span class='color_orange'>update:56</span>, v:_t$2 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16</span></span>
    ***** END RESULTS FUNCTION CALL *******
    Instruction Returns
    PROP 1 of 1:
    <span class='color_blue'><span class='color_red'>(-1  &lt;  n$19)</span>; <span class='color_blue'>t != 0</span>; <span class='color_blue'>MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(x)</span>; <span class='color_blue'>MEMma &lt; malloc:38 &gt;  <span class='color_orange'>{vpath: }</span>(_t$1)</span>; <span class='color_red'>DANGL &lt; UNINIT &gt; (n$19)</span>; <span class='color_blue'>DANGL &lt; UNINIT &gt; (n$18)</span> ;
    <span class='color_blue'>x = _t$7 <span class='color_orange'>update:45</span>:node*</span>; <span class='color_blue'>n = _t$6 <span class='color_orange'>update:58</span>:node*</span>; <span class='color_blue'>t = n$17 <span class='color_orange'>update:53</span>:node*</span>; <span class='color_blue'>#GB<src.c>$head = _t$1 <span class='color_orange'>update:38</span>:node*</span>; <span class='color_blue'>i = 4 <span class='color_orange'>update:43</span>:int</span>; <span class='color_blue'>return = _t$0 <span class='color_orange'>initial</span>:int</span> ;
    <span class='color_blue'>x|->{next:null <span class='color_orange'>update:46</span>, v:4 <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16</span>; <span class='color_blue'>n|->{next:null <span class='color_orange'>update:46</span>, v:3 <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16</span>; <span class='color_blue'>_t$2|->{next:t <span class='color_orange'>update:56</span>, v:_t$4 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16</span>; <span class='color_blue'>_t$1|->{next:_t$2 <span class='color_orange'>update:56</span>, v:_t$3 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16</span>; <span class='color_blue'>t|->{next:_t$5 <span class='color_orange'>update:56</span>, v:n$18 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16</span>; <span class='color_blue'>lseg(_t$5,n,[],P0)</span>
    [footprint
       <span class='color_blue'>@f$1 != 0</span> *
       <span class='color_blue'>#GB<src.c>$head = @f$0 <span class='color_orange'>rearrange:38</span>:node*</span>  ]
    where
    P0 = exists [_t$2]. <span class='color_blue'>_t$0|->{next:_t$1 <span class='color_orange'>update:56</span>, v:_t$2 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16</span></span>
    
    Instruction <span class='color_green'>n$19=_fun_printf("%d\n":char const *,n$18:int) [line 54, column 7]</span>
    in vpath_find exp:n$1414
    vpath_find: found head : node*
    in vpath_find exp:n$1411
    vpath_find: found x : node*
    <span class='color_orange'>WARNING: likely use of variable-arguments function, or function prototype missing</span>
    actual parameters: 3
    formal parameters: 
    Found 1 specs for function printf
    START EXECUTING SPECS FOR printf from state
    <span class='color_blue'>n$18 = 3 ;
    t != 0; MEMma &lt; malloc:38 &gt;  <span class='color_orange'>{vpath: }</span>(n$1414); MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(x) ;
    x = n$1411 <span class='color_orange'>update:45</span>:node*; n = n$17 <span class='color_orange'>update:58</span>:node*; t = n$17 <span class='color_orange'>update:53</span>:node*; #GB<src.c>$head = n$1414 <span class='color_orange'>update:38</span>:node*; i = 4 <span class='color_orange'>update:43</span>:int; return = n$1416 <span class='color_orange'>initial</span>:int ;
    n$1414|->{next:n$1412 <span class='color_orange'>update:56</span>, v:n$1415 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16; n$1412|->{next:t <span class='color_orange'>update:56</span>, v:n$1413 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16; x|->{next:null <span class='color_orange'>update:46</span>, v:4 <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16; t|->{next:null <span class='color_orange'>update:46</span>, v:3 <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16
    [footprint
       t = @f$1; @f$2 != 0 *
       #GB<src.c>$head = @f$0 <span class='color_orange'>rearrange:38</span>:node*  ]</span>
    <span class='color_orange'>WARNING: more actual pars than formal pars in fun call (2 vs 1)</span>
    EXECUTING SPEC 1/1
    ACTUAL PRECONDITION =
      <span class='color_blue'>n$18 = 3 ;
      t != 0; MEMma &lt; malloc:38 &gt;  <span class='color_orange'>{vpath: }</span>(n$1414); MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(x) ;
      x = n$1411 <span class='color_orange'>update:45</span>:node*; n = n$17 <span class='color_orange'>update:58</span>:node*; t = n$17 <span class='color_orange'>update:53</span>:node*; #GB<src.c>$head = n$1414 <span class='color_orange'>update:38</span>:node*; i = 4 <span class='color_orange'>update:43</span>:int; format|callee = "%d\n" <span class='color_orange'>actual_precondition</span>:char const *; return = n$1416 <span class='color_orange'>initial</span>:int ;
      n$1414|->{next:n$1412 <span class='color_orange'>update:56</span>, v:n$1415 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16; n$1412|->{next:t <span class='color_orange'>update:56</span>, v:n$1413 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16; x|->{next:null <span class='color_orange'>update:46</span>, v:4 <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16; t|->{next:null <span class='color_orange'>update:46</span>, v:3 <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16
      [footprint
         t = @f$1; @f$2 != 0 *
         #GB<src.c>$head = @f$0 <span class='color_orange'>rearrange:38</span>:node*  ]</span>
    SPEC =
      --------------------------- ---------- ---------------------------
      PRE:
      <span class='color_blue'><span class='color_blue'>format|callee = _t$2463 <span class='color_orange'>formal</span>:char const *</span></span>
      POST 1 of 1:
      <span class='color_blue'><span class='color_red'>(-1  &lt;  _t$2464)</span>; <span class='color_red'>DANGL &lt; UNINIT &gt; (return|callee)</span> ;
      <span class='color_red'>return|callee = _t$2464 <span class='color_orange'>update:1114</span>:int</span></span>
      ----------------------------------------------------------------
    pre_check_pure_implication
    pi1:
      n$18 = 3; n$17 != 0; MEMma &lt; malloc:38 &gt;  <span class='color_orange'>{vpath: }</span>(n$1414); MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(n$1411)
    pi2:
      
    returns
    sub1: 
      n$18 = 3
    sub2: 
      n$18 = 3
    Current Implication
    SUB:
      n$18 = 3
    <span class='color_blue'>t != 0; MEMma &lt; malloc:38 &gt;  <span class='color_orange'>{vpath: }</span>(n$1414); MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(x); 3 = 3 ;
    x = n$1411 <span class='color_orange'>update:45</span>:node*; n = n$17 <span class='color_orange'>update:58</span>:node*; t = n$17 <span class='color_orange'>update:53</span>:node*; #GB<src.c>$head = n$1414 <span class='color_orange'>update:38</span>:node*; i = 4 <span class='color_orange'>update:43</span>:int; format|callee = "%d\n" <span class='color_orange'>actual_precondition</span>:char const *; return = n$1416 <span class='color_orange'>initial</span>:int ;
    n$1414|->{next:n$1412 <span class='color_orange'>update:56</span>, v:n$1415 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16; n$1412|->{next:t <span class='color_orange'>update:56</span>, v:n$1413 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16; x|->{next:null <span class='color_orange'>update:46</span>, v:4 <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16; t|->{next:null <span class='color_orange'>update:46</span>, v:3 <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16
    [footprint
       t = @f$1; @f$2 != 0 *
       #GB<src.c>$head = @f$0 <span class='color_orange'>rearrange:38</span>:node*  ]</span>
    [SUB: 
      n$18 = 3]
    |-
    <span class='color_blue'>format|callee = _t$2463 <span class='color_orange'>formal</span>:char const *</span>
    
      do_imply "%d\n" _t$2463
        Final Implication
        SUB:
          n$18 = 3
        <span class='color_blue'>t != 0; MEMma &lt; malloc:38 &gt;  <span class='color_orange'>{vpath: }</span>(n$1414); MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(x); 3 = 3 ;
        x = n$1411 <span class='color_orange'>update:45</span>:node*; n = n$17 <span class='color_orange'>update:58</span>:node*; t = n$17 <span class='color_orange'>update:53</span>:node*; #GB<src.c>$head = n$1414 <span class='color_orange'>update:38</span>:node*; i = 4 <span class='color_orange'>update:43</span>:int; return = n$1416 <span class='color_orange'>initial</span>:int ;
        n$1414|->{next:n$1412 <span class='color_orange'>update:56</span>, v:n$1415 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16; n$1412|->{next:t <span class='color_orange'>update:56</span>, v:n$1413 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16; x|->{next:null <span class='color_orange'>update:46</span>, v:4 <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16; t|->{next:null <span class='color_orange'>update:46</span>, v:3 <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16
        [footprint
           t = @f$1; @f$2 != 0 *
           #GB<src.c>$head = @f$0 <span class='color_orange'>rearrange:38</span>:node*  ]</span>
        [SUB: 
          n$18 = 3; _t$2463 = "%d\n"]
        |-
        <span class='color_blue'></span>
    Result of Abduction
      SUB:
        n$18 = 3
      <span class='color_blue'>t != 0; MEMma &lt; malloc:38 &gt;  <span class='color_orange'>{vpath: }</span>(n$1414); MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(x); 3 = 3 ;
      x = n$1411 <span class='color_orange'>update:45</span>:node*; n = n$17 <span class='color_orange'>update:58</span>:node*; t = n$17 <span class='color_orange'>update:53</span>:node*; #GB<src.c>$head = n$1414 <span class='color_orange'>update:38</span>:node*; i = 4 <span class='color_orange'>update:43</span>:int; format|callee = "%d\n" <span class='color_orange'>actual_precondition</span>:char const *; return = n$1416 <span class='color_orange'>initial</span>:int ;
      n$1414|->{next:n$1412 <span class='color_orange'>update:56</span>, v:n$1415 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16; n$1412|->{next:t <span class='color_orange'>update:56</span>, v:n$1413 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16; x|->{next:null <span class='color_orange'>update:46</span>, v:4 <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16; t|->{next:null <span class='color_orange'>update:46</span>, v:3 <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16
      [footprint
         t = @f$1; @f$2 != 0 *
         #GB<src.c>$head = @f$0 <span class='color_orange'>rearrange:38</span>:node*  ]</span>
      [SUB: 
        n$18 = 3; _t$2463 = "%d\n"]
      |-
      <span class='color_blue'>format|callee = "%d\n" <span class='color_orange'>formal</span>:char const *</span>
    returning TRUE
      New footprint:
      
      Frame fld:
      
      Missing fld:
      
      Instantiated frame:
      n$1414|->{next:n$1412 <span class='color_orange'>update:56</span>, v:n$1415 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16; n$1412|->{next:n$17 <span class='color_orange'>update:56</span>, v:n$1413 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16; n$1411|->{next:null <span class='color_orange'>update:46</span>, v:4 <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16; n$17|->{next:null <span class='color_orange'>update:46</span>, v:3 <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16; &amp;x|->n$1411 <span class='color_orange'>update:45</span>:node*; &amp;n|->n$17 <span class='color_orange'>update:58</span>:node*; &amp;t|->n$17 <span class='color_orange'>update:53</span>:node*; &amp;#GB<src.c>$head|->n$1414 <span class='color_orange'>update:38</span>:node*; &amp;i|->4 <span class='color_orange'>update:43</span>:int; &amp;return|->n$1416 <span class='color_orange'>initial</span>:int
      Instantiated post:
      PROP 1 of 1:
      <span class='color_blue'><span class='color_red'>(-1  &lt;  _t$2464)</span>; <span class='color_red'>DANGL &lt; UNINIT &gt; (return|callee)</span> ;
      <span class='color_red'>return|callee = _t$2464 <span class='color_orange'>update:54</span>:int</span></span>
      
    ***** RESULTS FUNCTION CALL *******
    PROP 1 of 1:
    <span class='color_blue'><span class='color_blue'>n$18 = 3</span> ;
    <span class='color_red'>(-1  &lt;  n$19)</span>; <span class='color_blue'>t != 0</span>; <span class='color_blue'>MEMma &lt; malloc:38 &gt;  <span class='color_orange'>{vpath: }</span>(n$1414)</span>; <span class='color_blue'>MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(x)</span>; <span class='color_red'>DANGL &lt; UNINIT &gt; (n$19)</span> ;
    <span class='color_blue'>x = n$1411 <span class='color_orange'>update:45</span>:node*</span>; <span class='color_blue'>n = n$17 <span class='color_orange'>update:58</span>:node*</span>; <span class='color_blue'>t = n$17 <span class='color_orange'>update:53</span>:node*</span>; <span class='color_blue'>#GB<src.c>$head = n$1414 <span class='color_orange'>update:38</span>:node*</span>; <span class='color_blue'>i = 4 <span class='color_orange'>update:43</span>:int</span>; <span class='color_blue'>return = n$1416 <span class='color_orange'>initial</span>:int</span> ;
    <span class='color_blue'>n$1414|->{next:n$1412 <span class='color_orange'>update:56</span>, v:n$1415 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16</span>; <span class='color_blue'>n$1412|->{next:t <span class='color_orange'>update:56</span>, v:n$1413 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16</span>; <span class='color_blue'>x|->{next:null <span class='color_orange'>update:46</span>, v:4 <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16</span>; <span class='color_blue'>t|->{next:null <span class='color_orange'>update:46</span>, v:3 <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16</span>
    [footprint
       <span class='color_blue'>t = @f$1</span>; <span class='color_blue'>@f$2 != 0</span> *
       <span class='color_blue'>#GB<src.c>$head = @f$0 <span class='color_orange'>rearrange:38</span>:node*</span>  ]</span>
    ***** END RESULTS FUNCTION CALL *******
    Instruction Returns
    PROP 1 of 1:
    <span class='color_blue'><span class='color_blue'>n$18 = 3</span> ;
    <span class='color_red'>(-1  &lt;  n$19)</span>; <span class='color_blue'>t != 0</span>; <span class='color_blue'>MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(x)</span>; <span class='color_blue'>MEMma &lt; malloc:38 &gt;  <span class='color_orange'>{vpath: }</span>(_t$1)</span>; <span class='color_red'>DANGL &lt; UNINIT &gt; (n$19)</span> ;
    <span class='color_blue'>x = _t$5 <span class='color_orange'>update:45</span>:node*</span>; <span class='color_blue'>n = n$17 <span class='color_orange'>update:58</span>:node*</span>; <span class='color_blue'>t = n$17 <span class='color_orange'>update:53</span>:node*</span>; <span class='color_blue'>#GB<src.c>$head = _t$1 <span class='color_orange'>update:38</span>:node*</span>; <span class='color_blue'>i = 4 <span class='color_orange'>update:43</span>:int</span>; <span class='color_blue'>return = _t$0 <span class='color_orange'>initial</span>:int</span> ;
    <span class='color_blue'>x|->{next:null <span class='color_orange'>update:46</span>, v:4 <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16</span>; <span class='color_blue'>_t$2|->{next:t <span class='color_orange'>update:56</span>, v:_t$4 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16</span>; <span class='color_blue'>_t$1|->{next:_t$2 <span class='color_orange'>update:56</span>, v:_t$3 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16</span>; <span class='color_blue'>t|->{next:null <span class='color_orange'>update:46</span>, v:3 <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16</span>
    [footprint
       <span class='color_blue'>t = @f$1</span>; <span class='color_blue'>@f$2 != 0</span> *
       <span class='color_blue'>#GB<src.c>$head = @f$0 <span class='color_orange'>rearrange:38</span>:node*</span>  ]</span>
    
    Instruction <span class='color_green'>REMOVE_TEMPS(n$17,n$18,n$19); [line 54, column 7]</span>
    in vpath_find exp:_t$7
    vpath_find: found x : node*
    in vpath_find exp:_t$1
    vpath_find: found head : node*
    Instruction Returns
    PROP 1 of 1:
    <span class='color_blue'><span class='color_red'>(-1  &lt;  _t$10)</span>; <span class='color_red'>t != 0</span>; <span class='color_red'>MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(x)</span>; <span class='color_blue'>MEMma &lt; malloc:38 &gt;  <span class='color_orange'>{vpath: }</span>(_t$1)</span>; <span class='color_red'>DANGL &lt; UNINIT &gt; (_t$10)</span>; <span class='color_blue'>DANGL &lt; UNINIT &gt; (_t$7)</span> ;
    <span class='color_blue'>x = <span class='color_red'>_t$9 <span class='color_orange'>update:45</span></span>:node*</span>; <span class='color_blue'>n = <span class='color_red'>_t$8 <span class='color_orange'>update:58</span></span>:node*</span>; <span class='color_blue'>t = <span class='color_red'>_t$4 <span class='color_orange'>update:53</span></span>:node*</span>; <span class='color_blue'>#GB<src.c>$head = _t$1 <span class='color_orange'>update:38</span>:node*</span>; <span class='color_blue'>i = 4 <span class='color_orange'>update:43</span>:int</span>; <span class='color_blue'>return = _t$0 <span class='color_orange'>initial</span>:int</span> ;
    <span class='color_red'>x|->{next:null <span class='color_orange'>update:46</span>, v:4 <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16</span>; <span class='color_red'>n|->{next:null <span class='color_orange'>update:46</span>, v:3 <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16</span>; <span class='color_red'>t|->{next:_t$6 <span class='color_orange'>update:56</span>, v:_t$7 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16</span>; <span class='color_blue'>_t$2|->{next:<span class='color_red'>t <span class='color_orange'>update:56</span></span>, v:<span class='color_red'>_t$5 <span class='color_orange'>alloc</span></span>} <span class='color_orange'>alloc</span>:node16</span>; <span class='color_blue'>_t$1|->{next:_t$2 <span class='color_orange'>update:56</span>, v:_t$3 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16</span>; <span class='color_blue'>lseg(_t$6,n,[],P0)</span>
    [footprint
       <span class='color_blue'>@f$1 != 0</span> *
       <span class='color_blue'>#GB<src.c>$head = @f$0 <span class='color_orange'>rearrange:38</span>:node*</span>  ]
    where
    P0 = exists [_t$2]. <span class='color_blue'>_t$0|->{next:_t$1 <span class='color_orange'>update:56</span>, v:_t$2 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16</span></span>
    
    Instruction <span class='color_green'>REMOVE_TEMPS(n$17,n$18,n$19); [line 54, column 7]</span>
    in vpath_find exp:_t$5
    vpath_find: found x : node*
    in vpath_find exp:_t$1
    vpath_find: found head : node*
    Instruction Returns
    PROP 1 of 1:
    <span class='color_blue'><span class='color_red'>(-1  &lt;  _t$7)</span>; <span class='color_red'>t != 0</span>; <span class='color_red'>MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(x)</span>; <span class='color_blue'>MEMma &lt; malloc:38 &gt;  <span class='color_orange'>{vpath: }</span>(_t$1)</span>; <span class='color_red'>DANGL &lt; UNINIT &gt; (_t$7)</span> ;
    <span class='color_blue'>x = <span class='color_red'>_t$6 <span class='color_orange'>update:45</span></span>:node*</span>; <span class='color_blue'>n = <span class='color_red'>_t$4 <span class='color_orange'>update:58</span></span>:node*</span>; <span class='color_blue'>t = <span class='color_red'>_t$4 <span class='color_orange'>update:53</span></span>:node*</span>; <span class='color_blue'>#GB<src.c>$head = _t$1 <span class='color_orange'>update:38</span>:node*</span>; <span class='color_blue'>i = 4 <span class='color_orange'>update:43</span>:int</span>; <span class='color_blue'>return = _t$0 <span class='color_orange'>initial</span>:int</span> ;
    <span class='color_red'>x|->{next:null <span class='color_orange'>update:46</span>, v:4 <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16</span>; <span class='color_red'>t|->{next:null <span class='color_orange'>update:46</span>, v:3 <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16</span>; <span class='color_blue'>_t$2|->{next:<span class='color_red'>t <span class='color_orange'>update:56</span></span>, v:<span class='color_red'>_t$5 <span class='color_orange'>alloc</span></span>} <span class='color_orange'>alloc</span>:node16</span>; <span class='color_blue'>_t$1|->{next:_t$2 <span class='color_orange'>update:56</span>, v:_t$3 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16</span>
    [footprint
       <span class='color_blue'>@f$2 = @f$1</span>; <span class='color_red'>@f$3 != 0</span> *
       <span class='color_blue'>#GB<src.c>$head = @f$0 <span class='color_orange'>rearrange:38</span>:node*</span>  ]</span>
    
    Instruction <span class='color_green'>APPLY_ABSTRACTION; [line 54, column 7]</span>
    in vpath_find exp:_t$9
    vpath_find: found x : node*
    in vpath_find exp:_t$1
    vpath_find: found head : node*
    <span class='color_blue'>t != 0; MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(x); MEMma &lt; malloc:38 &gt;  <span class='color_orange'>{vpath: }</span>(_t$1) ;
    x = _t$4 <span class='color_orange'>update:45</span>:node*; n = _t$3 <span class='color_orange'>update:58</span>:node*; t = _t$2 <span class='color_orange'>update:53</span>:node*; #GB<src.c>$head = _t$1 <span class='color_orange'>update:38</span>:node*; i = 4 <span class='color_orange'>update:43</span>:int; return = _t$0 <span class='color_orange'>initial</span>:int ;
    x|->{next:null <span class='color_orange'>update:46</span>, v:4 <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16; n|->{next:null <span class='color_orange'>update:46</span>, v:3 <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16; lsegne(t,n,[],P0); lsegne(_t$1,t,[],P0)
    [footprint
       #GB<src.c>$head = @f$0 <span class='color_orange'>rearrange:38</span>:node*  ]
    where
    P0 = exists [_t$2]. _t$0|->{next:_t$1 <span class='color_orange'>update:56</span>, v:_t$2 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16</span>
    Instruction Returns
    PROP 1 of 1:
    <span class='color_blue'><span class='color_red'>t != 0</span>; <span class='color_blue'>MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(x)</span>; <span class='color_blue'>MEMma &lt; malloc:38 &gt;  <span class='color_orange'>{vpath: }</span>(_t$1)</span> ;
    <span class='color_blue'>x = <span class='color_red'>_t$4 <span class='color_orange'>update:45</span></span>:node*</span>; <span class='color_blue'>n = <span class='color_red'>_t$3 <span class='color_orange'>update:58</span></span>:node*</span>; <span class='color_blue'>t = <span class='color_red'>_t$2 <span class='color_orange'>update:53</span></span>:node*</span>; <span class='color_blue'>#GB<src.c>$head = _t$1 <span class='color_orange'>update:38</span>:node*</span>; <span class='color_blue'>i = 4 <span class='color_orange'>update:43</span>:int</span>; <span class='color_blue'>return = _t$0 <span class='color_orange'>initial</span>:int</span> ;
    <span class='color_blue'>x|->{next:<span class='color_red'>null <span class='color_orange'>update:46</span></span>, v:<span class='color_red'>4 <span class='color_orange'>update:47</span></span>} <span class='color_orange'>alloc</span>:node16</span>; <span class='color_red'>n|->{next:null <span class='color_orange'>update:46</span>, v:3 <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16</span>; <span class='color_blue'>lsegne(t,n,[],P0)</span>; <span class='color_blue'>lsegne(_t$1,t,[],P0)</span>
    [footprint
       <span class='color_blue'>#GB<src.c>$head = @f$0 <span class='color_orange'>rearrange:38</span>:node*</span>  ]
    where
    P0 = exists [_t$2]. <span class='color_blue'>_t$0|->{next:_t$1 <span class='color_orange'>update:56</span>, v:_t$2 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16</span></span>
    
    Instruction <span class='color_green'>APPLY_ABSTRACTION; [line 54, column 7]</span>
    in vpath_find exp:_t$6
    vpath_find: found x : node*
    in vpath_find exp:_t$1
    vpath_find: found head : node*
    <span class='color_blue'>t != 0; MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(x); MEMma &lt; malloc:38 &gt;  <span class='color_orange'>{vpath: }</span>(_t$1) ;
    x = _t$3 <span class='color_orange'>update:45</span>:node*; n = _t$2 <span class='color_orange'>update:58</span>:node*; t = _t$2 <span class='color_orange'>update:53</span>:node*; #GB<src.c>$head = _t$1 <span class='color_orange'>update:38</span>:node*; i = 4 <span class='color_orange'>update:43</span>:int; return = _t$0 <span class='color_orange'>initial</span>:int ;
    x|->{next:null <span class='color_orange'>update:46</span>, v:4 <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16; t|->{next:null <span class='color_orange'>update:46</span>, v:3 <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16; lsegne(_t$1,t,[],P0)
    [footprint
       #GB<src.c>$head = @f$0 <span class='color_orange'>rearrange:38</span>:node*  ]
    where
    P0 = exists [_t$2]. _t$0|->{next:_t$1 <span class='color_orange'>update:56</span>, v:_t$2 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16</span>
    Instruction Returns
    PROP 1 of 1:
    <span class='color_blue'><span class='color_red'>t != 0</span>; <span class='color_red'>MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(x)</span>; <span class='color_blue'>MEMma &lt; malloc:38 &gt;  <span class='color_orange'>{vpath: }</span>(_t$1)</span> ;
    <span class='color_blue'>x = <span class='color_red'>_t$3 <span class='color_orange'>update:45</span></span>:node*</span>; <span class='color_blue'>n = <span class='color_red'>_t$2 <span class='color_orange'>update:58</span></span>:node*</span>; <span class='color_blue'>t = <span class='color_red'>_t$2 <span class='color_orange'>update:53</span></span>:node*</span>; <span class='color_blue'>#GB<src.c>$head = _t$1 <span class='color_orange'>update:38</span>:node*</span>; <span class='color_blue'>i = 4 <span class='color_orange'>update:43</span>:int</span>; <span class='color_blue'>return = _t$0 <span class='color_orange'>initial</span>:int</span> ;
    <span class='color_red'>x|->{next:null <span class='color_orange'>update:46</span>, v:4 <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16</span>; <span class='color_blue'>t|->{next:<span class='color_red'>null <span class='color_orange'>update:46</span></span>, v:<span class='color_red'>3 <span class='color_orange'>update:47</span></span>} <span class='color_orange'>alloc</span>:node16</span>; <span class='color_blue'>lsegne(_t$1,t,[],P0)</span>
    [footprint
       <span class='color_blue'>#GB<src.c>$head = @f$0 <span class='color_orange'>rearrange:38</span>:node*</span>  ]
    where
    P0 = exists [_t$2]. <span class='color_blue'>_t$0|->{next:_t$1 <span class='color_orange'>update:56</span>, v:_t$2 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16</span></span>
    
    .... After Symbolic Execution ....
    PROP 1 of 2:
    <span class='color_blue'><span class='color_red'>t != 0</span>; <span class='color_blue'>MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(x)</span>; <span class='color_blue'>MEMma &lt; malloc:38 &gt;  <span class='color_orange'>{vpath: }</span>(_t$1)</span> ;
    <span class='color_blue'>x = <span class='color_red'>_t$4 <span class='color_orange'>update:45</span></span>:node*</span>; <span class='color_blue'>n = <span class='color_red'>_t$3 <span class='color_orange'>update:58</span></span>:node*</span>; <span class='color_blue'>t = <span class='color_red'>_t$2 <span class='color_orange'>update:53</span></span>:node*</span>; <span class='color_blue'>#GB<src.c>$head = _t$1 <span class='color_orange'>update:38</span>:node*</span>; <span class='color_blue'>i = 4 <span class='color_orange'>update:43</span>:int</span>; <span class='color_blue'>return = _t$0 <span class='color_orange'>initial</span>:int</span> ;
    <span class='color_blue'>x|->{next:null <span class='color_orange'>update:46</span>, v:4 <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16</span>; <span class='color_red'>n|->{next:null <span class='color_orange'>update:46</span>, v:3 <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16</span>; <span class='color_blue'>lsegne(t,n,[],P0)</span>; <span class='color_blue'>lsegne(_t$1,t,[],P0)</span>
    [footprint
       <span class='color_blue'>#GB<src.c>$head = @f$0 <span class='color_orange'>rearrange:38</span>:node*</span>  ]
    where
    P0 = exists [_t$2]. <span class='color_blue'>_t$0|->{next:_t$1 <span class='color_orange'>update:56</span>, v:_t$2 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16</span></span>
    PROP 2 of 2:
    <span class='color_blue'><span class='color_red'>t != 0</span>; <span class='color_red'>MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(x)</span>; <span class='color_blue'>MEMma &lt; malloc:38 &gt;  <span class='color_orange'>{vpath: }</span>(_t$1)</span> ;
    <span class='color_blue'>x = <span class='color_red'>_t$3 <span class='color_orange'>update:45</span></span>:node*</span>; <span class='color_blue'>n = <span class='color_red'>_t$2 <span class='color_orange'>update:58</span></span>:node*</span>; <span class='color_blue'>t = <span class='color_red'>_t$2 <span class='color_orange'>update:53</span></span>:node*</span>; <span class='color_blue'>#GB<src.c>$head = _t$1 <span class='color_orange'>update:38</span>:node*</span>; <span class='color_blue'>i = 4 <span class='color_orange'>update:43</span>:int</span>; <span class='color_blue'>return = _t$0 <span class='color_orange'>initial</span>:int</span> ;
    <span class='color_red'>x|->{next:null <span class='color_orange'>update:46</span>, v:4 <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16</span>; <span class='color_blue'>t|->{next:<span class='color_red'>null <span class='color_orange'>update:46</span></span>, v:<span class='color_red'>3 <span class='color_orange'>update:47</span></span>} <span class='color_orange'>alloc</span>:node16</span>; <span class='color_blue'>lsegne(_t$1,t,[],P0)</span>
    [footprint
       <span class='color_blue'>#GB<src.c>$head = @f$0 <span class='color_orange'>rearrange:38</span>:node*</span>  ]
    where
    P0 = exists [_t$2]. <span class='color_blue'>_t$0|->{next:_t$1 <span class='color_orange'>update:56</span>, v:_t$2 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16</span></span>
    
    
    
  </LISTING></span><hr width="100%">
<a name="session353" href="./../nodes/main.fad58de7366495db4650cfefac2fcd61_node25.html#session353">node25#session353</a>(<a href="./../../src.c.b9996786c0d0c7ca7785f2f6d38e80de.html#LINE54">54</a>) interproc<LISTING><span class='color_black'>**** [FP:Pending] main Node: 25, Procedure: main, Session: 353, Todo: 2 ****
  PROP 1 of 2:
  <span class='color_blue'><span class='color_red'>(@f$0  &lt;=  8)</span>; <span class='color_red'>t != 0</span>; <span class='color_red'>_t$2 != 0</span>; <span class='color_red'>MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(x)</span>; <span class='color_red'>MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(_t$5)</span>; <span class='color_red'>MEMma &lt; malloc:38 &gt;  <span class='color_orange'>{vpath: }</span>(_t$1)</span> ;
  <span class='color_red'>x = _t$6 <span class='color_orange'>update:45</span>:node*</span>; <span class='color_red'>n = null <span class='color_orange'>update:40</span>:node*</span>; <span class='color_red'>t = _t$3 <span class='color_orange'>update:53</span>:node*</span>; <span class='color_red'>#GB<src.c>$head = _t$1 <span class='color_orange'>update:38</span>:node*</span>; <span class='color_red'>i = (@f$0 + 1) <span class='color_orange'>update:43</span>:int</span>; <span class='color_red'>return = _t$0 <span class='color_orange'>initial</span>:int</span> ;
  <span class='color_red'>x|->{next:null <span class='color_orange'>update:46</span>, v:(@f$0 + 1) <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16</span>; <span class='color_red'>_t$5|->{next:null <span class='color_orange'>update:46</span>, v:@f$0 <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16</span>; <span class='color_red'>_t$2|->{next:t <span class='color_orange'>update:56</span>, v:_t$4 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16</span>; <span class='color_red'>lsegne(_t$1,_t$2,[],P0)</span>; <span class='color_red'>lseg(t,_t$5,[],P0)</span>
  [footprint
     <span class='color_red'>@f$2 != 0</span> *
     <span class='color_red'>#GB<src.c>$head = @f$1 <span class='color_orange'>rearrange:38</span>:node*</span>  ]
  where
  P0 = exists [_t$2]. <span class='color_blue'>_t$0|->{next:_t$1 <span class='color_orange'>update:56</span>, v:_t$2 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16</span></span>
  PROP 2 of 2:
  <span class='color_blue'><span class='color_red'>t != 0</span>; <span class='color_red'>MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(x)</span>; <span class='color_red'>MEMma &lt; malloc:38 &gt;  <span class='color_orange'>{vpath: }</span>(_t$1)</span> ;
  <span class='color_red'>x = _t$6 <span class='color_orange'>update:45</span>:node*</span>; <span class='color_red'>n = _t$5 <span class='color_orange'>update:58</span>:node*</span>; <span class='color_red'>t = _t$3 <span class='color_orange'>update:53</span>:node*</span>; <span class='color_red'>#GB<src.c>$head = _t$1 <span class='color_orange'>update:38</span>:node*</span>; <span class='color_red'>i = 4 <span class='color_orange'>update:43</span>:int</span>; <span class='color_red'>return = _t$0 <span class='color_orange'>initial</span>:int</span> ;
  <span class='color_red'>x|->{next:null <span class='color_orange'>update:46</span>, v:4 <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16</span>; <span class='color_red'>n|->{next:null <span class='color_orange'>update:46</span>, v:3 <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16</span>; <span class='color_red'>_t$2|->{next:t <span class='color_orange'>update:56</span>, v:_t$4 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16</span>; <span class='color_red'>lsegne(_t$1,_t$2,[],P0)</span>; <span class='color_red'>lseg(t,n,[],P0)</span>
  [footprint
     <span class='color_red'>@f$1 != 0</span> *
     <span class='color_red'>#GB<src.c>$head = @f$0 <span class='color_orange'>rearrange:38</span>:node*</span>  ]
  where
  P0 = exists [_t$2]. <span class='color_blue'>_t$0|->{next:_t$1 <span class='color_orange'>update:56</span>, v:_t$2 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16</span></span>
  .... Instructions: .... 
  <span class='color_green'>n$17=*&amp;t:node* [line 54, column 21];
  n$18=*n$17.v:int [line 54, column 21];
  n$19=_fun_printf("%d\n":char const *,n$18:int) [line 54, column 7];
  REMOVE_TEMPS(n$17,n$18,n$19); [line 54, column 7];
  APPLY_ABSTRACTION; [line 54, column 7];
  </span>
  
  Processing prop 1/2
    Instruction <span class='color_green'>n$17=*&amp;t:node* [line 54, column 21]</span>
    in vpath_find exp:n$1540
    vpath_find: found head : node*
    in vpath_find exp:n$1536
    vpath_find: cannot find n$1536
    in vpath_find exp:n$1535
    vpath_find: found x : node*
    .... Rearrangement Start ....
    Exp: &amp;t
    Prop: 
    <span class='color_blue'>(@f$0  &lt;=  8); t != 0; n$1537 != 0; MEMma &lt; malloc:38 &gt;  <span class='color_orange'>{vpath: }</span>(n$1540); MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(n$1536); MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(x) ;
    x = n$1535 <span class='color_orange'>update:45</span>:node*; n = null <span class='color_orange'>update:40</span>:node*; t = n$1538 <span class='color_orange'>update:53</span>:node*; #GB<src.c>$head = n$1540 <span class='color_orange'>update:38</span>:node*; i = (@f$0 + 1) <span class='color_orange'>update:43</span>:int; return = n$1541 <span class='color_orange'>initial</span>:int ;
    n$1537|->{next:t <span class='color_orange'>update:56</span>, v:n$1539 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16; n$1536|->{next:null <span class='color_orange'>update:46</span>, v:@f$0 <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16; x|->{next:null <span class='color_orange'>update:46</span>, v:(@f$0 + 1) <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16; lsegne(n$1540,n$1537,[],P0); lseg(t,n$1536,[],P0)
    [footprint
       @f$2 != 0 *
       #GB<src.c>$head = @f$1 <span class='color_orange'>rearrange:38</span>:node*  ]
    where
    P0 = exists [_t$2]. _t$0|->{next:_t$1 <span class='color_orange'>update:56</span>, v:_t$2 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16</span>
    
    in prop_iter_extend_ptsto lexp: &amp;t
    prop before:
    <span class='color_blue'>(@f$0  &lt;=  8); t != 0; n$1537 != 0; MEMma &lt; malloc:38 &gt;  <span class='color_orange'>{vpath: }</span>(n$1540); MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(n$1536); MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(x) ;
    x = n$1535 <span class='color_orange'>update:45</span>:node*; n = null <span class='color_orange'>update:40</span>:node*; t = n$1538 <span class='color_orange'>update:53</span>:node*; #GB<src.c>$head = n$1540 <span class='color_orange'>update:38</span>:node*; i = (@f$0 + 1) <span class='color_orange'>update:43</span>:int; return = n$1541 <span class='color_orange'>initial</span>:int ;
    n$1537|->{next:t <span class='color_orange'>update:56</span>, v:n$1539 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16; n$1536|->{next:null <span class='color_orange'>update:46</span>, v:@f$0 <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16; x|->{next:null <span class='color_orange'>update:46</span>, v:(@f$0 + 1) <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16; lsegne(n$1540,n$1537,[],P0); lseg(t,n$1536,[],P0)
    [footprint
       @f$2 != 0 *
       #GB<src.c>$head = @f$1 <span class='color_orange'>rearrange:38</span>:node*  ]
    where
    P0 = exists [_t$2]. _t$0|->{next:_t$1 <span class='color_orange'>update:56</span>, v:_t$2 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16</span>
    
    
    prop list after:
    PROP 1 of 1:
    <span class='color_blue'><span class='color_blue'>(@f$0  &lt;=  8)</span>; <span class='color_blue'>t != 0</span>; <span class='color_blue'>n$1537 != 0</span>; <span class='color_blue'>MEMma &lt; malloc:38 &gt;  <span class='color_orange'>{vpath: }</span>(n$1540)</span>; <span class='color_blue'>MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(n$1536)</span>; <span class='color_blue'>MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(x)</span> ;
    <span class='color_blue'>x = n$1535 <span class='color_orange'>update:45</span>:node*</span>; <span class='color_blue'>n = null <span class='color_orange'>update:40</span>:node*</span>; <span class='color_blue'>t = n$1538 <span class='color_orange'>update:53</span>:node*</span>; <span class='color_blue'>#GB<src.c>$head = n$1540 <span class='color_orange'>update:38</span>:node*</span>; <span class='color_blue'>i = (@f$0 + 1) <span class='color_orange'>update:43</span>:int</span>; <span class='color_blue'>return = n$1541 <span class='color_orange'>initial</span>:int</span> ;
    <span class='color_blue'>n$1537|->{next:t <span class='color_orange'>update:56</span>, v:n$1539 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16</span>; <span class='color_blue'>n$1536|->{next:null <span class='color_orange'>update:46</span>, v:@f$0 <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16</span>; <span class='color_blue'>x|->{next:null <span class='color_orange'>update:46</span>, v:(@f$0 + 1) <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16</span>; <span class='color_blue'>lsegne(n$1540,n$1537,[],P0)</span>; <span class='color_blue'>lseg(t,n$1536,[],P0)</span>
    [footprint
       <span class='color_blue'>@f$2 != 0</span> *
       <span class='color_blue'>#GB<src.c>$head = @f$1 <span class='color_orange'>rearrange:38</span>:node*</span>  ]
    where
    P0 = exists [_t$2]. <span class='color_blue'>_t$0|->{next:_t$1 <span class='color_orange'>update:56</span>, v:_t$2 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16</span></span>
    
    
    
    Instruction Returns
    PROP 1 of 1:
    <span class='color_blue'><span class='color_blue'>(@f$0  &lt;=  8)</span>; <span class='color_blue'>_t$2 != 0</span>; <span class='color_red'>t != 0</span>; <span class='color_blue'>MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(x)</span>; <span class='color_red'>MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(_t$4)</span>; <span class='color_blue'>MEMma &lt; malloc:38 &gt;  <span class='color_orange'>{vpath: }</span>(_t$1)</span> ;
    <span class='color_blue'>x = <span class='color_red'>_t$5 <span class='color_orange'>update:45</span></span>:node*</span>; <span class='color_blue'>n = null <span class='color_orange'>update:40</span>:node*</span>; <span class='color_blue'>t = <span class='color_red'>n$17 <span class='color_orange'>update:53</span></span>:node*</span>; <span class='color_blue'>#GB<src.c>$head = _t$1 <span class='color_orange'>update:38</span>:node*</span>; <span class='color_blue'>i = (@f$0 + 1) <span class='color_orange'>update:43</span>:int</span>; <span class='color_blue'>return = _t$0 <span class='color_orange'>initial</span>:int</span> ;
    <span class='color_blue'>x|->{next:null <span class='color_orange'>update:46</span>, v:<span class='color_red'>(@f$0 + 1) <span class='color_orange'>update:47</span></span>} <span class='color_orange'>alloc</span>:node16</span>; <span class='color_red'>_t$4|->{next:null <span class='color_orange'>update:46</span>, v:@f$0 <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16</span>; <span class='color_blue'>_t$2|->{next:<span class='color_red'>t <span class='color_orange'>update:56</span></span>, v:<span class='color_red'>_t$3 <span class='color_orange'>alloc</span></span>} <span class='color_orange'>alloc</span>:node16</span>; <span class='color_blue'>lsegne(_t$1,_t$2,[],P0)</span>; <span class='color_red'>lseg(t,_t$4,[],P0)</span>
    [footprint
       <span class='color_blue'>@f$2 != 0</span> *
       <span class='color_blue'>#GB<src.c>$head = @f$1 <span class='color_orange'>rearrange:38</span>:node*</span>  ]
    where
    P0 = exists [_t$2]. <span class='color_blue'>_t$0|->{next:_t$1 <span class='color_orange'>update:56</span>, v:_t$2 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16</span></span>
    
    Instruction <span class='color_green'>n$18=*n$17.v:int [line 54, column 21]</span>
    in vpath_find exp:n$1546
    vpath_find: found head : node*
    in vpath_find exp:n$1543
    vpath_find: cannot find n$1543
    in vpath_find exp:n$1542
    vpath_find: found x : node*
    .... Rearrangement Start ....
    Exp: n$17.v
    Prop: 
    <span class='color_blue'>(@f$0  &lt;=  8); n$1544 != 0; t != 0; MEMma &lt; malloc:38 &gt;  <span class='color_orange'>{vpath: }</span>(n$1546); MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(n$1543); MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(x) ;
    x = n$1542 <span class='color_orange'>update:45</span>:node*; n = null <span class='color_orange'>update:40</span>:node*; t = n$17 <span class='color_orange'>update:53</span>:node*; #GB<src.c>$head = n$1546 <span class='color_orange'>update:38</span>:node*; i = (@f$0 + 1) <span class='color_orange'>update:43</span>:int; return = n$1547 <span class='color_orange'>initial</span>:int ;
    n$1544|->{next:t <span class='color_orange'>update:56</span>, v:n$1545 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16; n$1543|->{next:null <span class='color_orange'>update:46</span>, v:@f$0 <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16; x|->{next:null <span class='color_orange'>update:46</span>, v:(@f$0 + 1) <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16; lsegne(n$1546,n$1544,[],P0); lseg(t,n$1543,[],P0)
    [footprint
       @f$2 != 0 *
       #GB<src.c>$head = @f$1 <span class='color_orange'>rearrange:38</span>:node*  ]
    where
    P0 = exists [_t$2]. _t$0|->{next:_t$1 <span class='color_orange'>update:56</span>, v:_t$2 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16</span>
    
    in prop_iter_extend_ptsto lexp: n$17.v
    prop before:
    <span class='color_blue'>(@f$0  &lt;=  8); n$1544 != 0; t != 0; MEMma &lt; malloc:38 &gt;  <span class='color_orange'>{vpath: }</span>(n$1546); MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(n$1543); MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(x) ;
    x = n$1542 <span class='color_orange'>update:45</span>:node*; n = null <span class='color_orange'>update:40</span>:node*; t = n$17 <span class='color_orange'>update:53</span>:node*; #GB<src.c>$head = n$1546 <span class='color_orange'>update:38</span>:node*; i = (@f$0 + 1) <span class='color_orange'>update:43</span>:int; return = n$1547 <span class='color_orange'>initial</span>:int ;
    n$1544|->{next:t <span class='color_orange'>update:56</span>, v:n$1545 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16; n$1543|->{next:null <span class='color_orange'>update:46</span>, v:@f$0 <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16; x|->{next:null <span class='color_orange'>update:46</span>, v:(@f$0 + 1) <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16; t|->{next:_t$2761 <span class='color_orange'>update:56</span>, v:_t$2762 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16; lsegne(n$1546,n$1544,[],P0); lseg(_t$2761,n$1543,[],P0)
    [footprint
       @f$2 != 0 *
       #GB<src.c>$head = @f$1 <span class='color_orange'>rearrange:38</span>:node*  ]
    where
    P0 = exists [_t$2]. _t$0|->{next:_t$1 <span class='color_orange'>update:56</span>, v:_t$2 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16</span>
    
    
    prop list after:
    PROP 1 of 1:
    <span class='color_blue'><span class='color_blue'>(@f$0  &lt;=  8)</span>; <span class='color_blue'>n$1544 != 0</span>; <span class='color_blue'>t != 0</span>; <span class='color_blue'>MEMma &lt; malloc:38 &gt;  <span class='color_orange'>{vpath: }</span>(n$1546)</span>; <span class='color_blue'>MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(n$1543)</span>; <span class='color_blue'>MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(x)</span> ;
    <span class='color_blue'>x = n$1542 <span class='color_orange'>update:45</span>:node*</span>; <span class='color_blue'>n = null <span class='color_orange'>update:40</span>:node*</span>; <span class='color_blue'>t = n$17 <span class='color_orange'>update:53</span>:node*</span>; <span class='color_blue'>#GB<src.c>$head = n$1546 <span class='color_orange'>update:38</span>:node*</span>; <span class='color_blue'>i = (@f$0 + 1) <span class='color_orange'>update:43</span>:int</span>; <span class='color_blue'>return = n$1547 <span class='color_orange'>initial</span>:int</span> ;
    <span class='color_blue'>n$1544|->{next:t <span class='color_orange'>update:56</span>, v:n$1545 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16</span>; <span class='color_blue'>n$1543|->{next:null <span class='color_orange'>update:46</span>, v:@f$0 <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16</span>; <span class='color_blue'>x|->{next:null <span class='color_orange'>update:46</span>, v:(@f$0 + 1) <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16</span>; <span class='color_blue'>t|->{next:_t$2761 <span class='color_orange'>update:56</span>, v:_t$2762 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16</span>; <span class='color_blue'>lsegne(n$1546,n$1544,[],P0)</span>; <span class='color_blue'>lseg(_t$2761,n$1543,[],P0)</span>
    [footprint
       <span class='color_blue'>@f$2 != 0</span> *
       <span class='color_blue'>#GB<src.c>$head = @f$1 <span class='color_orange'>rearrange:38</span>:node*</span>  ]
    where
    P0 = exists [_t$2]. <span class='color_blue'>_t$0|->{next:_t$1 <span class='color_orange'>update:56</span>, v:_t$2 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16</span></span>
    
    
    
    in prop_iter_extend_ptsto lexp: n$17.v
    prop before:
    <span class='color_blue'>n$1543 = t ;
    (@f$0  &lt;=  8); n$1544 != 0; t != 0; MEMma &lt; malloc:38 &gt;  <span class='color_orange'>{vpath: }</span>(n$1546); MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(x); MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(t) ;
    x = n$1542 <span class='color_orange'>update:45</span>:node*; n = null <span class='color_orange'>update:40</span>:node*; t = n$17 <span class='color_orange'>update:53</span>:node*; #GB<src.c>$head = n$1546 <span class='color_orange'>update:38</span>:node*; i = (@f$0 + 1) <span class='color_orange'>update:43</span>:int; return = n$1547 <span class='color_orange'>initial</span>:int ;
    n$1544|->{next:t <span class='color_orange'>update:56</span>, v:n$1545 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16; x|->{next:null <span class='color_orange'>update:46</span>, v:(@f$0 + 1) <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16; t|->{next:null <span class='color_orange'>update:46</span>, v:@f$0 <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16; lsegne(n$1546,n$1544,[],P0)
    [footprint
       n$1543 = t; @f$2 != 0 *
       #GB<src.c>$head = @f$1 <span class='color_orange'>rearrange:38</span>:node*  ]
    where
    P0 = exists [_t$2]. _t$0|->{next:_t$1 <span class='color_orange'>update:56</span>, v:_t$2 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16</span>
    
    
    prop list after:
    PROP 1 of 1:
    <span class='color_blue'><span class='color_blue'>n$1543 = t</span> ;
    <span class='color_blue'>(@f$0  &lt;=  8)</span>; <span class='color_blue'>n$1544 != 0</span>; <span class='color_blue'>t != 0</span>; <span class='color_blue'>MEMma &lt; malloc:38 &gt;  <span class='color_orange'>{vpath: }</span>(n$1546)</span>; <span class='color_blue'>MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(x)</span>; <span class='color_blue'>MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(t)</span> ;
    <span class='color_blue'>x = n$1542 <span class='color_orange'>update:45</span>:node*</span>; <span class='color_blue'>n = null <span class='color_orange'>update:40</span>:node*</span>; <span class='color_blue'>t = n$17 <span class='color_orange'>update:53</span>:node*</span>; <span class='color_blue'>#GB<src.c>$head = n$1546 <span class='color_orange'>update:38</span>:node*</span>; <span class='color_blue'>i = (@f$0 + 1) <span class='color_orange'>update:43</span>:int</span>; <span class='color_blue'>return = n$1547 <span class='color_orange'>initial</span>:int</span> ;
    <span class='color_blue'>n$1544|->{next:t <span class='color_orange'>update:56</span>, v:n$1545 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16</span>; <span class='color_blue'>x|->{next:null <span class='color_orange'>update:46</span>, v:(@f$0 + 1) <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16</span>; <span class='color_blue'>t|->{next:null <span class='color_orange'>update:46</span>, v:@f$0 <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16</span>; <span class='color_blue'>lsegne(n$1546,n$1544,[],P0)</span>
    [footprint
       <span class='color_blue'>n$1543 = t</span>; <span class='color_blue'>@f$2 != 0</span> *
       <span class='color_blue'>#GB<src.c>$head = @f$1 <span class='color_orange'>rearrange:38</span>:node*</span>  ]
    where
    P0 = exists [_t$2]. <span class='color_blue'>_t$0|->{next:_t$1 <span class='color_orange'>update:56</span>, v:_t$2 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16</span></span>
    
    
    
    Instruction Returns
    PROP 1 of 2:
    <span class='color_blue'><span class='color_blue'>(@f$0  &lt;=  8)</span>; <span class='color_blue'>_t$2 != 0</span>; <span class='color_blue'>t != 0</span>; <span class='color_red'>MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(x)</span>; <span class='color_blue'>MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(_t$5)</span>; <span class='color_blue'>MEMma &lt; malloc:38 &gt;  <span class='color_orange'>{vpath: }</span>(_t$1)</span>; <span class='color_red'>DANGL &lt; UNINIT &gt; (n$18)</span> ;
    <span class='color_blue'>x = <span class='color_red'>_t$6 <span class='color_orange'>update:45</span></span>:node*</span>; <span class='color_blue'>n = null <span class='color_orange'>update:40</span>:node*</span>; <span class='color_blue'>t = n$17 <span class='color_orange'>update:53</span>:node*</span>; <span class='color_blue'>#GB<src.c>$head = _t$1 <span class='color_orange'>update:38</span>:node*</span>; <span class='color_blue'>i = (@f$0 + 1) <span class='color_orange'>update:43</span>:int</span>; <span class='color_blue'>return = _t$0 <span class='color_orange'>initial</span>:int</span> ;
    <span class='color_red'>x|->{next:null <span class='color_orange'>update:46</span>, v:(@f$0 + 1) <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16</span>; <span class='color_blue'>_t$5|->{next:null <span class='color_orange'>update:46</span>, v:<span class='color_red'>@f$0 <span class='color_orange'>update:47</span></span>} <span class='color_orange'>alloc</span>:node16</span>; <span class='color_blue'>_t$2|->{next:t <span class='color_orange'>update:56</span>, v:_t$3 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16</span>; <span class='color_blue'>t|->{next:_t$4 <span class='color_orange'>update:56</span>, v:n$18 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16</span>; <span class='color_blue'>lsegne(_t$1,_t$2,[],P0)</span>; <span class='color_blue'>lseg(_t$4,_t$5,[],P0)</span>
    [footprint
       <span class='color_blue'>@f$2 != 0</span> *
       <span class='color_blue'>#GB<src.c>$head = @f$1 <span class='color_orange'>rearrange:38</span>:node*</span>  ]
    where
    P0 = exists [_t$2]. <span class='color_blue'>_t$0|->{next:_t$1 <span class='color_orange'>update:56</span>, v:_t$2 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16</span></span>
    PROP 2 of 2:
    <span class='color_blue'><span class='color_red'>n$18 = @f$0</span> ;
    <span class='color_blue'>(@f$0  &lt;=  8)</span>; <span class='color_blue'>_t$2 != 0</span>; <span class='color_blue'>t != 0</span>; <span class='color_blue'>MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(x)</span>; <span class='color_blue'>MEMma &lt; malloc:38 &gt;  <span class='color_orange'>{vpath: }</span>(_t$1)</span>; <span class='color_blue'>MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(t)</span> ;
    <span class='color_blue'>x = <span class='color_red'>_t$4 <span class='color_orange'>update:45</span></span>:node*</span>; <span class='color_blue'>n = null <span class='color_orange'>update:40</span>:node*</span>; <span class='color_blue'>t = n$17 <span class='color_orange'>update:53</span>:node*</span>; <span class='color_blue'>#GB<src.c>$head = _t$1 <span class='color_orange'>update:38</span>:node*</span>; <span class='color_blue'>i = (@f$0 + 1) <span class='color_orange'>update:43</span>:int</span>; <span class='color_blue'>return = _t$0 <span class='color_orange'>initial</span>:int</span> ;
    <span class='color_blue'>x|->{next:null <span class='color_orange'>update:46</span>, v:<span class='color_red'>(@f$0 + 1) <span class='color_orange'>update:47</span></span>} <span class='color_orange'>alloc</span>:node16</span>; <span class='color_blue'>_t$2|->{next:t <span class='color_orange'>update:56</span>, v:_t$3 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16</span>; <span class='color_blue'>t|->{next:null <span class='color_orange'>update:46</span>, v:@f$0 <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16</span>; <span class='color_blue'>lsegne(_t$1,_t$2,[],P0)</span>
    [footprint
       <span class='color_red'>t = @f$2</span>; <span class='color_red'>@f$3 != 0</span> *
       <span class='color_blue'>#GB<src.c>$head = @f$1 <span class='color_orange'>rearrange:38</span>:node*</span>  ]
    where
    P0 = exists [_t$2]. <span class='color_blue'>_t$0|->{next:_t$1 <span class='color_orange'>update:56</span>, v:_t$2 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16</span></span>
    
    Instruction <span class='color_green'>n$19=_fun_printf("%d\n":char const *,n$18:int) [line 54, column 7]</span>
    in vpath_find exp:n$1553
    vpath_find: found head : node*
    in vpath_find exp:n$1549
    vpath_find: cannot find n$1549
    in vpath_find exp:n$1548
    vpath_find: found x : node*
    <span class='color_orange'>WARNING: likely use of variable-arguments function, or function prototype missing</span>
    actual parameters: n$18
    formal parameters: 
    Found 1 specs for function printf
    START EXECUTING SPECS FOR printf from state
    <span class='color_blue'>(@f$0  &lt;=  8); n$1550 != 0; t != 0; MEMma &lt; malloc:38 &gt;  <span class='color_orange'>{vpath: }</span>(n$1553); MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(n$1549); MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(x); DANGL &lt; UNINIT &gt; (n$18) ;
    x = n$1548 <span class='color_orange'>update:45</span>:node*; n = null <span class='color_orange'>update:40</span>:node*; t = n$17 <span class='color_orange'>update:53</span>:node*; #GB<src.c>$head = n$1553 <span class='color_orange'>update:38</span>:node*; i = (@f$0 + 1) <span class='color_orange'>update:43</span>:int; return = n$1554 <span class='color_orange'>initial</span>:int ;
    n$1550|->{next:t <span class='color_orange'>update:56</span>, v:n$1551 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16; n$1549|->{next:null <span class='color_orange'>update:46</span>, v:@f$0 <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16; x|->{next:null <span class='color_orange'>update:46</span>, v:(@f$0 + 1) <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16; t|->{next:n$1552 <span class='color_orange'>update:56</span>, v:n$18 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16; lsegne(n$1553,n$1550,[],P0); lseg(n$1552,n$1549,[],P0)
    [footprint
       @f$2 != 0 *
       #GB<src.c>$head = @f$1 <span class='color_orange'>rearrange:38</span>:node*  ]
    where
    P0 = exists [_t$2]. _t$0|->{next:_t$1 <span class='color_orange'>update:56</span>, v:_t$2 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16</span>
    <span class='color_orange'>WARNING: more actual pars than formal pars in fun call (2 vs 1)</span>
    EXECUTING SPEC 1/1
    ACTUAL PRECONDITION =
      <span class='color_blue'>(@f$0  &lt;=  8); n$1550 != 0; t != 0; MEMma &lt; malloc:38 &gt;  <span class='color_orange'>{vpath: }</span>(n$1553); MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(n$1549); MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(x); DANGL &lt; UNINIT &gt; (n$18) ;
      x = n$1548 <span class='color_orange'>update:45</span>:node*; n = null <span class='color_orange'>update:40</span>:node*; t = n$17 <span class='color_orange'>update:53</span>:node*; #GB<src.c>$head = n$1553 <span class='color_orange'>update:38</span>:node*; i = (@f$0 + 1) <span class='color_orange'>update:43</span>:int; format|callee = "%d\n" <span class='color_orange'>actual_precondition</span>:char const *; return = n$1554 <span class='color_orange'>initial</span>:int ;
      n$1550|->{next:t <span class='color_orange'>update:56</span>, v:n$1551 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16; n$1549|->{next:null <span class='color_orange'>update:46</span>, v:@f$0 <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16; x|->{next:null <span class='color_orange'>update:46</span>, v:(@f$0 + 1) <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16; t|->{next:n$1552 <span class='color_orange'>update:56</span>, v:n$18 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16; lsegne(n$1553,n$1550,[],P0); lseg(n$1552,n$1549,[],P0)
      [footprint
         @f$2 != 0 *
         #GB<src.c>$head = @f$1 <span class='color_orange'>rearrange:38</span>:node*  ]
      where
      P0 = exists [_t$2]. _t$0|->{next:_t$1 <span class='color_orange'>update:56</span>, v:_t$2 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16</span>
    SPEC =
      --------------------------- ---------- ---------------------------
      PRE:
      <span class='color_blue'><span class='color_blue'>format|callee = _t$2777 <span class='color_orange'>formal</span>:char const *</span></span>
      POST 1 of 1:
      <span class='color_blue'><span class='color_red'>(-1  &lt;  _t$2778)</span>; <span class='color_red'>DANGL &lt; UNINIT &gt; (return|callee)</span> ;
      <span class='color_red'>return|callee = _t$2778 <span class='color_orange'>update:1114</span>:int</span></span>
      ----------------------------------------------------------------
    pre_check_pure_implication
    pi1:
      (@f$0  &lt;=  8); n$1550 != 0; n$17 != 0; MEMma &lt; malloc:38 &gt;  <span class='color_orange'>{vpath: }</span>(n$1553); MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(n$1549); MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(n$1548); DANGL &lt; UNINIT &gt; (n$18)
    pi2:
      
    returns
    sub1: 
      
    sub2: 
      
    Current Implication
    SUB:
      
    <span class='color_blue'>(@f$0  &lt;=  8); n$1550 != 0; t != 0; MEMma &lt; malloc:38 &gt;  <span class='color_orange'>{vpath: }</span>(n$1553); MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(n$1549); MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(x); DANGL &lt; UNINIT &gt; (n$18) ;
    x = n$1548 <span class='color_orange'>update:45</span>:node*; n = null <span class='color_orange'>update:40</span>:node*; t = n$17 <span class='color_orange'>update:53</span>:node*; #GB<src.c>$head = n$1553 <span class='color_orange'>update:38</span>:node*; i = (@f$0 + 1) <span class='color_orange'>update:43</span>:int; format|callee = "%d\n" <span class='color_orange'>actual_precondition</span>:char const *; return = n$1554 <span class='color_orange'>initial</span>:int ;
    n$1550|->{next:t <span class='color_orange'>update:56</span>, v:n$1551 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16; n$1549|->{next:null <span class='color_orange'>update:46</span>, v:@f$0 <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16; x|->{next:null <span class='color_orange'>update:46</span>, v:(@f$0 + 1) <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16; t|->{next:n$1552 <span class='color_orange'>update:56</span>, v:n$18 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16; lsegne(n$1553,n$1550,[],P0); lseg(n$1552,n$1549,[],P0)
    [footprint
       @f$2 != 0 *
       #GB<src.c>$head = @f$1 <span class='color_orange'>rearrange:38</span>:node*  ]
    where
    P0 = exists [_t$2]. _t$0|->{next:_t$1 <span class='color_orange'>update:56</span>, v:_t$2 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16</span>
    |-
    <span class='color_blue'>format|callee = _t$2777 <span class='color_orange'>formal</span>:char const *</span>
    
      do_imply "%d\n" _t$2777
        Final Implication
        SUB:
          
        <span class='color_blue'>(@f$0  &lt;=  8); n$1550 != 0; t != 0; MEMma &lt; malloc:38 &gt;  <span class='color_orange'>{vpath: }</span>(n$1553); MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(n$1549); MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(x); DANGL &lt; UNINIT &gt; (n$18) ;
        x = n$1548 <span class='color_orange'>update:45</span>:node*; n = null <span class='color_orange'>update:40</span>:node*; t = n$17 <span class='color_orange'>update:53</span>:node*; #GB<src.c>$head = n$1553 <span class='color_orange'>update:38</span>:node*; i = (@f$0 + 1) <span class='color_orange'>update:43</span>:int; return = n$1554 <span class='color_orange'>initial</span>:int ;
        n$1550|->{next:t <span class='color_orange'>update:56</span>, v:n$1551 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16; n$1549|->{next:null <span class='color_orange'>update:46</span>, v:@f$0 <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16; x|->{next:null <span class='color_orange'>update:46</span>, v:(@f$0 + 1) <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16; t|->{next:n$1552 <span class='color_orange'>update:56</span>, v:n$18 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16; lsegne(n$1553,n$1550,[],P0); lseg(n$1552,n$1549,[],P0)
        [footprint
           @f$2 != 0 *
           #GB<src.c>$head = @f$1 <span class='color_orange'>rearrange:38</span>:node*  ]
        where
        P0 = exists [_t$2]. _t$0|->{next:_t$1 <span class='color_orange'>update:56</span>, v:_t$2 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16</span>
        [SUB: 
          _t$2777 = "%d\n"]
        |-
        <span class='color_blue'></span>
    Result of Abduction
      SUB:
        
      <span class='color_blue'>(@f$0  &lt;=  8); n$1550 != 0; t != 0; MEMma &lt; malloc:38 &gt;  <span class='color_orange'>{vpath: }</span>(n$1553); MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(n$1549); MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(x); DANGL &lt; UNINIT &gt; (n$18) ;
      x = n$1548 <span class='color_orange'>update:45</span>:node*; n = null <span class='color_orange'>update:40</span>:node*; t = n$17 <span class='color_orange'>update:53</span>:node*; #GB<src.c>$head = n$1553 <span class='color_orange'>update:38</span>:node*; i = (@f$0 + 1) <span class='color_orange'>update:43</span>:int; format|callee = "%d\n" <span class='color_orange'>actual_precondition</span>:char const *; return = n$1554 <span class='color_orange'>initial</span>:int ;
      n$1550|->{next:t <span class='color_orange'>update:56</span>, v:n$1551 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16; n$1549|->{next:null <span class='color_orange'>update:46</span>, v:@f$0 <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16; x|->{next:null <span class='color_orange'>update:46</span>, v:(@f$0 + 1) <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16; t|->{next:n$1552 <span class='color_orange'>update:56</span>, v:n$18 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16; lsegne(n$1553,n$1550,[],P0); lseg(n$1552,n$1549,[],P0)
      [footprint
         @f$2 != 0 *
         #GB<src.c>$head = @f$1 <span class='color_orange'>rearrange:38</span>:node*  ]
      where
      P0 = exists [_t$2]. _t$0|->{next:_t$1 <span class='color_orange'>update:56</span>, v:_t$2 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16</span>
      [SUB: 
        _t$2777 = "%d\n"]
      |-
      <span class='color_blue'>format|callee = "%d\n" <span class='color_orange'>formal</span>:char const *</span>
    returning TRUE
      New footprint:
      
      Frame fld:
      
      Missing fld:
      
      Instantiated frame:
      n$1550|->{next:n$17 <span class='color_orange'>update:56</span>, v:n$1551 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16; n$1549|->{next:null <span class='color_orange'>update:46</span>, v:@f$0 <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16; n$1548|->{next:null <span class='color_orange'>update:46</span>, v:(@f$0 + 1) <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16; n$17|->{next:n$1552 <span class='color_orange'>update:56</span>, v:n$18 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16; &amp;x|->n$1548 <span class='color_orange'>update:45</span>:node*; &amp;n|->null <span class='color_orange'>update:40</span>:node*; &amp;t|->n$17 <span class='color_orange'>update:53</span>:node*; &amp;#GB<src.c>$head|->n$1553 <span class='color_orange'>update:38</span>:node*; &amp;i|->(@f$0 + 1) <span class='color_orange'>update:43</span>:int; &amp;return|->n$1554 <span class='color_orange'>initial</span>:int; lsegne(n$1553,n$1550,[],lam [_t$0,_t$1,]. exists [_t$2]. _t$0|->{next:_t$1 <span class='color_orange'>update:56</span>, v:_t$2 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16); lseg(n$1552,n$1549,[],lam [_t$0,_t$1,]. exists [_t$2]. _t$0|->{next:_t$1 <span class='color_orange'>update:56</span>, v:_t$2 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16)
      Instantiated post:
      PROP 1 of 1:
      <span class='color_blue'><span class='color_red'>(-1  &lt;  _t$2778)</span>; <span class='color_red'>DANGL &lt; UNINIT &gt; (return|callee)</span> ;
      <span class='color_red'>return|callee = _t$2778 <span class='color_orange'>update:54</span>:int</span></span>
      
    ***** RESULTS FUNCTION CALL *******
    PROP 1 of 1:
    <span class='color_blue'><span class='color_red'>(-1  &lt;  n$19)</span>; <span class='color_blue'>(@f$0  &lt;=  8)</span>; <span class='color_blue'>n$1550 != 0</span>; <span class='color_blue'>t != 0</span>; <span class='color_blue'>MEMma &lt; malloc:38 &gt;  <span class='color_orange'>{vpath: }</span>(n$1553)</span>; <span class='color_blue'>MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(n$1549)</span>; <span class='color_blue'>MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(x)</span>; <span class='color_red'>DANGL &lt; UNINIT &gt; (n$19)</span>; <span class='color_blue'>DANGL &lt; UNINIT &gt; (n$18)</span> ;
    <span class='color_blue'>x = n$1548 <span class='color_orange'>update:45</span>:node*</span>; <span class='color_blue'>n = null <span class='color_orange'>update:40</span>:node*</span>; <span class='color_blue'>t = n$17 <span class='color_orange'>update:53</span>:node*</span>; <span class='color_blue'>#GB<src.c>$head = n$1553 <span class='color_orange'>update:38</span>:node*</span>; <span class='color_blue'>i = (@f$0 + 1) <span class='color_orange'>update:43</span>:int</span>; <span class='color_blue'>return = n$1554 <span class='color_orange'>initial</span>:int</span> ;
    <span class='color_blue'>n$1550|->{next:t <span class='color_orange'>update:56</span>, v:n$1551 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16</span>; <span class='color_blue'>n$1549|->{next:null <span class='color_orange'>update:46</span>, v:@f$0 <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16</span>; <span class='color_blue'>x|->{next:null <span class='color_orange'>update:46</span>, v:(@f$0 + 1) <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16</span>; <span class='color_blue'>t|->{next:n$1552 <span class='color_orange'>update:56</span>, v:n$18 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16</span>; <span class='color_blue'>lsegne(n$1553,n$1550,[],P0)</span>; <span class='color_blue'>lseg(n$1552,n$1549,[],P0)</span>
    [footprint
       <span class='color_blue'>@f$2 != 0</span> *
       <span class='color_blue'>#GB<src.c>$head = @f$1 <span class='color_orange'>rearrange:38</span>:node*</span>  ]
    where
    P0 = exists [_t$2]. <span class='color_blue'>_t$0|->{next:_t$1 <span class='color_orange'>update:56</span>, v:_t$2 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16</span></span>
    ***** END RESULTS FUNCTION CALL *******
    Instruction Returns
    PROP 1 of 1:
    <span class='color_blue'><span class='color_red'>(-1  &lt;  n$19)</span>; <span class='color_blue'>(@f$0  &lt;=  8)</span>; <span class='color_blue'>_t$2 != 0</span>; <span class='color_blue'>t != 0</span>; <span class='color_blue'>MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(x)</span>; <span class='color_blue'>MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(_t$5)</span>; <span class='color_blue'>MEMma &lt; malloc:38 &gt;  <span class='color_orange'>{vpath: }</span>(_t$1)</span>; <span class='color_red'>DANGL &lt; UNINIT &gt; (n$19)</span>; <span class='color_blue'>DANGL &lt; UNINIT &gt; (n$18)</span> ;
    <span class='color_blue'>x = _t$6 <span class='color_orange'>update:45</span>:node*</span>; <span class='color_blue'>n = null <span class='color_orange'>update:40</span>:node*</span>; <span class='color_blue'>t = n$17 <span class='color_orange'>update:53</span>:node*</span>; <span class='color_blue'>#GB<src.c>$head = _t$1 <span class='color_orange'>update:38</span>:node*</span>; <span class='color_blue'>i = (@f$0 + 1) <span class='color_orange'>update:43</span>:int</span>; <span class='color_blue'>return = _t$0 <span class='color_orange'>initial</span>:int</span> ;
    <span class='color_blue'>x|->{next:null <span class='color_orange'>update:46</span>, v:(@f$0 + 1) <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16</span>; <span class='color_blue'>_t$5|->{next:null <span class='color_orange'>update:46</span>, v:@f$0 <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16</span>; <span class='color_blue'>_t$2|->{next:t <span class='color_orange'>update:56</span>, v:_t$3 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16</span>; <span class='color_blue'>t|->{next:_t$4 <span class='color_orange'>update:56</span>, v:n$18 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16</span>; <span class='color_blue'>lsegne(_t$1,_t$2,[],P0)</span>; <span class='color_blue'>lseg(_t$4,_t$5,[],P0)</span>
    [footprint
       <span class='color_red'>(@f$0  &lt;=  8)</span>; <span class='color_blue'>@f$2 != 0</span> *
       <span class='color_blue'>#GB<src.c>$head = @f$1 <span class='color_orange'>rearrange:38</span>:node*</span>  ]
    where
    P0 = exists [_t$2]. <span class='color_blue'>_t$0|->{next:_t$1 <span class='color_orange'>update:56</span>, v:_t$2 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16</span></span>
    
    Instruction <span class='color_green'>n$19=_fun_printf("%d\n":char const *,n$18:int) [line 54, column 7]</span>
    in vpath_find exp:n$1558
    vpath_find: found head : node*
    in vpath_find exp:n$1555
    vpath_find: found x : node*
    in vpath_find exp:n$17
    vpath_find: found t : node*
    <span class='color_orange'>WARNING: likely use of variable-arguments function, or function prototype missing</span>
    actual parameters: @f$0
    formal parameters: 
    Found 1 specs for function printf
    START EXECUTING SPECS FOR printf from state
    <span class='color_blue'>n$18 = @f$0 ;
    (@f$0  &lt;=  8); n$1556 != 0; t != 0; MEMma &lt; malloc:38 &gt;  <span class='color_orange'>{vpath: }</span>(n$1558); MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(x); MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(t) ;
    x = n$1555 <span class='color_orange'>update:45</span>:node*; n = null <span class='color_orange'>update:40</span>:node*; t = n$17 <span class='color_orange'>update:53</span>:node*; #GB<src.c>$head = n$1558 <span class='color_orange'>update:38</span>:node*; i = (@f$0 + 1) <span class='color_orange'>update:43</span>:int; return = n$1559 <span class='color_orange'>initial</span>:int ;
    n$1556|->{next:t <span class='color_orange'>update:56</span>, v:n$1557 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16; x|->{next:null <span class='color_orange'>update:46</span>, v:(@f$0 + 1) <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16; t|->{next:null <span class='color_orange'>update:46</span>, v:@f$0 <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16; lsegne(n$1558,n$1556,[],P0)
    [footprint
       t = @f$2; @f$3 != 0 *
       #GB<src.c>$head = @f$1 <span class='color_orange'>rearrange:38</span>:node*  ]
    where
    P0 = exists [_t$2]. _t$0|->{next:_t$1 <span class='color_orange'>update:56</span>, v:_t$2 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16</span>
    <span class='color_orange'>WARNING: more actual pars than formal pars in fun call (2 vs 1)</span>
    EXECUTING SPEC 1/1
    ACTUAL PRECONDITION =
      <span class='color_blue'>n$18 = @f$0 ;
      (@f$0  &lt;=  8); n$1556 != 0; t != 0; MEMma &lt; malloc:38 &gt;  <span class='color_orange'>{vpath: }</span>(n$1558); MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(x); MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(t) ;
      x = n$1555 <span class='color_orange'>update:45</span>:node*; n = null <span class='color_orange'>update:40</span>:node*; t = n$17 <span class='color_orange'>update:53</span>:node*; #GB<src.c>$head = n$1558 <span class='color_orange'>update:38</span>:node*; i = (@f$0 + 1) <span class='color_orange'>update:43</span>:int; format|callee = "%d\n" <span class='color_orange'>actual_precondition</span>:char const *; return = n$1559 <span class='color_orange'>initial</span>:int ;
      n$1556|->{next:t <span class='color_orange'>update:56</span>, v:n$1557 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16; x|->{next:null <span class='color_orange'>update:46</span>, v:(@f$0 + 1) <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16; t|->{next:null <span class='color_orange'>update:46</span>, v:@f$0 <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16; lsegne(n$1558,n$1556,[],P0)
      [footprint
         t = @f$2; @f$3 != 0 *
         #GB<src.c>$head = @f$1 <span class='color_orange'>rearrange:38</span>:node*  ]
      where
      P0 = exists [_t$2]. _t$0|->{next:_t$1 <span class='color_orange'>update:56</span>, v:_t$2 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16</span>
    SPEC =
      --------------------------- ---------- ---------------------------
      PRE:
      <span class='color_blue'><span class='color_blue'>format|callee = _t$2786 <span class='color_orange'>formal</span>:char const *</span></span>
      POST 1 of 1:
      <span class='color_blue'><span class='color_red'>(-1  &lt;  _t$2787)</span>; <span class='color_red'>DANGL &lt; UNINIT &gt; (return|callee)</span> ;
      <span class='color_red'>return|callee = _t$2787 <span class='color_orange'>update:1114</span>:int</span></span>
      ----------------------------------------------------------------
    pre_check_pure_implication
    pi1:
      n$18 = @f$0; (@f$0  &lt;=  8); n$1556 != 0; n$17 != 0; MEMma &lt; malloc:38 &gt;  <span class='color_orange'>{vpath: }</span>(n$1558); MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(n$1555); MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(n$17)
    pi2:
      
    returns
    sub1: 
      n$18 = @f$0
    sub2: 
      
    Current Implication
    SUB:
      n$18 = @f$0
    <span class='color_blue'>(@f$0  &lt;=  8); n$1556 != 0; t != 0; MEMma &lt; malloc:38 &gt;  <span class='color_orange'>{vpath: }</span>(n$1558); MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(x); MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(t); @f$0 = @f$0 ;
    x = n$1555 <span class='color_orange'>update:45</span>:node*; n = null <span class='color_orange'>update:40</span>:node*; t = n$17 <span class='color_orange'>update:53</span>:node*; #GB<src.c>$head = n$1558 <span class='color_orange'>update:38</span>:node*; i = (@f$0 + 1) <span class='color_orange'>update:43</span>:int; format|callee = "%d\n" <span class='color_orange'>actual_precondition</span>:char const *; return = n$1559 <span class='color_orange'>initial</span>:int ;
    n$1556|->{next:t <span class='color_orange'>update:56</span>, v:n$1557 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16; x|->{next:null <span class='color_orange'>update:46</span>, v:(@f$0 + 1) <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16; t|->{next:null <span class='color_orange'>update:46</span>, v:@f$0 <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16; lsegne(n$1558,n$1556,[],P0)
    [footprint
       t = @f$2; @f$3 != 0 *
       #GB<src.c>$head = @f$1 <span class='color_orange'>rearrange:38</span>:node*  ]
    where
    P0 = exists [_t$2]. _t$0|->{next:_t$1 <span class='color_orange'>update:56</span>, v:_t$2 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16</span>
    |-
    <span class='color_blue'>format|callee = _t$2786 <span class='color_orange'>formal</span>:char const *</span>
    
      do_imply "%d\n" _t$2786
        Final Implication
        SUB:
          n$18 = @f$0
        <span class='color_blue'>(@f$0  &lt;=  8); n$1556 != 0; t != 0; MEMma &lt; malloc:38 &gt;  <span class='color_orange'>{vpath: }</span>(n$1558); MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(x); MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(t); @f$0 = @f$0 ;
        x = n$1555 <span class='color_orange'>update:45</span>:node*; n = null <span class='color_orange'>update:40</span>:node*; t = n$17 <span class='color_orange'>update:53</span>:node*; #GB<src.c>$head = n$1558 <span class='color_orange'>update:38</span>:node*; i = (@f$0 + 1) <span class='color_orange'>update:43</span>:int; return = n$1559 <span class='color_orange'>initial</span>:int ;
        n$1556|->{next:t <span class='color_orange'>update:56</span>, v:n$1557 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16; x|->{next:null <span class='color_orange'>update:46</span>, v:(@f$0 + 1) <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16; t|->{next:null <span class='color_orange'>update:46</span>, v:@f$0 <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16; lsegne(n$1558,n$1556,[],P0)
        [footprint
           t = @f$2; @f$3 != 0 *
           #GB<src.c>$head = @f$1 <span class='color_orange'>rearrange:38</span>:node*  ]
        where
        P0 = exists [_t$2]. _t$0|->{next:_t$1 <span class='color_orange'>update:56</span>, v:_t$2 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16</span>
        [SUB: 
          _t$2786 = "%d\n"]
        |-
        <span class='color_blue'></span>
    Result of Abduction
      SUB:
        n$18 = @f$0
      <span class='color_blue'>(@f$0  &lt;=  8); n$1556 != 0; t != 0; MEMma &lt; malloc:38 &gt;  <span class='color_orange'>{vpath: }</span>(n$1558); MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(x); MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(t); @f$0 = @f$0 ;
      x = n$1555 <span class='color_orange'>update:45</span>:node*; n = null <span class='color_orange'>update:40</span>:node*; t = n$17 <span class='color_orange'>update:53</span>:node*; #GB<src.c>$head = n$1558 <span class='color_orange'>update:38</span>:node*; i = (@f$0 + 1) <span class='color_orange'>update:43</span>:int; format|callee = "%d\n" <span class='color_orange'>actual_precondition</span>:char const *; return = n$1559 <span class='color_orange'>initial</span>:int ;
      n$1556|->{next:t <span class='color_orange'>update:56</span>, v:n$1557 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16; x|->{next:null <span class='color_orange'>update:46</span>, v:(@f$0 + 1) <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16; t|->{next:null <span class='color_orange'>update:46</span>, v:@f$0 <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16; lsegne(n$1558,n$1556,[],P0)
      [footprint
         t = @f$2; @f$3 != 0 *
         #GB<src.c>$head = @f$1 <span class='color_orange'>rearrange:38</span>:node*  ]
      where
      P0 = exists [_t$2]. _t$0|->{next:_t$1 <span class='color_orange'>update:56</span>, v:_t$2 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16</span>
      [SUB: 
        _t$2786 = "%d\n"]
      |-
      <span class='color_blue'>format|callee = "%d\n" <span class='color_orange'>formal</span>:char const *</span>
    returning TRUE
      New footprint:
      
      Frame fld:
      
      Missing fld:
      
      Instantiated frame:
      n$1556|->{next:n$17 <span class='color_orange'>update:56</span>, v:n$1557 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16; n$1555|->{next:null <span class='color_orange'>update:46</span>, v:(@f$0 + 1) <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16; n$17|->{next:null <span class='color_orange'>update:46</span>, v:@f$0 <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16; &amp;x|->n$1555 <span class='color_orange'>update:45</span>:node*; &amp;n|->null <span class='color_orange'>update:40</span>:node*; &amp;t|->n$17 <span class='color_orange'>update:53</span>:node*; &amp;#GB<src.c>$head|->n$1558 <span class='color_orange'>update:38</span>:node*; &amp;i|->(@f$0 + 1) <span class='color_orange'>update:43</span>:int; &amp;return|->n$1559 <span class='color_orange'>initial</span>:int; lsegne(n$1558,n$1556,[],lam [_t$0,_t$1,]. exists [_t$2]. _t$0|->{next:_t$1 <span class='color_orange'>update:56</span>, v:_t$2 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16)
      Instantiated post:
      PROP 1 of 1:
      <span class='color_blue'><span class='color_red'>(-1  &lt;  _t$2787)</span>; <span class='color_red'>DANGL &lt; UNINIT &gt; (return|callee)</span> ;
      <span class='color_red'>return|callee = _t$2787 <span class='color_orange'>update:54</span>:int</span></span>
      
    ***** RESULTS FUNCTION CALL *******
    PROP 1 of 1:
    <span class='color_blue'><span class='color_blue'>n$18 = @f$0</span> ;
    <span class='color_red'>(-1  &lt;  n$19)</span>; <span class='color_blue'>(@f$0  &lt;=  8)</span>; <span class='color_blue'>n$1556 != 0</span>; <span class='color_blue'>t != 0</span>; <span class='color_blue'>MEMma &lt; malloc:38 &gt;  <span class='color_orange'>{vpath: }</span>(n$1558)</span>; <span class='color_blue'>MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(x)</span>; <span class='color_blue'>MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(t)</span>; <span class='color_red'>DANGL &lt; UNINIT &gt; (n$19)</span> ;
    <span class='color_blue'>x = n$1555 <span class='color_orange'>update:45</span>:node*</span>; <span class='color_blue'>n = null <span class='color_orange'>update:40</span>:node*</span>; <span class='color_blue'>t = n$17 <span class='color_orange'>update:53</span>:node*</span>; <span class='color_blue'>#GB<src.c>$head = n$1558 <span class='color_orange'>update:38</span>:node*</span>; <span class='color_blue'>i = (@f$0 + 1) <span class='color_orange'>update:43</span>:int</span>; <span class='color_blue'>return = n$1559 <span class='color_orange'>initial</span>:int</span> ;
    <span class='color_blue'>n$1556|->{next:t <span class='color_orange'>update:56</span>, v:n$1557 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16</span>; <span class='color_blue'>x|->{next:null <span class='color_orange'>update:46</span>, v:(@f$0 + 1) <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16</span>; <span class='color_blue'>t|->{next:null <span class='color_orange'>update:46</span>, v:@f$0 <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16</span>; <span class='color_blue'>lsegne(n$1558,n$1556,[],P0)</span>
    [footprint
       <span class='color_blue'>t = @f$2</span>; <span class='color_blue'>@f$3 != 0</span> *
       <span class='color_blue'>#GB<src.c>$head = @f$1 <span class='color_orange'>rearrange:38</span>:node*</span>  ]
    where
    P0 = exists [_t$2]. <span class='color_blue'>_t$0|->{next:_t$1 <span class='color_orange'>update:56</span>, v:_t$2 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16</span></span>
    ***** END RESULTS FUNCTION CALL *******
    Instruction Returns
    PROP 1 of 1:
    <span class='color_blue'><span class='color_blue'>n$18 = @f$0</span> ;
    <span class='color_red'>(-1  &lt;  n$19)</span>; <span class='color_blue'>(@f$0  &lt;=  8)</span>; <span class='color_blue'>_t$2 != 0</span>; <span class='color_blue'>t != 0</span>; <span class='color_blue'>MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(x)</span>; <span class='color_blue'>MEMma &lt; malloc:38 &gt;  <span class='color_orange'>{vpath: }</span>(_t$1)</span>; <span class='color_blue'>MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(t)</span>; <span class='color_red'>DANGL &lt; UNINIT &gt; (n$19)</span> ;
    <span class='color_blue'>x = _t$4 <span class='color_orange'>update:45</span>:node*</span>; <span class='color_blue'>n = null <span class='color_orange'>update:40</span>:node*</span>; <span class='color_blue'>t = n$17 <span class='color_orange'>update:53</span>:node*</span>; <span class='color_blue'>#GB<src.c>$head = _t$1 <span class='color_orange'>update:38</span>:node*</span>; <span class='color_blue'>i = (@f$0 + 1) <span class='color_orange'>update:43</span>:int</span>; <span class='color_blue'>return = _t$0 <span class='color_orange'>initial</span>:int</span> ;
    <span class='color_blue'>x|->{next:null <span class='color_orange'>update:46</span>, v:(@f$0 + 1) <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16</span>; <span class='color_blue'>_t$2|->{next:t <span class='color_orange'>update:56</span>, v:_t$3 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16</span>; <span class='color_blue'>t|->{next:null <span class='color_orange'>update:46</span>, v:@f$0 <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16</span>; <span class='color_blue'>lsegne(_t$1,_t$2,[],P0)</span>
    [footprint
       <span class='color_blue'>t = @f$2</span>; <span class='color_red'>(@f$0  &lt;=  8)</span>; <span class='color_blue'>@f$3 != 0</span> *
       <span class='color_blue'>#GB<src.c>$head = @f$1 <span class='color_orange'>rearrange:38</span>:node*</span>  ]
    where
    P0 = exists [_t$2]. <span class='color_blue'>_t$0|->{next:_t$1 <span class='color_orange'>update:56</span>, v:_t$2 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16</span></span>
    
    Instruction <span class='color_green'>REMOVE_TEMPS(n$17,n$18,n$19); [line 54, column 7]</span>
    in vpath_find exp:_t$6
    vpath_find: found x : node*
    in vpath_find exp:_t$5
    vpath_find: cannot find _t$5
    in vpath_find exp:_t$1
    vpath_find: found head : node*
    Instruction Returns
    PROP 1 of 1:
    <span class='color_blue'><span class='color_red'>(-1  &lt;  _t$9)</span>; <span class='color_blue'>(@f$0  &lt;=  8)</span>; <span class='color_red'>t != 0</span>; <span class='color_blue'>_t$2 != 0</span>; <span class='color_red'>MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(x)</span>; <span class='color_red'>MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(_t$7)</span>; <span class='color_blue'>MEMma &lt; malloc:38 &gt;  <span class='color_orange'>{vpath: }</span>(_t$1)</span>; <span class='color_red'>DANGL &lt; UNINIT &gt; (_t$9)</span>; <span class='color_blue'>DANGL &lt; UNINIT &gt; (_t$6)</span> ;
    <span class='color_blue'>x = <span class='color_red'>_t$8 <span class='color_orange'>update:45</span></span>:node*</span>; <span class='color_blue'>n = null <span class='color_orange'>update:40</span>:node*</span>; <span class='color_blue'>t = <span class='color_red'>_t$3 <span class='color_orange'>update:53</span></span>:node*</span>; <span class='color_blue'>#GB<src.c>$head = _t$1 <span class='color_orange'>update:38</span>:node*</span>; <span class='color_blue'>i = (@f$0 + 1) <span class='color_orange'>update:43</span>:int</span>; <span class='color_blue'>return = _t$0 <span class='color_orange'>initial</span>:int</span> ;
    <span class='color_red'>x|->{next:null <span class='color_orange'>update:46</span>, v:(@f$0 + 1) <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16</span>; <span class='color_red'>_t$7|->{next:null <span class='color_orange'>update:46</span>, v:@f$0 <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16</span>; <span class='color_red'>t|->{next:_t$5 <span class='color_orange'>update:56</span>, v:_t$6 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16</span>; <span class='color_blue'>_t$2|->{next:<span class='color_red'>t <span class='color_orange'>update:56</span></span>, v:<span class='color_red'>_t$4 <span class='color_orange'>alloc</span></span>} <span class='color_orange'>alloc</span>:node16</span>; <span class='color_blue'>lsegne(_t$1,_t$2,[],P0)</span>; <span class='color_blue'>lseg(_t$5,_t$7,[],P0)</span>
    [footprint
       <span class='color_blue'>(@f$0  &lt;=  8)</span>; <span class='color_blue'>@f$2 != 0</span> *
       <span class='color_blue'>#GB<src.c>$head = @f$1 <span class='color_orange'>rearrange:38</span>:node*</span>  ]
    where
    P0 = exists [_t$2]. <span class='color_blue'>_t$0|->{next:_t$1 <span class='color_orange'>update:56</span>, v:_t$2 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16</span></span>
    
    Instruction <span class='color_green'>REMOVE_TEMPS(n$17,n$18,n$19); [line 54, column 7]</span>
    in vpath_find exp:_t$4
    vpath_find: found x : node*
    in vpath_find exp:_t$1
    vpath_find: found head : node*
    in vpath_find exp:n$17
    vpath_find: found t : node*
    Instruction Returns
    PROP 1 of 1:
    <span class='color_blue'><span class='color_red'>(-1  &lt;  _t$6)</span>; <span class='color_blue'>(@f$0  &lt;=  8)</span>; <span class='color_red'>t != 0</span>; <span class='color_blue'>_t$2 != 0</span>; <span class='color_red'>MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(x)</span>; <span class='color_red'>MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(t)</span>; <span class='color_blue'>MEMma &lt; malloc:38 &gt;  <span class='color_orange'>{vpath: }</span>(_t$1)</span>; <span class='color_red'>DANGL &lt; UNINIT &gt; (_t$6)</span> ;
    <span class='color_blue'>x = <span class='color_red'>_t$5 <span class='color_orange'>update:45</span></span>:node*</span>; <span class='color_blue'>n = null <span class='color_orange'>update:40</span>:node*</span>; <span class='color_blue'>t = <span class='color_red'>_t$3 <span class='color_orange'>update:53</span></span>:node*</span>; <span class='color_blue'>#GB<src.c>$head = _t$1 <span class='color_orange'>update:38</span>:node*</span>; <span class='color_blue'>i = (@f$0 + 1) <span class='color_orange'>update:43</span>:int</span>; <span class='color_blue'>return = _t$0 <span class='color_orange'>initial</span>:int</span> ;
    <span class='color_red'>x|->{next:null <span class='color_orange'>update:46</span>, v:(@f$0 + 1) <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16</span>; <span class='color_red'>t|->{next:null <span class='color_orange'>update:46</span>, v:@f$0 <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16</span>; <span class='color_blue'>_t$2|->{next:<span class='color_red'>t <span class='color_orange'>update:56</span></span>, v:<span class='color_red'>_t$4 <span class='color_orange'>alloc</span></span>} <span class='color_orange'>alloc</span>:node16</span>; <span class='color_blue'>lsegne(_t$1,_t$2,[],P0)</span>
    [footprint
       <span class='color_blue'>@f$3 = @f$2</span>; <span class='color_blue'>(@f$0  &lt;=  8)</span>; <span class='color_red'>@f$4 != 0</span> *
       <span class='color_blue'>#GB<src.c>$head = @f$1 <span class='color_orange'>rearrange:38</span>:node*</span>  ]
    where
    P0 = exists [_t$2]. <span class='color_blue'>_t$0|->{next:_t$1 <span class='color_orange'>update:56</span>, v:_t$2 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16</span></span>
    
    Instruction <span class='color_green'>APPLY_ABSTRACTION; [line 54, column 7]</span>
    in vpath_find exp:_t$8
    vpath_find: found x : node*
    in vpath_find exp:_t$7
    vpath_find: cannot find _t$7
    in vpath_find exp:_t$1
    vpath_find: found head : node*
    <span class='color_blue'>(@f$0  &lt;=  8); t != 0; MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(x); MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(_t$3); MEMma &lt; malloc:38 &gt;  <span class='color_orange'>{vpath: }</span>(_t$1) ;
    x = _t$4 <span class='color_orange'>update:45</span>:node*; n = null <span class='color_orange'>update:40</span>:node*; t = _t$2 <span class='color_orange'>update:53</span>:node*; #GB<src.c>$head = _t$1 <span class='color_orange'>update:38</span>:node*; i = (@f$0 + 1) <span class='color_orange'>update:43</span>:int; return = _t$0 <span class='color_orange'>initial</span>:int ;
    x|->{next:null <span class='color_orange'>update:46</span>, v:(@f$0 + 1) <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16; _t$3|->{next:null <span class='color_orange'>update:46</span>, v:@f$0 <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16; lsegne(t,_t$3,[],P0); lsegne(_t$1,t,[],P0)
    [footprint
       (@f$0  &lt;=  8) *
       #GB<src.c>$head = @f$1 <span class='color_orange'>rearrange:38</span>:node*  ]
    where
    P0 = exists [_t$2]. _t$0|->{next:_t$1 <span class='color_orange'>update:56</span>, v:_t$2 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16</span>
    Instruction Returns
    PROP 1 of 1:
    <span class='color_blue'><span class='color_blue'>(@f$0  &lt;=  8)</span>; <span class='color_blue'>t != 0</span>; <span class='color_red'>MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(x)</span>; <span class='color_blue'>MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(_t$3)</span>; <span class='color_blue'>MEMma &lt; malloc:38 &gt;  <span class='color_orange'>{vpath: }</span>(_t$1)</span> ;
    <span class='color_blue'>x = <span class='color_red'>_t$4 <span class='color_orange'>update:45</span></span>:node*</span>; <span class='color_blue'>n = null <span class='color_orange'>update:40</span>:node*</span>; <span class='color_blue'>t = <span class='color_red'>_t$2 <span class='color_orange'>update:53</span></span>:node*</span>; <span class='color_blue'>#GB<src.c>$head = _t$1 <span class='color_orange'>update:38</span>:node*</span>; <span class='color_blue'>i = (@f$0 + 1) <span class='color_orange'>update:43</span>:int</span>; <span class='color_blue'>return = _t$0 <span class='color_orange'>initial</span>:int</span> ;
    <span class='color_red'>x|->{next:null <span class='color_orange'>update:46</span>, v:(@f$0 + 1) <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16</span>; <span class='color_blue'>_t$3|->{next:<span class='color_red'>null <span class='color_orange'>update:46</span></span>, v:<span class='color_red'>@f$0 <span class='color_orange'>update:47</span></span>} <span class='color_orange'>alloc</span>:node16</span>; <span class='color_blue'>lsegne(t,_t$3,[],P0)</span>; <span class='color_blue'>lsegne(_t$1,t,[],P0)</span>
    [footprint
       <span class='color_blue'>(@f$0  &lt;=  8)</span> *
       <span class='color_blue'>#GB<src.c>$head = @f$1 <span class='color_orange'>rearrange:38</span>:node*</span>  ]
    where
    P0 = exists [_t$2]. <span class='color_blue'>_t$0|->{next:_t$1 <span class='color_orange'>update:56</span>, v:_t$2 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16</span></span>
    
    Instruction <span class='color_green'>APPLY_ABSTRACTION; [line 54, column 7]</span>
    in vpath_find exp:_t$5
    vpath_find: found x : node*
    in vpath_find exp:_t$3
    vpath_find: found t : node*
    in vpath_find exp:_t$1
    vpath_find: found head : node*
    <span class='color_blue'>(@f$0  &lt;=  8); t != 0; MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(x); MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(t); MEMma &lt; malloc:38 &gt;  <span class='color_orange'>{vpath: }</span>(_t$1) ;
    x = _t$3 <span class='color_orange'>update:45</span>:node*; n = null <span class='color_orange'>update:40</span>:node*; t = _t$2 <span class='color_orange'>update:53</span>:node*; #GB<src.c>$head = _t$1 <span class='color_orange'>update:38</span>:node*; i = (@f$0 + 1) <span class='color_orange'>update:43</span>:int; return = _t$0 <span class='color_orange'>initial</span>:int ;
    x|->{next:null <span class='color_orange'>update:46</span>, v:(@f$0 + 1) <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16; t|->{next:null <span class='color_orange'>update:46</span>, v:@f$0 <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16; lsegne(_t$1,t,[],P0)
    [footprint
       (@f$0  &lt;=  8) *
       #GB<src.c>$head = @f$1 <span class='color_orange'>rearrange:38</span>:node*  ]
    where
    P0 = exists [_t$2]. _t$0|->{next:_t$1 <span class='color_orange'>update:56</span>, v:_t$2 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16</span>
    Instruction Returns
    PROP 1 of 1:
    <span class='color_blue'><span class='color_blue'>(@f$0  &lt;=  8)</span>; <span class='color_blue'>t != 0</span>; <span class='color_blue'>MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(x)</span>; <span class='color_blue'>MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(t)</span>; <span class='color_blue'>MEMma &lt; malloc:38 &gt;  <span class='color_orange'>{vpath: }</span>(_t$1)</span> ;
    <span class='color_blue'>x = <span class='color_red'>_t$3 <span class='color_orange'>update:45</span></span>:node*</span>; <span class='color_blue'>n = null <span class='color_orange'>update:40</span>:node*</span>; <span class='color_blue'>t = <span class='color_red'>_t$2 <span class='color_orange'>update:53</span></span>:node*</span>; <span class='color_blue'>#GB<src.c>$head = _t$1 <span class='color_orange'>update:38</span>:node*</span>; <span class='color_blue'>i = (@f$0 + 1) <span class='color_orange'>update:43</span>:int</span>; <span class='color_blue'>return = _t$0 <span class='color_orange'>initial</span>:int</span> ;
    <span class='color_blue'>x|->{next:null <span class='color_orange'>update:46</span>, v:<span class='color_red'>(@f$0 + 1) <span class='color_orange'>update:47</span></span>} <span class='color_orange'>alloc</span>:node16</span>; <span class='color_blue'>t|->{next:<span class='color_red'>null <span class='color_orange'>update:46</span></span>, v:<span class='color_red'>@f$0 <span class='color_orange'>update:47</span></span>} <span class='color_orange'>alloc</span>:node16</span>; <span class='color_blue'>lsegne(_t$1,t,[],P0)</span>
    [footprint
       <span class='color_blue'>(@f$0  &lt;=  8)</span> *
       <span class='color_blue'>#GB<src.c>$head = @f$1 <span class='color_orange'>rearrange:38</span>:node*</span>  ]
    where
    P0 = exists [_t$2]. <span class='color_blue'>_t$0|->{next:_t$1 <span class='color_orange'>update:56</span>, v:_t$2 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16</span></span>
    
    .... After Symbolic Execution ....
    PROP 1 of 2:
    <span class='color_blue'><span class='color_blue'>(@f$0  &lt;=  8)</span>; <span class='color_blue'>t != 0</span>; <span class='color_red'>MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(x)</span>; <span class='color_blue'>MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(_t$3)</span>; <span class='color_blue'>MEMma &lt; malloc:38 &gt;  <span class='color_orange'>{vpath: }</span>(_t$1)</span> ;
    <span class='color_blue'>x = <span class='color_red'>_t$4 <span class='color_orange'>update:45</span></span>:node*</span>; <span class='color_blue'>n = null <span class='color_orange'>update:40</span>:node*</span>; <span class='color_blue'>t = <span class='color_red'>_t$2 <span class='color_orange'>update:53</span></span>:node*</span>; <span class='color_blue'>#GB<src.c>$head = _t$1 <span class='color_orange'>update:38</span>:node*</span>; <span class='color_blue'>i = (@f$0 + 1) <span class='color_orange'>update:43</span>:int</span>; <span class='color_blue'>return = _t$0 <span class='color_orange'>initial</span>:int</span> ;
    <span class='color_red'>x|->{next:null <span class='color_orange'>update:46</span>, v:(@f$0 + 1) <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16</span>; <span class='color_blue'>_t$3|->{next:null <span class='color_orange'>update:46</span>, v:@f$0 <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16</span>; <span class='color_blue'>lsegne(t,_t$3,[],P0)</span>; <span class='color_blue'>lsegne(_t$1,t,[],P0)</span>
    [footprint
       <span class='color_red'>(@f$0  &lt;=  8)</span> *
       <span class='color_blue'>#GB<src.c>$head = @f$1 <span class='color_orange'>rearrange:38</span>:node*</span>  ]
    where
    P0 = exists [_t$2]. <span class='color_blue'>_t$0|->{next:_t$1 <span class='color_orange'>update:56</span>, v:_t$2 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16</span></span>
    PROP 2 of 2:
    <span class='color_blue'><span class='color_blue'>(@f$0  &lt;=  8)</span>; <span class='color_blue'>t != 0</span>; <span class='color_blue'>MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(x)</span>; <span class='color_blue'>MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(t)</span>; <span class='color_blue'>MEMma &lt; malloc:38 &gt;  <span class='color_orange'>{vpath: }</span>(_t$1)</span> ;
    <span class='color_blue'>x = <span class='color_red'>_t$3 <span class='color_orange'>update:45</span></span>:node*</span>; <span class='color_blue'>n = null <span class='color_orange'>update:40</span>:node*</span>; <span class='color_blue'>t = <span class='color_red'>_t$2 <span class='color_orange'>update:53</span></span>:node*</span>; <span class='color_blue'>#GB<src.c>$head = _t$1 <span class='color_orange'>update:38</span>:node*</span>; <span class='color_blue'>i = (@f$0 + 1) <span class='color_orange'>update:43</span>:int</span>; <span class='color_blue'>return = _t$0 <span class='color_orange'>initial</span>:int</span> ;
    <span class='color_blue'>x|->{next:null <span class='color_orange'>update:46</span>, v:(@f$0 + 1) <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16</span>; <span class='color_blue'>t|->{next:<span class='color_red'>null <span class='color_orange'>update:46</span></span>, v:<span class='color_red'>@f$0 <span class='color_orange'>update:47</span></span>} <span class='color_orange'>alloc</span>:node16</span>; <span class='color_blue'>lsegne(_t$1,t,[],P0)</span>
    [footprint
       <span class='color_red'>(@f$0  &lt;=  8)</span> *
       <span class='color_blue'>#GB<src.c>$head = @f$1 <span class='color_orange'>rearrange:38</span>:node*</span>  ]
    where
    P0 = exists [_t$2]. <span class='color_blue'>_t$0|->{next:_t$1 <span class='color_orange'>update:56</span>, v:_t$2 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16</span></span>
    
    
    
  Processing prop 2/2
    Instruction <span class='color_green'>n$17=*&amp;t:node* [line 54, column 21]</span>
    in vpath_find exp:n$1565
    vpath_find: found head : node*
    in vpath_find exp:n$1560
    vpath_find: found x : node*
    .... Rearrangement Start ....
    Exp: &amp;t
    Prop: 
    <span class='color_blue'>t != 0; MEMma &lt; malloc:38 &gt;  <span class='color_orange'>{vpath: }</span>(n$1565); MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(x) ;
    x = n$1560 <span class='color_orange'>update:45</span>:node*; n = n$1561 <span class='color_orange'>update:58</span>:node*; t = n$1563 <span class='color_orange'>update:53</span>:node*; #GB<src.c>$head = n$1565 <span class='color_orange'>update:38</span>:node*; i = 4 <span class='color_orange'>update:43</span>:int; return = n$1566 <span class='color_orange'>initial</span>:int ;
    n$1562|->{next:t <span class='color_orange'>update:56</span>, v:n$1564 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16; n|->{next:null <span class='color_orange'>update:46</span>, v:3 <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16; x|->{next:null <span class='color_orange'>update:46</span>, v:4 <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16; lsegne(n$1565,n$1562,[],P0); lseg(t,n,[],P0)
    [footprint
       @f$1 != 0 *
       #GB<src.c>$head = @f$0 <span class='color_orange'>rearrange:38</span>:node*  ]
    where
    P0 = exists [_t$2]. _t$0|->{next:_t$1 <span class='color_orange'>update:56</span>, v:_t$2 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16</span>
    
    in prop_iter_extend_ptsto lexp: &amp;t
    prop before:
    <span class='color_blue'>t != 0; MEMma &lt; malloc:38 &gt;  <span class='color_orange'>{vpath: }</span>(n$1565); MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(x) ;
    x = n$1560 <span class='color_orange'>update:45</span>:node*; n = n$1561 <span class='color_orange'>update:58</span>:node*; t = n$1563 <span class='color_orange'>update:53</span>:node*; #GB<src.c>$head = n$1565 <span class='color_orange'>update:38</span>:node*; i = 4 <span class='color_orange'>update:43</span>:int; return = n$1566 <span class='color_orange'>initial</span>:int ;
    n$1562|->{next:t <span class='color_orange'>update:56</span>, v:n$1564 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16; n|->{next:null <span class='color_orange'>update:46</span>, v:3 <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16; x|->{next:null <span class='color_orange'>update:46</span>, v:4 <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16; lsegne(n$1565,n$1562,[],P0); lseg(t,n,[],P0)
    [footprint
       @f$1 != 0 *
       #GB<src.c>$head = @f$0 <span class='color_orange'>rearrange:38</span>:node*  ]
    where
    P0 = exists [_t$2]. _t$0|->{next:_t$1 <span class='color_orange'>update:56</span>, v:_t$2 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16</span>
    
    
    prop list after:
    PROP 1 of 1:
    <span class='color_blue'><span class='color_blue'>t != 0</span>; <span class='color_blue'>MEMma &lt; malloc:38 &gt;  <span class='color_orange'>{vpath: }</span>(n$1565)</span>; <span class='color_blue'>MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(x)</span> ;
    <span class='color_blue'>x = n$1560 <span class='color_orange'>update:45</span>:node*</span>; <span class='color_blue'>n = n$1561 <span class='color_orange'>update:58</span>:node*</span>; <span class='color_blue'>t = n$1563 <span class='color_orange'>update:53</span>:node*</span>; <span class='color_blue'>#GB<src.c>$head = n$1565 <span class='color_orange'>update:38</span>:node*</span>; <span class='color_blue'>i = 4 <span class='color_orange'>update:43</span>:int</span>; <span class='color_blue'>return = n$1566 <span class='color_orange'>initial</span>:int</span> ;
    <span class='color_blue'>n$1562|->{next:t <span class='color_orange'>update:56</span>, v:n$1564 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16</span>; <span class='color_blue'>n|->{next:null <span class='color_orange'>update:46</span>, v:3 <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16</span>; <span class='color_blue'>x|->{next:null <span class='color_orange'>update:46</span>, v:4 <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16</span>; <span class='color_blue'>lsegne(n$1565,n$1562,[],P0)</span>; <span class='color_blue'>lseg(t,n,[],P0)</span>
    [footprint
       <span class='color_blue'>@f$1 != 0</span> *
       <span class='color_blue'>#GB<src.c>$head = @f$0 <span class='color_orange'>rearrange:38</span>:node*</span>  ]
    where
    P0 = exists [_t$2]. <span class='color_blue'>_t$0|->{next:_t$1 <span class='color_orange'>update:56</span>, v:_t$2 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16</span></span>
    
    
    
    Instruction Returns
    PROP 1 of 1:
    <span class='color_blue'><span class='color_red'>t != 0</span>; <span class='color_red'>MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(x)</span>; <span class='color_blue'>MEMma &lt; malloc:38 &gt;  <span class='color_orange'>{vpath: }</span>(_t$1)</span> ;
    <span class='color_blue'>x = <span class='color_red'>_t$5 <span class='color_orange'>update:45</span></span>:node*</span>; <span class='color_blue'>n = <span class='color_red'>_t$4 <span class='color_orange'>update:58</span></span>:node*</span>; <span class='color_blue'>t = <span class='color_red'>n$17 <span class='color_orange'>update:53</span></span>:node*</span>; <span class='color_blue'>#GB<src.c>$head = _t$1 <span class='color_orange'>update:38</span>:node*</span>; <span class='color_blue'>i = 4 <span class='color_orange'>update:43</span>:int</span>; <span class='color_blue'>return = _t$0 <span class='color_orange'>initial</span>:int</span> ;
    <span class='color_blue'>x|->{next:null <span class='color_orange'>update:46</span>, v:<span class='color_red'>4 <span class='color_orange'>update:47</span></span>} <span class='color_orange'>alloc</span>:node16</span>; <span class='color_red'>n|->{next:null <span class='color_orange'>update:46</span>, v:3 <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16</span>; <span class='color_blue'>_t$2|->{next:<span class='color_red'>t <span class='color_orange'>update:56</span></span>, v:<span class='color_red'>_t$3 <span class='color_orange'>alloc</span></span>} <span class='color_orange'>alloc</span>:node16</span>; <span class='color_blue'>lsegne(_t$1,_t$2,[],P0)</span>; <span class='color_red'>lseg(t,n,[],P0)</span>
    [footprint
       <span class='color_blue'>@f$1 != 0</span> *
       <span class='color_blue'>#GB<src.c>$head = @f$0 <span class='color_orange'>rearrange:38</span>:node*</span>  ]
    where
    P0 = exists [_t$2]. <span class='color_blue'>_t$0|->{next:_t$1 <span class='color_orange'>update:56</span>, v:_t$2 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16</span></span>
    
    Instruction <span class='color_green'>n$18=*n$17.v:int [line 54, column 21]</span>
    in vpath_find exp:n$1571
    vpath_find: found head : node*
    in vpath_find exp:n$1567
    vpath_find: found x : node*
    .... Rearrangement Start ....
    Exp: n$17.v
    Prop: 
    <span class='color_blue'>t != 0; MEMma &lt; malloc:38 &gt;  <span class='color_orange'>{vpath: }</span>(n$1571); MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(x) ;
    x = n$1567 <span class='color_orange'>update:45</span>:node*; n = n$1568 <span class='color_orange'>update:58</span>:node*; t = n$17 <span class='color_orange'>update:53</span>:node*; #GB<src.c>$head = n$1571 <span class='color_orange'>update:38</span>:node*; i = 4 <span class='color_orange'>update:43</span>:int; return = n$1572 <span class='color_orange'>initial</span>:int ;
    n$1569|->{next:t <span class='color_orange'>update:56</span>, v:n$1570 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16; n|->{next:null <span class='color_orange'>update:46</span>, v:3 <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16; x|->{next:null <span class='color_orange'>update:46</span>, v:4 <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16; lsegne(n$1571,n$1569,[],P0); lseg(t,n,[],P0)
    [footprint
       @f$1 != 0 *
       #GB<src.c>$head = @f$0 <span class='color_orange'>rearrange:38</span>:node*  ]
    where
    P0 = exists [_t$2]. _t$0|->{next:_t$1 <span class='color_orange'>update:56</span>, v:_t$2 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16</span>
    
    in prop_iter_extend_ptsto lexp: n$17.v
    prop before:
    <span class='color_blue'>t != 0; MEMma &lt; malloc:38 &gt;  <span class='color_orange'>{vpath: }</span>(n$1571); MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(x) ;
    x = n$1567 <span class='color_orange'>update:45</span>:node*; n = n$1568 <span class='color_orange'>update:58</span>:node*; t = n$17 <span class='color_orange'>update:53</span>:node*; #GB<src.c>$head = n$1571 <span class='color_orange'>update:38</span>:node*; i = 4 <span class='color_orange'>update:43</span>:int; return = n$1572 <span class='color_orange'>initial</span>:int ;
    n$1569|->{next:t <span class='color_orange'>update:56</span>, v:n$1570 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16; n|->{next:null <span class='color_orange'>update:46</span>, v:3 <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16; x|->{next:null <span class='color_orange'>update:46</span>, v:4 <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16; t|->{next:_t$2857 <span class='color_orange'>update:56</span>, v:_t$2858 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16; lsegne(n$1571,n$1569,[],P0); lseg(_t$2857,n,[],P0)
    [footprint
       @f$1 != 0 *
       #GB<src.c>$head = @f$0 <span class='color_orange'>rearrange:38</span>:node*  ]
    where
    P0 = exists [_t$2]. _t$0|->{next:_t$1 <span class='color_orange'>update:56</span>, v:_t$2 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16</span>
    
    
    prop list after:
    PROP 1 of 1:
    <span class='color_blue'><span class='color_blue'>t != 0</span>; <span class='color_blue'>MEMma &lt; malloc:38 &gt;  <span class='color_orange'>{vpath: }</span>(n$1571)</span>; <span class='color_blue'>MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(x)</span> ;
    <span class='color_blue'>x = n$1567 <span class='color_orange'>update:45</span>:node*</span>; <span class='color_blue'>n = n$1568 <span class='color_orange'>update:58</span>:node*</span>; <span class='color_blue'>t = n$17 <span class='color_orange'>update:53</span>:node*</span>; <span class='color_blue'>#GB<src.c>$head = n$1571 <span class='color_orange'>update:38</span>:node*</span>; <span class='color_blue'>i = 4 <span class='color_orange'>update:43</span>:int</span>; <span class='color_blue'>return = n$1572 <span class='color_orange'>initial</span>:int</span> ;
    <span class='color_blue'>n$1569|->{next:t <span class='color_orange'>update:56</span>, v:n$1570 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16</span>; <span class='color_blue'>n|->{next:null <span class='color_orange'>update:46</span>, v:3 <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16</span>; <span class='color_blue'>x|->{next:null <span class='color_orange'>update:46</span>, v:4 <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16</span>; <span class='color_blue'>t|->{next:_t$2857 <span class='color_orange'>update:56</span>, v:_t$2858 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16</span>; <span class='color_blue'>lsegne(n$1571,n$1569,[],P0)</span>; <span class='color_blue'>lseg(_t$2857,n,[],P0)</span>
    [footprint
       <span class='color_blue'>@f$1 != 0</span> *
       <span class='color_blue'>#GB<src.c>$head = @f$0 <span class='color_orange'>rearrange:38</span>:node*</span>  ]
    where
    P0 = exists [_t$2]. <span class='color_blue'>_t$0|->{next:_t$1 <span class='color_orange'>update:56</span>, v:_t$2 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16</span></span>
    
    
    
    in prop_iter_extend_ptsto lexp: n$17.v
    prop before:
    <span class='color_blue'>n$1568 = t ;
    t != 0; MEMma &lt; malloc:38 &gt;  <span class='color_orange'>{vpath: }</span>(n$1571); MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(x) ;
    x = n$1567 <span class='color_orange'>update:45</span>:node*; n = n$17 <span class='color_orange'>update:58</span>:node*; t = n$17 <span class='color_orange'>update:53</span>:node*; #GB<src.c>$head = n$1571 <span class='color_orange'>update:38</span>:node*; i = 4 <span class='color_orange'>update:43</span>:int; return = n$1572 <span class='color_orange'>initial</span>:int ;
    n$1569|->{next:t <span class='color_orange'>update:56</span>, v:n$1570 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16; x|->{next:null <span class='color_orange'>update:46</span>, v:4 <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16; t|->{next:null <span class='color_orange'>update:46</span>, v:3 <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16; lsegne(n$1571,n$1569,[],P0)
    [footprint
       n$1568 = t; @f$1 != 0 *
       #GB<src.c>$head = @f$0 <span class='color_orange'>rearrange:38</span>:node*  ]
    where
    P0 = exists [_t$2]. _t$0|->{next:_t$1 <span class='color_orange'>update:56</span>, v:_t$2 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16</span>
    
    
    prop list after:
    PROP 1 of 1:
    <span class='color_blue'><span class='color_blue'>n$1568 = t</span> ;
    <span class='color_blue'>t != 0</span>; <span class='color_blue'>MEMma &lt; malloc:38 &gt;  <span class='color_orange'>{vpath: }</span>(n$1571)</span>; <span class='color_blue'>MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(x)</span> ;
    <span class='color_blue'>x = n$1567 <span class='color_orange'>update:45</span>:node*</span>; <span class='color_blue'>n = n$17 <span class='color_orange'>update:58</span>:node*</span>; <span class='color_blue'>t = n$17 <span class='color_orange'>update:53</span>:node*</span>; <span class='color_blue'>#GB<src.c>$head = n$1571 <span class='color_orange'>update:38</span>:node*</span>; <span class='color_blue'>i = 4 <span class='color_orange'>update:43</span>:int</span>; <span class='color_blue'>return = n$1572 <span class='color_orange'>initial</span>:int</span> ;
    <span class='color_blue'>n$1569|->{next:t <span class='color_orange'>update:56</span>, v:n$1570 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16</span>; <span class='color_blue'>x|->{next:null <span class='color_orange'>update:46</span>, v:4 <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16</span>; <span class='color_blue'>t|->{next:null <span class='color_orange'>update:46</span>, v:3 <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16</span>; <span class='color_blue'>lsegne(n$1571,n$1569,[],P0)</span>
    [footprint
       <span class='color_blue'>n$1568 = t</span>; <span class='color_blue'>@f$1 != 0</span> *
       <span class='color_blue'>#GB<src.c>$head = @f$0 <span class='color_orange'>rearrange:38</span>:node*</span>  ]
    where
    P0 = exists [_t$2]. <span class='color_blue'>_t$0|->{next:_t$1 <span class='color_orange'>update:56</span>, v:_t$2 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16</span></span>
    
    
    
    Instruction Returns
    PROP 1 of 2:
    <span class='color_blue'><span class='color_blue'>t != 0</span>; <span class='color_red'>MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(x)</span>; <span class='color_blue'>MEMma &lt; malloc:38 &gt;  <span class='color_orange'>{vpath: }</span>(_t$1)</span>; <span class='color_red'>DANGL &lt; UNINIT &gt; (n$18)</span> ;
    <span class='color_blue'>x = <span class='color_red'>_t$6 <span class='color_orange'>update:45</span></span>:node*</span>; <span class='color_blue'>n = <span class='color_red'>_t$5 <span class='color_orange'>update:58</span></span>:node*</span>; <span class='color_blue'>t = n$17 <span class='color_orange'>update:53</span>:node*</span>; <span class='color_blue'>#GB<src.c>$head = _t$1 <span class='color_orange'>update:38</span>:node*</span>; <span class='color_blue'>i = 4 <span class='color_orange'>update:43</span>:int</span>; <span class='color_blue'>return = _t$0 <span class='color_orange'>initial</span>:int</span> ;
    <span class='color_red'>x|->{next:null <span class='color_orange'>update:46</span>, v:4 <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16</span>; <span class='color_blue'>n|->{next:null <span class='color_orange'>update:46</span>, v:<span class='color_red'>3 <span class='color_orange'>update:47</span></span>} <span class='color_orange'>alloc</span>:node16</span>; <span class='color_blue'>_t$2|->{next:t <span class='color_orange'>update:56</span>, v:_t$3 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16</span>; <span class='color_blue'>t|->{next:_t$4 <span class='color_orange'>update:56</span>, v:n$18 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16</span>; <span class='color_blue'>lsegne(_t$1,_t$2,[],P0)</span>; <span class='color_blue'>lseg(_t$4,n,[],P0)</span>
    [footprint
       <span class='color_blue'>@f$1 != 0</span> *
       <span class='color_blue'>#GB<src.c>$head = @f$0 <span class='color_orange'>rearrange:38</span>:node*</span>  ]
    where
    P0 = exists [_t$2]. <span class='color_blue'>_t$0|->{next:_t$1 <span class='color_orange'>update:56</span>, v:_t$2 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16</span></span>
    PROP 2 of 2:
    <span class='color_blue'><span class='color_red'>n$18 = 3</span> ;
    <span class='color_blue'>t != 0</span>; <span class='color_red'>MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(x)</span>; <span class='color_blue'>MEMma &lt; malloc:38 &gt;  <span class='color_orange'>{vpath: }</span>(_t$1)</span> ;
    <span class='color_blue'>x = <span class='color_red'>_t$4 <span class='color_orange'>update:45</span></span>:node*</span>; <span class='color_blue'>n = <span class='color_red'>n$17 <span class='color_orange'>update:58</span></span>:node*</span>; <span class='color_blue'>t = n$17 <span class='color_orange'>update:53</span>:node*</span>; <span class='color_blue'>#GB<src.c>$head = _t$1 <span class='color_orange'>update:38</span>:node*</span>; <span class='color_blue'>i = 4 <span class='color_orange'>update:43</span>:int</span>; <span class='color_blue'>return = _t$0 <span class='color_orange'>initial</span>:int</span> ;
    <span class='color_blue'>x|->{next:null <span class='color_orange'>update:46</span>, v:<span class='color_red'>4 <span class='color_orange'>update:47</span></span>} <span class='color_orange'>alloc</span>:node16</span>; <span class='color_blue'>_t$2|->{next:t <span class='color_orange'>update:56</span>, v:_t$3 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16</span>; <span class='color_blue'>t|->{next:null <span class='color_orange'>update:46</span>, v:3 <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16</span>; <span class='color_blue'>lsegne(_t$1,_t$2,[],P0)</span>
    [footprint
       <span class='color_red'>t = @f$1</span>; <span class='color_red'>@f$2 != 0</span> *
       <span class='color_blue'>#GB<src.c>$head = @f$0 <span class='color_orange'>rearrange:38</span>:node*</span>  ]
    where
    P0 = exists [_t$2]. <span class='color_blue'>_t$0|->{next:_t$1 <span class='color_orange'>update:56</span>, v:_t$2 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16</span></span>
    
    Instruction <span class='color_green'>n$19=_fun_printf("%d\n":char const *,n$18:int) [line 54, column 7]</span>
    in vpath_find exp:n$1578
    vpath_find: found head : node*
    in vpath_find exp:n$1573
    vpath_find: found x : node*
    <span class='color_orange'>WARNING: likely use of variable-arguments function, or function prototype missing</span>
    actual parameters: n$18
    formal parameters: 
    Found 1 specs for function printf
    START EXECUTING SPECS FOR printf from state
    <span class='color_blue'>t != 0; MEMma &lt; malloc:38 &gt;  <span class='color_orange'>{vpath: }</span>(n$1578); MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(x); DANGL &lt; UNINIT &gt; (n$18) ;
    x = n$1573 <span class='color_orange'>update:45</span>:node*; n = n$1574 <span class='color_orange'>update:58</span>:node*; t = n$17 <span class='color_orange'>update:53</span>:node*; #GB<src.c>$head = n$1578 <span class='color_orange'>update:38</span>:node*; i = 4 <span class='color_orange'>update:43</span>:int; return = n$1579 <span class='color_orange'>initial</span>:int ;
    n$1575|->{next:t <span class='color_orange'>update:56</span>, v:n$1576 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16; n|->{next:null <span class='color_orange'>update:46</span>, v:3 <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16; x|->{next:null <span class='color_orange'>update:46</span>, v:4 <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16; t|->{next:n$1577 <span class='color_orange'>update:56</span>, v:n$18 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16; lsegne(n$1578,n$1575,[],P0); lseg(n$1577,n,[],P0)
    [footprint
       @f$1 != 0 *
       #GB<src.c>$head = @f$0 <span class='color_orange'>rearrange:38</span>:node*  ]
    where
    P0 = exists [_t$2]. _t$0|->{next:_t$1 <span class='color_orange'>update:56</span>, v:_t$2 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16</span>
    <span class='color_orange'>WARNING: more actual pars than formal pars in fun call (2 vs 1)</span>
    EXECUTING SPEC 1/1
    ACTUAL PRECONDITION =
      <span class='color_blue'>t != 0; MEMma &lt; malloc:38 &gt;  <span class='color_orange'>{vpath: }</span>(n$1578); MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(x); DANGL &lt; UNINIT &gt; (n$18) ;
      x = n$1573 <span class='color_orange'>update:45</span>:node*; n = n$1574 <span class='color_orange'>update:58</span>:node*; t = n$17 <span class='color_orange'>update:53</span>:node*; #GB<src.c>$head = n$1578 <span class='color_orange'>update:38</span>:node*; i = 4 <span class='color_orange'>update:43</span>:int; format|callee = "%d\n" <span class='color_orange'>actual_precondition</span>:char const *; return = n$1579 <span class='color_orange'>initial</span>:int ;
      n$1575|->{next:t <span class='color_orange'>update:56</span>, v:n$1576 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16; n|->{next:null <span class='color_orange'>update:46</span>, v:3 <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16; x|->{next:null <span class='color_orange'>update:46</span>, v:4 <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16; t|->{next:n$1577 <span class='color_orange'>update:56</span>, v:n$18 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16; lsegne(n$1578,n$1575,[],P0); lseg(n$1577,n,[],P0)
      [footprint
         @f$1 != 0 *
         #GB<src.c>$head = @f$0 <span class='color_orange'>rearrange:38</span>:node*  ]
      where
      P0 = exists [_t$2]. _t$0|->{next:_t$1 <span class='color_orange'>update:56</span>, v:_t$2 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16</span>
    SPEC =
      --------------------------- ---------- ---------------------------
      PRE:
      <span class='color_blue'><span class='color_blue'>format|callee = _t$2873 <span class='color_orange'>formal</span>:char const *</span></span>
      POST 1 of 1:
      <span class='color_blue'><span class='color_red'>(-1  &lt;  _t$2874)</span>; <span class='color_red'>DANGL &lt; UNINIT &gt; (return|callee)</span> ;
      <span class='color_red'>return|callee = _t$2874 <span class='color_orange'>update:1114</span>:int</span></span>
      ----------------------------------------------------------------
    pre_check_pure_implication
    pi1:
      n$17 != 0; MEMma &lt; malloc:38 &gt;  <span class='color_orange'>{vpath: }</span>(n$1578); MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(n$1573); DANGL &lt; UNINIT &gt; (n$18)
    pi2:
      
    returns
    sub1: 
      
    sub2: 
      
    Current Implication
    SUB:
      
    <span class='color_blue'>t != 0; MEMma &lt; malloc:38 &gt;  <span class='color_orange'>{vpath: }</span>(n$1578); MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(x); DANGL &lt; UNINIT &gt; (n$18) ;
    x = n$1573 <span class='color_orange'>update:45</span>:node*; n = n$1574 <span class='color_orange'>update:58</span>:node*; t = n$17 <span class='color_orange'>update:53</span>:node*; #GB<src.c>$head = n$1578 <span class='color_orange'>update:38</span>:node*; i = 4 <span class='color_orange'>update:43</span>:int; format|callee = "%d\n" <span class='color_orange'>actual_precondition</span>:char const *; return = n$1579 <span class='color_orange'>initial</span>:int ;
    n$1575|->{next:t <span class='color_orange'>update:56</span>, v:n$1576 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16; n|->{next:null <span class='color_orange'>update:46</span>, v:3 <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16; x|->{next:null <span class='color_orange'>update:46</span>, v:4 <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16; t|->{next:n$1577 <span class='color_orange'>update:56</span>, v:n$18 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16; lsegne(n$1578,n$1575,[],P0); lseg(n$1577,n,[],P0)
    [footprint
       @f$1 != 0 *
       #GB<src.c>$head = @f$0 <span class='color_orange'>rearrange:38</span>:node*  ]
    where
    P0 = exists [_t$2]. _t$0|->{next:_t$1 <span class='color_orange'>update:56</span>, v:_t$2 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16</span>
    |-
    <span class='color_blue'>format|callee = _t$2873 <span class='color_orange'>formal</span>:char const *</span>
    
      do_imply "%d\n" _t$2873
        Final Implication
        SUB:
          
        <span class='color_blue'>t != 0; MEMma &lt; malloc:38 &gt;  <span class='color_orange'>{vpath: }</span>(n$1578); MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(x); DANGL &lt; UNINIT &gt; (n$18) ;
        x = n$1573 <span class='color_orange'>update:45</span>:node*; n = n$1574 <span class='color_orange'>update:58</span>:node*; t = n$17 <span class='color_orange'>update:53</span>:node*; #GB<src.c>$head = n$1578 <span class='color_orange'>update:38</span>:node*; i = 4 <span class='color_orange'>update:43</span>:int; return = n$1579 <span class='color_orange'>initial</span>:int ;
        n$1575|->{next:t <span class='color_orange'>update:56</span>, v:n$1576 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16; n|->{next:null <span class='color_orange'>update:46</span>, v:3 <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16; x|->{next:null <span class='color_orange'>update:46</span>, v:4 <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16; t|->{next:n$1577 <span class='color_orange'>update:56</span>, v:n$18 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16; lsegne(n$1578,n$1575,[],P0); lseg(n$1577,n,[],P0)
        [footprint
           @f$1 != 0 *
           #GB<src.c>$head = @f$0 <span class='color_orange'>rearrange:38</span>:node*  ]
        where
        P0 = exists [_t$2]. _t$0|->{next:_t$1 <span class='color_orange'>update:56</span>, v:_t$2 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16</span>
        [SUB: 
          _t$2873 = "%d\n"]
        |-
        <span class='color_blue'></span>
    Result of Abduction
      SUB:
        
      <span class='color_blue'>t != 0; MEMma &lt; malloc:38 &gt;  <span class='color_orange'>{vpath: }</span>(n$1578); MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(x); DANGL &lt; UNINIT &gt; (n$18) ;
      x = n$1573 <span class='color_orange'>update:45</span>:node*; n = n$1574 <span class='color_orange'>update:58</span>:node*; t = n$17 <span class='color_orange'>update:53</span>:node*; #GB<src.c>$head = n$1578 <span class='color_orange'>update:38</span>:node*; i = 4 <span class='color_orange'>update:43</span>:int; format|callee = "%d\n" <span class='color_orange'>actual_precondition</span>:char const *; return = n$1579 <span class='color_orange'>initial</span>:int ;
      n$1575|->{next:t <span class='color_orange'>update:56</span>, v:n$1576 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16; n|->{next:null <span class='color_orange'>update:46</span>, v:3 <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16; x|->{next:null <span class='color_orange'>update:46</span>, v:4 <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16; t|->{next:n$1577 <span class='color_orange'>update:56</span>, v:n$18 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16; lsegne(n$1578,n$1575,[],P0); lseg(n$1577,n,[],P0)
      [footprint
         @f$1 != 0 *
         #GB<src.c>$head = @f$0 <span class='color_orange'>rearrange:38</span>:node*  ]
      where
      P0 = exists [_t$2]. _t$0|->{next:_t$1 <span class='color_orange'>update:56</span>, v:_t$2 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16</span>
      [SUB: 
        _t$2873 = "%d\n"]
      |-
      <span class='color_blue'>format|callee = "%d\n" <span class='color_orange'>formal</span>:char const *</span>
    returning TRUE
      New footprint:
      
      Frame fld:
      
      Missing fld:
      
      Instantiated frame:
      n$1575|->{next:n$17 <span class='color_orange'>update:56</span>, v:n$1576 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16; n$1574|->{next:null <span class='color_orange'>update:46</span>, v:3 <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16; n$1573|->{next:null <span class='color_orange'>update:46</span>, v:4 <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16; n$17|->{next:n$1577 <span class='color_orange'>update:56</span>, v:n$18 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16; &amp;x|->n$1573 <span class='color_orange'>update:45</span>:node*; &amp;n|->n$1574 <span class='color_orange'>update:58</span>:node*; &amp;t|->n$17 <span class='color_orange'>update:53</span>:node*; &amp;#GB<src.c>$head|->n$1578 <span class='color_orange'>update:38</span>:node*; &amp;i|->4 <span class='color_orange'>update:43</span>:int; &amp;return|->n$1579 <span class='color_orange'>initial</span>:int; lsegne(n$1578,n$1575,[],lam [_t$0,_t$1,]. exists [_t$2]. _t$0|->{next:_t$1 <span class='color_orange'>update:56</span>, v:_t$2 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16); lseg(n$1577,n$1574,[],lam [_t$0,_t$1,]. exists [_t$2]. _t$0|->{next:_t$1 <span class='color_orange'>update:56</span>, v:_t$2 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16)
      Instantiated post:
      PROP 1 of 1:
      <span class='color_blue'><span class='color_red'>(-1  &lt;  _t$2874)</span>; <span class='color_red'>DANGL &lt; UNINIT &gt; (return|callee)</span> ;
      <span class='color_red'>return|callee = _t$2874 <span class='color_orange'>update:54</span>:int</span></span>
      
    ***** RESULTS FUNCTION CALL *******
    PROP 1 of 1:
    <span class='color_blue'><span class='color_red'>(-1  &lt;  n$19)</span>; <span class='color_blue'>t != 0</span>; <span class='color_blue'>MEMma &lt; malloc:38 &gt;  <span class='color_orange'>{vpath: }</span>(n$1578)</span>; <span class='color_blue'>MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(x)</span>; <span class='color_red'>DANGL &lt; UNINIT &gt; (n$19)</span>; <span class='color_blue'>DANGL &lt; UNINIT &gt; (n$18)</span> ;
    <span class='color_blue'>x = n$1573 <span class='color_orange'>update:45</span>:node*</span>; <span class='color_blue'>n = n$1574 <span class='color_orange'>update:58</span>:node*</span>; <span class='color_blue'>t = n$17 <span class='color_orange'>update:53</span>:node*</span>; <span class='color_blue'>#GB<src.c>$head = n$1578 <span class='color_orange'>update:38</span>:node*</span>; <span class='color_blue'>i = 4 <span class='color_orange'>update:43</span>:int</span>; <span class='color_blue'>return = n$1579 <span class='color_orange'>initial</span>:int</span> ;
    <span class='color_blue'>n$1575|->{next:t <span class='color_orange'>update:56</span>, v:n$1576 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16</span>; <span class='color_blue'>n|->{next:null <span class='color_orange'>update:46</span>, v:3 <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16</span>; <span class='color_blue'>x|->{next:null <span class='color_orange'>update:46</span>, v:4 <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16</span>; <span class='color_blue'>t|->{next:n$1577 <span class='color_orange'>update:56</span>, v:n$18 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16</span>; <span class='color_blue'>lsegne(n$1578,n$1575,[],P0)</span>; <span class='color_blue'>lseg(n$1577,n,[],P0)</span>
    [footprint
       <span class='color_blue'>@f$1 != 0</span> *
       <span class='color_blue'>#GB<src.c>$head = @f$0 <span class='color_orange'>rearrange:38</span>:node*</span>  ]
    where
    P0 = exists [_t$2]. <span class='color_blue'>_t$0|->{next:_t$1 <span class='color_orange'>update:56</span>, v:_t$2 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16</span></span>
    ***** END RESULTS FUNCTION CALL *******
    Instruction Returns
    PROP 1 of 1:
    <span class='color_blue'><span class='color_red'>(-1  &lt;  n$19)</span>; <span class='color_blue'>t != 0</span>; <span class='color_blue'>MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(x)</span>; <span class='color_blue'>MEMma &lt; malloc:38 &gt;  <span class='color_orange'>{vpath: }</span>(_t$1)</span>; <span class='color_red'>DANGL &lt; UNINIT &gt; (n$19)</span>; <span class='color_blue'>DANGL &lt; UNINIT &gt; (n$18)</span> ;
    <span class='color_blue'>x = _t$6 <span class='color_orange'>update:45</span>:node*</span>; <span class='color_blue'>n = _t$5 <span class='color_orange'>update:58</span>:node*</span>; <span class='color_blue'>t = n$17 <span class='color_orange'>update:53</span>:node*</span>; <span class='color_blue'>#GB<src.c>$head = _t$1 <span class='color_orange'>update:38</span>:node*</span>; <span class='color_blue'>i = 4 <span class='color_orange'>update:43</span>:int</span>; <span class='color_blue'>return = _t$0 <span class='color_orange'>initial</span>:int</span> ;
    <span class='color_blue'>x|->{next:null <span class='color_orange'>update:46</span>, v:4 <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16</span>; <span class='color_blue'>n|->{next:null <span class='color_orange'>update:46</span>, v:3 <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16</span>; <span class='color_blue'>_t$2|->{next:t <span class='color_orange'>update:56</span>, v:_t$3 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16</span>; <span class='color_blue'>t|->{next:_t$4 <span class='color_orange'>update:56</span>, v:n$18 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16</span>; <span class='color_blue'>lsegne(_t$1,_t$2,[],P0)</span>; <span class='color_blue'>lseg(_t$4,n,[],P0)</span>
    [footprint
       <span class='color_blue'>@f$1 != 0</span> *
       <span class='color_blue'>#GB<src.c>$head = @f$0 <span class='color_orange'>rearrange:38</span>:node*</span>  ]
    where
    P0 = exists [_t$2]. <span class='color_blue'>_t$0|->{next:_t$1 <span class='color_orange'>update:56</span>, v:_t$2 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16</span></span>
    
    Instruction <span class='color_green'>n$19=_fun_printf("%d\n":char const *,n$18:int) [line 54, column 7]</span>
    in vpath_find exp:n$1583
    vpath_find: found head : node*
    in vpath_find exp:n$1580
    vpath_find: found x : node*
    <span class='color_orange'>WARNING: likely use of variable-arguments function, or function prototype missing</span>
    actual parameters: 3
    formal parameters: 
    Found 1 specs for function printf
    START EXECUTING SPECS FOR printf from state
    <span class='color_blue'>n$18 = 3 ;
    t != 0; MEMma &lt; malloc:38 &gt;  <span class='color_orange'>{vpath: }</span>(n$1583); MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(x) ;
    x = n$1580 <span class='color_orange'>update:45</span>:node*; n = n$17 <span class='color_orange'>update:58</span>:node*; t = n$17 <span class='color_orange'>update:53</span>:node*; #GB<src.c>$head = n$1583 <span class='color_orange'>update:38</span>:node*; i = 4 <span class='color_orange'>update:43</span>:int; return = n$1584 <span class='color_orange'>initial</span>:int ;
    n$1581|->{next:t <span class='color_orange'>update:56</span>, v:n$1582 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16; x|->{next:null <span class='color_orange'>update:46</span>, v:4 <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16; t|->{next:null <span class='color_orange'>update:46</span>, v:3 <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16; lsegne(n$1583,n$1581,[],P0)
    [footprint
       t = @f$1; @f$2 != 0 *
       #GB<src.c>$head = @f$0 <span class='color_orange'>rearrange:38</span>:node*  ]
    where
    P0 = exists [_t$2]. _t$0|->{next:_t$1 <span class='color_orange'>update:56</span>, v:_t$2 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16</span>
    <span class='color_orange'>WARNING: more actual pars than formal pars in fun call (2 vs 1)</span>
    EXECUTING SPEC 1/1
    ACTUAL PRECONDITION =
      <span class='color_blue'>n$18 = 3 ;
      t != 0; MEMma &lt; malloc:38 &gt;  <span class='color_orange'>{vpath: }</span>(n$1583); MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(x) ;
      x = n$1580 <span class='color_orange'>update:45</span>:node*; n = n$17 <span class='color_orange'>update:58</span>:node*; t = n$17 <span class='color_orange'>update:53</span>:node*; #GB<src.c>$head = n$1583 <span class='color_orange'>update:38</span>:node*; i = 4 <span class='color_orange'>update:43</span>:int; format|callee = "%d\n" <span class='color_orange'>actual_precondition</span>:char const *; return = n$1584 <span class='color_orange'>initial</span>:int ;
      n$1581|->{next:t <span class='color_orange'>update:56</span>, v:n$1582 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16; x|->{next:null <span class='color_orange'>update:46</span>, v:4 <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16; t|->{next:null <span class='color_orange'>update:46</span>, v:3 <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16; lsegne(n$1583,n$1581,[],P0)
      [footprint
         t = @f$1; @f$2 != 0 *
         #GB<src.c>$head = @f$0 <span class='color_orange'>rearrange:38</span>:node*  ]
      where
      P0 = exists [_t$2]. _t$0|->{next:_t$1 <span class='color_orange'>update:56</span>, v:_t$2 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16</span>
    SPEC =
      --------------------------- ---------- ---------------------------
      PRE:
      <span class='color_blue'><span class='color_blue'>format|callee = _t$2882 <span class='color_orange'>formal</span>:char const *</span></span>
      POST 1 of 1:
      <span class='color_blue'><span class='color_red'>(-1  &lt;  _t$2883)</span>; <span class='color_red'>DANGL &lt; UNINIT &gt; (return|callee)</span> ;
      <span class='color_red'>return|callee = _t$2883 <span class='color_orange'>update:1114</span>:int</span></span>
      ----------------------------------------------------------------
    pre_check_pure_implication
    pi1:
      n$18 = 3; n$17 != 0; MEMma &lt; malloc:38 &gt;  <span class='color_orange'>{vpath: }</span>(n$1583); MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(n$1580)
    pi2:
      
    returns
    sub1: 
      n$18 = 3
    sub2: 
      n$18 = 3
    Current Implication
    SUB:
      n$18 = 3
    <span class='color_blue'>t != 0; MEMma &lt; malloc:38 &gt;  <span class='color_orange'>{vpath: }</span>(n$1583); MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(x); 3 = 3 ;
    x = n$1580 <span class='color_orange'>update:45</span>:node*; n = n$17 <span class='color_orange'>update:58</span>:node*; t = n$17 <span class='color_orange'>update:53</span>:node*; #GB<src.c>$head = n$1583 <span class='color_orange'>update:38</span>:node*; i = 4 <span class='color_orange'>update:43</span>:int; format|callee = "%d\n" <span class='color_orange'>actual_precondition</span>:char const *; return = n$1584 <span class='color_orange'>initial</span>:int ;
    n$1581|->{next:t <span class='color_orange'>update:56</span>, v:n$1582 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16; x|->{next:null <span class='color_orange'>update:46</span>, v:4 <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16; t|->{next:null <span class='color_orange'>update:46</span>, v:3 <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16; lsegne(n$1583,n$1581,[],P0)
    [footprint
       t = @f$1; @f$2 != 0 *
       #GB<src.c>$head = @f$0 <span class='color_orange'>rearrange:38</span>:node*  ]
    where
    P0 = exists [_t$2]. _t$0|->{next:_t$1 <span class='color_orange'>update:56</span>, v:_t$2 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16</span>
    [SUB: 
      n$18 = 3]
    |-
    <span class='color_blue'>format|callee = _t$2882 <span class='color_orange'>formal</span>:char const *</span>
    
      do_imply "%d\n" _t$2882
        Final Implication
        SUB:
          n$18 = 3
        <span class='color_blue'>t != 0; MEMma &lt; malloc:38 &gt;  <span class='color_orange'>{vpath: }</span>(n$1583); MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(x); 3 = 3 ;
        x = n$1580 <span class='color_orange'>update:45</span>:node*; n = n$17 <span class='color_orange'>update:58</span>:node*; t = n$17 <span class='color_orange'>update:53</span>:node*; #GB<src.c>$head = n$1583 <span class='color_orange'>update:38</span>:node*; i = 4 <span class='color_orange'>update:43</span>:int; return = n$1584 <span class='color_orange'>initial</span>:int ;
        n$1581|->{next:t <span class='color_orange'>update:56</span>, v:n$1582 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16; x|->{next:null <span class='color_orange'>update:46</span>, v:4 <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16; t|->{next:null <span class='color_orange'>update:46</span>, v:3 <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16; lsegne(n$1583,n$1581,[],P0)
        [footprint
           t = @f$1; @f$2 != 0 *
           #GB<src.c>$head = @f$0 <span class='color_orange'>rearrange:38</span>:node*  ]
        where
        P0 = exists [_t$2]. _t$0|->{next:_t$1 <span class='color_orange'>update:56</span>, v:_t$2 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16</span>
        [SUB: 
          n$18 = 3; _t$2882 = "%d\n"]
        |-
        <span class='color_blue'></span>
    Result of Abduction
      SUB:
        n$18 = 3
      <span class='color_blue'>t != 0; MEMma &lt; malloc:38 &gt;  <span class='color_orange'>{vpath: }</span>(n$1583); MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(x); 3 = 3 ;
      x = n$1580 <span class='color_orange'>update:45</span>:node*; n = n$17 <span class='color_orange'>update:58</span>:node*; t = n$17 <span class='color_orange'>update:53</span>:node*; #GB<src.c>$head = n$1583 <span class='color_orange'>update:38</span>:node*; i = 4 <span class='color_orange'>update:43</span>:int; format|callee = "%d\n" <span class='color_orange'>actual_precondition</span>:char const *; return = n$1584 <span class='color_orange'>initial</span>:int ;
      n$1581|->{next:t <span class='color_orange'>update:56</span>, v:n$1582 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16; x|->{next:null <span class='color_orange'>update:46</span>, v:4 <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16; t|->{next:null <span class='color_orange'>update:46</span>, v:3 <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16; lsegne(n$1583,n$1581,[],P0)
      [footprint
         t = @f$1; @f$2 != 0 *
         #GB<src.c>$head = @f$0 <span class='color_orange'>rearrange:38</span>:node*  ]
      where
      P0 = exists [_t$2]. _t$0|->{next:_t$1 <span class='color_orange'>update:56</span>, v:_t$2 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16</span>
      [SUB: 
        n$18 = 3; _t$2882 = "%d\n"]
      |-
      <span class='color_blue'>format|callee = "%d\n" <span class='color_orange'>formal</span>:char const *</span>
    returning TRUE
      New footprint:
      
      Frame fld:
      
      Missing fld:
      
      Instantiated frame:
      n$1581|->{next:n$17 <span class='color_orange'>update:56</span>, v:n$1582 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16; n$1580|->{next:null <span class='color_orange'>update:46</span>, v:4 <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16; n$17|->{next:null <span class='color_orange'>update:46</span>, v:3 <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16; &amp;x|->n$1580 <span class='color_orange'>update:45</span>:node*; &amp;n|->n$17 <span class='color_orange'>update:58</span>:node*; &amp;t|->n$17 <span class='color_orange'>update:53</span>:node*; &amp;#GB<src.c>$head|->n$1583 <span class='color_orange'>update:38</span>:node*; &amp;i|->4 <span class='color_orange'>update:43</span>:int; &amp;return|->n$1584 <span class='color_orange'>initial</span>:int; lsegne(n$1583,n$1581,[],lam [_t$0,_t$1,]. exists [_t$2]. _t$0|->{next:_t$1 <span class='color_orange'>update:56</span>, v:_t$2 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16)
      Instantiated post:
      PROP 1 of 1:
      <span class='color_blue'><span class='color_red'>(-1  &lt;  _t$2883)</span>; <span class='color_red'>DANGL &lt; UNINIT &gt; (return|callee)</span> ;
      <span class='color_red'>return|callee = _t$2883 <span class='color_orange'>update:54</span>:int</span></span>
      
    ***** RESULTS FUNCTION CALL *******
    PROP 1 of 1:
    <span class='color_blue'><span class='color_blue'>n$18 = 3</span> ;
    <span class='color_red'>(-1  &lt;  n$19)</span>; <span class='color_blue'>t != 0</span>; <span class='color_blue'>MEMma &lt; malloc:38 &gt;  <span class='color_orange'>{vpath: }</span>(n$1583)</span>; <span class='color_blue'>MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(x)</span>; <span class='color_red'>DANGL &lt; UNINIT &gt; (n$19)</span> ;
    <span class='color_blue'>x = n$1580 <span class='color_orange'>update:45</span>:node*</span>; <span class='color_blue'>n = n$17 <span class='color_orange'>update:58</span>:node*</span>; <span class='color_blue'>t = n$17 <span class='color_orange'>update:53</span>:node*</span>; <span class='color_blue'>#GB<src.c>$head = n$1583 <span class='color_orange'>update:38</span>:node*</span>; <span class='color_blue'>i = 4 <span class='color_orange'>update:43</span>:int</span>; <span class='color_blue'>return = n$1584 <span class='color_orange'>initial</span>:int</span> ;
    <span class='color_blue'>n$1581|->{next:t <span class='color_orange'>update:56</span>, v:n$1582 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16</span>; <span class='color_blue'>x|->{next:null <span class='color_orange'>update:46</span>, v:4 <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16</span>; <span class='color_blue'>t|->{next:null <span class='color_orange'>update:46</span>, v:3 <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16</span>; <span class='color_blue'>lsegne(n$1583,n$1581,[],P0)</span>
    [footprint
       <span class='color_blue'>t = @f$1</span>; <span class='color_blue'>@f$2 != 0</span> *
       <span class='color_blue'>#GB<src.c>$head = @f$0 <span class='color_orange'>rearrange:38</span>:node*</span>  ]
    where
    P0 = exists [_t$2]. <span class='color_blue'>_t$0|->{next:_t$1 <span class='color_orange'>update:56</span>, v:_t$2 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16</span></span>
    ***** END RESULTS FUNCTION CALL *******
    Instruction Returns
    PROP 1 of 1:
    <span class='color_blue'><span class='color_blue'>n$18 = 3</span> ;
    <span class='color_red'>(-1  &lt;  n$19)</span>; <span class='color_blue'>t != 0</span>; <span class='color_blue'>MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(x)</span>; <span class='color_blue'>MEMma &lt; malloc:38 &gt;  <span class='color_orange'>{vpath: }</span>(_t$1)</span>; <span class='color_red'>DANGL &lt; UNINIT &gt; (n$19)</span> ;
    <span class='color_blue'>x = _t$4 <span class='color_orange'>update:45</span>:node*</span>; <span class='color_blue'>n = n$17 <span class='color_orange'>update:58</span>:node*</span>; <span class='color_blue'>t = n$17 <span class='color_orange'>update:53</span>:node*</span>; <span class='color_blue'>#GB<src.c>$head = _t$1 <span class='color_orange'>update:38</span>:node*</span>; <span class='color_blue'>i = 4 <span class='color_orange'>update:43</span>:int</span>; <span class='color_blue'>return = _t$0 <span class='color_orange'>initial</span>:int</span> ;
    <span class='color_blue'>x|->{next:null <span class='color_orange'>update:46</span>, v:4 <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16</span>; <span class='color_blue'>_t$2|->{next:t <span class='color_orange'>update:56</span>, v:_t$3 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16</span>; <span class='color_blue'>t|->{next:null <span class='color_orange'>update:46</span>, v:3 <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16</span>; <span class='color_blue'>lsegne(_t$1,_t$2,[],P0)</span>
    [footprint
       <span class='color_blue'>t = @f$1</span>; <span class='color_blue'>@f$2 != 0</span> *
       <span class='color_blue'>#GB<src.c>$head = @f$0 <span class='color_orange'>rearrange:38</span>:node*</span>  ]
    where
    P0 = exists [_t$2]. <span class='color_blue'>_t$0|->{next:_t$1 <span class='color_orange'>update:56</span>, v:_t$2 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16</span></span>
    
    Instruction <span class='color_green'>REMOVE_TEMPS(n$17,n$18,n$19); [line 54, column 7]</span>
    in vpath_find exp:_t$6
    vpath_find: found x : node*
    in vpath_find exp:_t$1
    vpath_find: found head : node*
    Instruction Returns
    PROP 1 of 1:
    <span class='color_blue'><span class='color_red'>(-1  &lt;  _t$9)</span>; <span class='color_red'>t != 0</span>; <span class='color_red'>MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(x)</span>; <span class='color_blue'>MEMma &lt; malloc:38 &gt;  <span class='color_orange'>{vpath: }</span>(_t$1)</span>; <span class='color_red'>DANGL &lt; UNINIT &gt; (_t$9)</span>; <span class='color_blue'>DANGL &lt; UNINIT &gt; (_t$6)</span> ;
    <span class='color_blue'>x = <span class='color_red'>_t$8 <span class='color_orange'>update:45</span></span>:node*</span>; <span class='color_blue'>n = <span class='color_red'>_t$7 <span class='color_orange'>update:58</span></span>:node*</span>; <span class='color_blue'>t = <span class='color_red'>_t$3 <span class='color_orange'>update:53</span></span>:node*</span>; <span class='color_blue'>#GB<src.c>$head = _t$1 <span class='color_orange'>update:38</span>:node*</span>; <span class='color_blue'>i = 4 <span class='color_orange'>update:43</span>:int</span>; <span class='color_blue'>return = _t$0 <span class='color_orange'>initial</span>:int</span> ;
    <span class='color_red'>x|->{next:null <span class='color_orange'>update:46</span>, v:4 <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16</span>; <span class='color_red'>n|->{next:null <span class='color_orange'>update:46</span>, v:3 <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16</span>; <span class='color_red'>t|->{next:_t$5 <span class='color_orange'>update:56</span>, v:_t$6 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16</span>; <span class='color_blue'>_t$2|->{next:<span class='color_red'>t <span class='color_orange'>update:56</span></span>, v:<span class='color_red'>_t$4 <span class='color_orange'>alloc</span></span>} <span class='color_orange'>alloc</span>:node16</span>; <span class='color_blue'>lsegne(_t$1,_t$2,[],P0)</span>; <span class='color_blue'>lseg(_t$5,n,[],P0)</span>
    [footprint
       <span class='color_blue'>@f$1 != 0</span> *
       <span class='color_blue'>#GB<src.c>$head = @f$0 <span class='color_orange'>rearrange:38</span>:node*</span>  ]
    where
    P0 = exists [_t$2]. <span class='color_blue'>_t$0|->{next:_t$1 <span class='color_orange'>update:56</span>, v:_t$2 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16</span></span>
    
    Instruction <span class='color_green'>REMOVE_TEMPS(n$17,n$18,n$19); [line 54, column 7]</span>
    in vpath_find exp:_t$4
    vpath_find: found x : node*
    in vpath_find exp:_t$1
    vpath_find: found head : node*
    Instruction Returns
    PROP 1 of 1:
    <span class='color_blue'><span class='color_red'>(-1  &lt;  _t$6)</span>; <span class='color_red'>t != 0</span>; <span class='color_red'>MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(x)</span>; <span class='color_blue'>MEMma &lt; malloc:38 &gt;  <span class='color_orange'>{vpath: }</span>(_t$1)</span>; <span class='color_red'>DANGL &lt; UNINIT &gt; (_t$6)</span> ;
    <span class='color_blue'>x = <span class='color_red'>_t$5 <span class='color_orange'>update:45</span></span>:node*</span>; <span class='color_blue'>n = <span class='color_red'>_t$3 <span class='color_orange'>update:58</span></span>:node*</span>; <span class='color_blue'>t = <span class='color_red'>_t$3 <span class='color_orange'>update:53</span></span>:node*</span>; <span class='color_blue'>#GB<src.c>$head = _t$1 <span class='color_orange'>update:38</span>:node*</span>; <span class='color_blue'>i = 4 <span class='color_orange'>update:43</span>:int</span>; <span class='color_blue'>return = _t$0 <span class='color_orange'>initial</span>:int</span> ;
    <span class='color_red'>x|->{next:null <span class='color_orange'>update:46</span>, v:4 <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16</span>; <span class='color_red'>t|->{next:null <span class='color_orange'>update:46</span>, v:3 <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16</span>; <span class='color_blue'>_t$2|->{next:<span class='color_red'>t <span class='color_orange'>update:56</span></span>, v:<span class='color_red'>_t$4 <span class='color_orange'>alloc</span></span>} <span class='color_orange'>alloc</span>:node16</span>; <span class='color_blue'>lsegne(_t$1,_t$2,[],P0)</span>
    [footprint
       <span class='color_blue'>@f$2 = @f$1</span>; <span class='color_red'>@f$3 != 0</span> *
       <span class='color_blue'>#GB<src.c>$head = @f$0 <span class='color_orange'>rearrange:38</span>:node*</span>  ]
    where
    P0 = exists [_t$2]. <span class='color_blue'>_t$0|->{next:_t$1 <span class='color_orange'>update:56</span>, v:_t$2 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16</span></span>
    
    Instruction <span class='color_green'>APPLY_ABSTRACTION; [line 54, column 7]</span>
    in vpath_find exp:_t$8
    vpath_find: found x : node*
    in vpath_find exp:_t$1
    vpath_find: found head : node*
    <span class='color_blue'>t != 0; MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(x); MEMma &lt; malloc:38 &gt;  <span class='color_orange'>{vpath: }</span>(_t$1) ;
    x = _t$4 <span class='color_orange'>update:45</span>:node*; n = _t$3 <span class='color_orange'>update:58</span>:node*; t = _t$2 <span class='color_orange'>update:53</span>:node*; #GB<src.c>$head = _t$1 <span class='color_orange'>update:38</span>:node*; i = 4 <span class='color_orange'>update:43</span>:int; return = _t$0 <span class='color_orange'>initial</span>:int ;
    x|->{next:null <span class='color_orange'>update:46</span>, v:4 <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16; n|->{next:null <span class='color_orange'>update:46</span>, v:3 <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16; lsegne(t,n,[],P0); lsegne(_t$1,t,[],P0)
    [footprint
       #GB<src.c>$head = @f$0 <span class='color_orange'>rearrange:38</span>:node*  ]
    where
    P0 = exists [_t$2]. _t$0|->{next:_t$1 <span class='color_orange'>update:56</span>, v:_t$2 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16</span>
    Instruction Returns
    PROP 1 of 1:
    <span class='color_blue'><span class='color_red'>t != 0</span>; <span class='color_red'>MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(x)</span>; <span class='color_blue'>MEMma &lt; malloc:38 &gt;  <span class='color_orange'>{vpath: }</span>(_t$1)</span> ;
    <span class='color_blue'>x = <span class='color_red'>_t$4 <span class='color_orange'>update:45</span></span>:node*</span>; <span class='color_blue'>n = <span class='color_red'>_t$3 <span class='color_orange'>update:58</span></span>:node*</span>; <span class='color_blue'>t = <span class='color_red'>_t$2 <span class='color_orange'>update:53</span></span>:node*</span>; <span class='color_blue'>#GB<src.c>$head = _t$1 <span class='color_orange'>update:38</span>:node*</span>; <span class='color_blue'>i = 4 <span class='color_orange'>update:43</span>:int</span>; <span class='color_blue'>return = _t$0 <span class='color_orange'>initial</span>:int</span> ;
    <span class='color_red'>x|->{next:null <span class='color_orange'>update:46</span>, v:4 <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16</span>; <span class='color_blue'>n|->{next:<span class='color_red'>null <span class='color_orange'>update:46</span></span>, v:<span class='color_red'>3 <span class='color_orange'>update:47</span></span>} <span class='color_orange'>alloc</span>:node16</span>; <span class='color_blue'>lsegne(t,n,[],P0)</span>; <span class='color_blue'>lsegne(_t$1,t,[],P0)</span>
    [footprint
       <span class='color_blue'>#GB<src.c>$head = @f$0 <span class='color_orange'>rearrange:38</span>:node*</span>  ]
    where
    P0 = exists [_t$2]. <span class='color_blue'>_t$0|->{next:_t$1 <span class='color_orange'>update:56</span>, v:_t$2 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16</span></span>
    
    Instruction <span class='color_green'>APPLY_ABSTRACTION; [line 54, column 7]</span>
    in vpath_find exp:_t$5
    vpath_find: found x : node*
    in vpath_find exp:_t$1
    vpath_find: found head : node*
    <span class='color_blue'>t != 0; MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(x); MEMma &lt; malloc:38 &gt;  <span class='color_orange'>{vpath: }</span>(_t$1) ;
    x = _t$3 <span class='color_orange'>update:45</span>:node*; n = _t$2 <span class='color_orange'>update:58</span>:node*; t = _t$2 <span class='color_orange'>update:53</span>:node*; #GB<src.c>$head = _t$1 <span class='color_orange'>update:38</span>:node*; i = 4 <span class='color_orange'>update:43</span>:int; return = _t$0 <span class='color_orange'>initial</span>:int ;
    x|->{next:null <span class='color_orange'>update:46</span>, v:4 <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16; t|->{next:null <span class='color_orange'>update:46</span>, v:3 <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16; lsegne(_t$1,t,[],P0)
    [footprint
       #GB<src.c>$head = @f$0 <span class='color_orange'>rearrange:38</span>:node*  ]
    where
    P0 = exists [_t$2]. _t$0|->{next:_t$1 <span class='color_orange'>update:56</span>, v:_t$2 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16</span>
    Instruction Returns
    PROP 1 of 1:
    <span class='color_blue'><span class='color_red'>t != 0</span>; <span class='color_blue'>MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(x)</span>; <span class='color_blue'>MEMma &lt; malloc:38 &gt;  <span class='color_orange'>{vpath: }</span>(_t$1)</span> ;
    <span class='color_blue'>x = <span class='color_red'>_t$3 <span class='color_orange'>update:45</span></span>:node*</span>; <span class='color_blue'>n = <span class='color_red'>_t$2 <span class='color_orange'>update:58</span></span>:node*</span>; <span class='color_blue'>t = <span class='color_red'>_t$2 <span class='color_orange'>update:53</span></span>:node*</span>; <span class='color_blue'>#GB<src.c>$head = _t$1 <span class='color_orange'>update:38</span>:node*</span>; <span class='color_blue'>i = 4 <span class='color_orange'>update:43</span>:int</span>; <span class='color_blue'>return = _t$0 <span class='color_orange'>initial</span>:int</span> ;
    <span class='color_blue'>x|->{next:null <span class='color_orange'>update:46</span>, v:<span class='color_red'>4 <span class='color_orange'>update:47</span></span>} <span class='color_orange'>alloc</span>:node16</span>; <span class='color_blue'>t|->{next:<span class='color_red'>null <span class='color_orange'>update:46</span></span>, v:<span class='color_red'>3 <span class='color_orange'>update:47</span></span>} <span class='color_orange'>alloc</span>:node16</span>; <span class='color_blue'>lsegne(_t$1,t,[],P0)</span>
    [footprint
       <span class='color_blue'>#GB<src.c>$head = @f$0 <span class='color_orange'>rearrange:38</span>:node*</span>  ]
    where
    P0 = exists [_t$2]. <span class='color_blue'>_t$0|->{next:_t$1 <span class='color_orange'>update:56</span>, v:_t$2 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16</span></span>
    
    .... After Symbolic Execution ....
    PROP 1 of 2:
    <span class='color_blue'><span class='color_red'>t != 0</span>; <span class='color_red'>MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(x)</span>; <span class='color_blue'>MEMma &lt; malloc:38 &gt;  <span class='color_orange'>{vpath: }</span>(_t$1)</span> ;
    <span class='color_blue'>x = <span class='color_red'>_t$4 <span class='color_orange'>update:45</span></span>:node*</span>; <span class='color_blue'>n = <span class='color_red'>_t$3 <span class='color_orange'>update:58</span></span>:node*</span>; <span class='color_blue'>t = <span class='color_red'>_t$2 <span class='color_orange'>update:53</span></span>:node*</span>; <span class='color_blue'>#GB<src.c>$head = _t$1 <span class='color_orange'>update:38</span>:node*</span>; <span class='color_blue'>i = 4 <span class='color_orange'>update:43</span>:int</span>; <span class='color_blue'>return = _t$0 <span class='color_orange'>initial</span>:int</span> ;
    <span class='color_red'>x|->{next:null <span class='color_orange'>update:46</span>, v:4 <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16</span>; <span class='color_blue'>n|->{next:null <span class='color_orange'>update:46</span>, v:3 <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16</span>; <span class='color_blue'>lsegne(t,n,[],P0)</span>; <span class='color_blue'>lsegne(_t$1,t,[],P0)</span>
    [footprint
       <span class='color_blue'>#GB<src.c>$head = @f$0 <span class='color_orange'>rearrange:38</span>:node*</span>  ]
    where
    P0 = exists [_t$2]. <span class='color_blue'>_t$0|->{next:_t$1 <span class='color_orange'>update:56</span>, v:_t$2 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16</span></span>
    PROP 2 of 2:
    <span class='color_blue'><span class='color_red'>t != 0</span>; <span class='color_blue'>MEMma &lt; malloc:45 &gt;  <span class='color_orange'>{vpath: }</span>(x)</span>; <span class='color_blue'>MEMma &lt; malloc:38 &gt;  <span class='color_orange'>{vpath: }</span>(_t$1)</span> ;
    <span class='color_blue'>x = <span class='color_red'>_t$3 <span class='color_orange'>update:45</span></span>:node*</span>; <span class='color_blue'>n = <span class='color_red'>_t$2 <span class='color_orange'>update:58</span></span>:node*</span>; <span class='color_blue'>t = <span class='color_red'>_t$2 <span class='color_orange'>update:53</span></span>:node*</span>; <span class='color_blue'>#GB<src.c>$head = _t$1 <span class='color_orange'>update:38</span>:node*</span>; <span class='color_blue'>i = 4 <span class='color_orange'>update:43</span>:int</span>; <span class='color_blue'>return = _t$0 <span class='color_orange'>initial</span>:int</span> ;
    <span class='color_blue'>x|->{next:null <span class='color_orange'>update:46</span>, v:4 <span class='color_orange'>update:47</span>} <span class='color_orange'>alloc</span>:node16</span>; <span class='color_blue'>t|->{next:<span class='color_red'>null <span class='color_orange'>update:46</span></span>, v:<span class='color_red'>3 <span class='color_orange'>update:47</span></span>} <span class='color_orange'>alloc</span>:node16</span>; <span class='color_blue'>lsegne(_t$1,t,[],P0)</span>
    [footprint
       <span class='color_blue'>#GB<src.c>$head = @f$0 <span class='color_orange'>rearrange:38</span>:node*</span>  ]
    where
    P0 = exists [_t$2]. <span class='color_blue'>_t$0|->{next:_t$1 <span class='color_orange'>update:56</span>, v:_t$2 <span class='color_orange'>alloc</span>} <span class='color_orange'>alloc</span>:node16</span></span>
    
    
    
  </LISTING></span>